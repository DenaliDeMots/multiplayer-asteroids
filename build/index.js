/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/acorn/dist/acorn.es.js":
/*!*********************************************!*\
  !*** ./node_modules/acorn/dist/acorn.es.js ***!
  \*********************************************/
/*! exports provided: version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, tokTypes, keywordTypes, TokContext, tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseExpressionAt\", function() { return parseExpressionAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenizer\", function() { return tokenizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse_dammit\", function() { return parse_dammit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LooseParser\", function() { return LooseParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pluginsLoose\", function() { return pluginsLoose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLooseExports\", function() { return addLooseExports; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plugins\", function() { return plugins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultOptions\", function() { return defaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SourceLocation\", function() { return SourceLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLineInfo\", function() { return getLineInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenType\", function() { return TokenType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokTypes\", function() { return types; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keywordTypes\", function() { return keywords$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokContext\", function() { return TokContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokContexts\", function() { return types$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifierChar\", function() { return isIdentifierChar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifierStart\", function() { return isIdentifierStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNewLine\", function() { return isNewLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineBreak\", function() { return lineBreak; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineBreakG\", function() { return lineBreakG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nonASCIIwhitespace\", function() { return nonASCIIwhitespace; });\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312e\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fea\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,55,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,698,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,1,31,6124,20,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,19719,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType == \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) == \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind != \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (!declaration) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init)) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.type == types._function);\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type == types._function) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type != types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    this.expect(types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.enterLexicalScope();\n    this.checkLVal(clause.param, \"let\");\n    this.expect(types.parenR);\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart == node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && node.body.kind != \"var\" ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  if (type == \"ForInStatement\") {\n    if (init.type === \"AssignmentPattern\" ||\n      (init.type === \"VariableDeclaration\" && init.declarations[0].init != null &&\n       (this.strict || init.declarations[0].id.type !== \"Identifier\")))\n      { this.raise(init.start, \"Invalid assignment in for-in loop head\"); }\n  }\n  node.left = init;\n  node.right = type == \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type != types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type == types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var member = this$1.parseClassMember(classBody);\n    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n      hadConstructor = true;\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMember = function(classBody) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type == \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type == \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop);\n      } }\n  else if (type == \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type == \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type == \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type == \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type == \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this$1.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this$1.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type == \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type == \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type == types.parenL || this.type == types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start == startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n    node = this.startNode();\n    this.next();\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super Arguments\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc)\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != types.comma && this.type != types.braceR)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") != -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved == \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType == types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)\n    { return true }\n  if (prevType == types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType == types._var || prevType == types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType == types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType == types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6) {\n    if (this.value == \"of\" && !this.exprAllowed ||\n        this.value == \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\nvar data = {\n  \"$LONE\": [\n    \"ASCII\",\n    \"ASCII_Hex_Digit\",\n    \"AHex\",\n    \"Alphabetic\",\n    \"Alpha\",\n    \"Any\",\n    \"Assigned\",\n    \"Bidi_Control\",\n    \"Bidi_C\",\n    \"Bidi_Mirrored\",\n    \"Bidi_M\",\n    \"Case_Ignorable\",\n    \"CI\",\n    \"Cased\",\n    \"Changes_When_Casefolded\",\n    \"CWCF\",\n    \"Changes_When_Casemapped\",\n    \"CWCM\",\n    \"Changes_When_Lowercased\",\n    \"CWL\",\n    \"Changes_When_NFKC_Casefolded\",\n    \"CWKCF\",\n    \"Changes_When_Titlecased\",\n    \"CWT\",\n    \"Changes_When_Uppercased\",\n    \"CWU\",\n    \"Dash\",\n    \"Default_Ignorable_Code_Point\",\n    \"DI\",\n    \"Deprecated\",\n    \"Dep\",\n    \"Diacritic\",\n    \"Dia\",\n    \"Emoji\",\n    \"Emoji_Component\",\n    \"Emoji_Modifier\",\n    \"Emoji_Modifier_Base\",\n    \"Emoji_Presentation\",\n    \"Extender\",\n    \"Ext\",\n    \"Grapheme_Base\",\n    \"Gr_Base\",\n    \"Grapheme_Extend\",\n    \"Gr_Ext\",\n    \"Hex_Digit\",\n    \"Hex\",\n    \"IDS_Binary_Operator\",\n    \"IDSB\",\n    \"IDS_Trinary_Operator\",\n    \"IDST\",\n    \"ID_Continue\",\n    \"IDC\",\n    \"ID_Start\",\n    \"IDS\",\n    \"Ideographic\",\n    \"Ideo\",\n    \"Join_Control\",\n    \"Join_C\",\n    \"Logical_Order_Exception\",\n    \"LOE\",\n    \"Lowercase\",\n    \"Lower\",\n    \"Math\",\n    \"Noncharacter_Code_Point\",\n    \"NChar\",\n    \"Pattern_Syntax\",\n    \"Pat_Syn\",\n    \"Pattern_White_Space\",\n    \"Pat_WS\",\n    \"Quotation_Mark\",\n    \"QMark\",\n    \"Radical\",\n    \"Regional_Indicator\",\n    \"RI\",\n    \"Sentence_Terminal\",\n    \"STerm\",\n    \"Soft_Dotted\",\n    \"SD\",\n    \"Terminal_Punctuation\",\n    \"Term\",\n    \"Unified_Ideograph\",\n    \"UIdeo\",\n    \"Uppercase\",\n    \"Upper\",\n    \"Variation_Selector\",\n    \"VS\",\n    \"White_Space\",\n    \"space\",\n    \"XID_Continue\",\n    \"XIDC\",\n    \"XID_Start\",\n    \"XIDS\"\n  ],\n  \"General_Category\": [\n    \"Cased_Letter\",\n    \"LC\",\n    \"Close_Punctuation\",\n    \"Pe\",\n    \"Connector_Punctuation\",\n    \"Pc\",\n    \"Control\",\n    \"Cc\",\n    \"cntrl\",\n    \"Currency_Symbol\",\n    \"Sc\",\n    \"Dash_Punctuation\",\n    \"Pd\",\n    \"Decimal_Number\",\n    \"Nd\",\n    \"digit\",\n    \"Enclosing_Mark\",\n    \"Me\",\n    \"Final_Punctuation\",\n    \"Pf\",\n    \"Format\",\n    \"Cf\",\n    \"Initial_Punctuation\",\n    \"Pi\",\n    \"Letter\",\n    \"L\",\n    \"Letter_Number\",\n    \"Nl\",\n    \"Line_Separator\",\n    \"Zl\",\n    \"Lowercase_Letter\",\n    \"Ll\",\n    \"Mark\",\n    \"M\",\n    \"Combining_Mark\",\n    \"Math_Symbol\",\n    \"Sm\",\n    \"Modifier_Letter\",\n    \"Lm\",\n    \"Modifier_Symbol\",\n    \"Sk\",\n    \"Nonspacing_Mark\",\n    \"Mn\",\n    \"Number\",\n    \"N\",\n    \"Open_Punctuation\",\n    \"Ps\",\n    \"Other\",\n    \"C\",\n    \"Other_Letter\",\n    \"Lo\",\n    \"Other_Number\",\n    \"No\",\n    \"Other_Punctuation\",\n    \"Po\",\n    \"Other_Symbol\",\n    \"So\",\n    \"Paragraph_Separator\",\n    \"Zp\",\n    \"Private_Use\",\n    \"Co\",\n    \"Punctuation\",\n    \"P\",\n    \"punct\",\n    \"Separator\",\n    \"Z\",\n    \"Space_Separator\",\n    \"Zs\",\n    \"Spacing_Mark\",\n    \"Mc\",\n    \"Surrogate\",\n    \"Cs\",\n    \"Symbol\",\n    \"S\",\n    \"Titlecase_Letter\",\n    \"Lt\",\n    \"Unassigned\",\n    \"Cn\",\n    \"Uppercase_Letter\",\n    \"Lu\"\n  ],\n  \"Script\": [\n    \"Adlam\",\n    \"Adlm\",\n    \"Ahom\",\n    \"Anatolian_Hieroglyphs\",\n    \"Hluw\",\n    \"Arabic\",\n    \"Arab\",\n    \"Armenian\",\n    \"Armn\",\n    \"Avestan\",\n    \"Avst\",\n    \"Balinese\",\n    \"Bali\",\n    \"Bamum\",\n    \"Bamu\",\n    \"Bassa_Vah\",\n    \"Bass\",\n    \"Batak\",\n    \"Batk\",\n    \"Bengali\",\n    \"Beng\",\n    \"Bhaiksuki\",\n    \"Bhks\",\n    \"Bopomofo\",\n    \"Bopo\",\n    \"Brahmi\",\n    \"Brah\",\n    \"Braille\",\n    \"Brai\",\n    \"Buginese\",\n    \"Bugi\",\n    \"Buhid\",\n    \"Buhd\",\n    \"Canadian_Aboriginal\",\n    \"Cans\",\n    \"Carian\",\n    \"Cari\",\n    \"Caucasian_Albanian\",\n    \"Aghb\",\n    \"Chakma\",\n    \"Cakm\",\n    \"Cham\",\n    \"Cherokee\",\n    \"Cher\",\n    \"Common\",\n    \"Zyyy\",\n    \"Coptic\",\n    \"Copt\",\n    \"Qaac\",\n    \"Cuneiform\",\n    \"Xsux\",\n    \"Cypriot\",\n    \"Cprt\",\n    \"Cyrillic\",\n    \"Cyrl\",\n    \"Deseret\",\n    \"Dsrt\",\n    \"Devanagari\",\n    \"Deva\",\n    \"Duployan\",\n    \"Dupl\",\n    \"Egyptian_Hieroglyphs\",\n    \"Egyp\",\n    \"Elbasan\",\n    \"Elba\",\n    \"Ethiopic\",\n    \"Ethi\",\n    \"Georgian\",\n    \"Geor\",\n    \"Glagolitic\",\n    \"Glag\",\n    \"Gothic\",\n    \"Goth\",\n    \"Grantha\",\n    \"Gran\",\n    \"Greek\",\n    \"Grek\",\n    \"Gujarati\",\n    \"Gujr\",\n    \"Gurmukhi\",\n    \"Guru\",\n    \"Han\",\n    \"Hani\",\n    \"Hangul\",\n    \"Hang\",\n    \"Hanunoo\",\n    \"Hano\",\n    \"Hatran\",\n    \"Hatr\",\n    \"Hebrew\",\n    \"Hebr\",\n    \"Hiragana\",\n    \"Hira\",\n    \"Imperial_Aramaic\",\n    \"Armi\",\n    \"Inherited\",\n    \"Zinh\",\n    \"Qaai\",\n    \"Inscriptional_Pahlavi\",\n    \"Phli\",\n    \"Inscriptional_Parthian\",\n    \"Prti\",\n    \"Javanese\",\n    \"Java\",\n    \"Kaithi\",\n    \"Kthi\",\n    \"Kannada\",\n    \"Knda\",\n    \"Katakana\",\n    \"Kana\",\n    \"Kayah_Li\",\n    \"Kali\",\n    \"Kharoshthi\",\n    \"Khar\",\n    \"Khmer\",\n    \"Khmr\",\n    \"Khojki\",\n    \"Khoj\",\n    \"Khudawadi\",\n    \"Sind\",\n    \"Lao\",\n    \"Laoo\",\n    \"Latin\",\n    \"Latn\",\n    \"Lepcha\",\n    \"Lepc\",\n    \"Limbu\",\n    \"Limb\",\n    \"Linear_A\",\n    \"Lina\",\n    \"Linear_B\",\n    \"Linb\",\n    \"Lisu\",\n    \"Lycian\",\n    \"Lyci\",\n    \"Lydian\",\n    \"Lydi\",\n    \"Mahajani\",\n    \"Mahj\",\n    \"Malayalam\",\n    \"Mlym\",\n    \"Mandaic\",\n    \"Mand\",\n    \"Manichaean\",\n    \"Mani\",\n    \"Marchen\",\n    \"Marc\",\n    \"Masaram_Gondi\",\n    \"Gonm\",\n    \"Meetei_Mayek\",\n    \"Mtei\",\n    \"Mende_Kikakui\",\n    \"Mend\",\n    \"Meroitic_Cursive\",\n    \"Merc\",\n    \"Meroitic_Hieroglyphs\",\n    \"Mero\",\n    \"Miao\",\n    \"Plrd\",\n    \"Modi\",\n    \"Mongolian\",\n    \"Mong\",\n    \"Mro\",\n    \"Mroo\",\n    \"Multani\",\n    \"Mult\",\n    \"Myanmar\",\n    \"Mymr\",\n    \"Nabataean\",\n    \"Nbat\",\n    \"New_Tai_Lue\",\n    \"Talu\",\n    \"Newa\",\n    \"Nko\",\n    \"Nkoo\",\n    \"Nushu\",\n    \"Nshu\",\n    \"Ogham\",\n    \"Ogam\",\n    \"Ol_Chiki\",\n    \"Olck\",\n    \"Old_Hungarian\",\n    \"Hung\",\n    \"Old_Italic\",\n    \"Ital\",\n    \"Old_North_Arabian\",\n    \"Narb\",\n    \"Old_Permic\",\n    \"Perm\",\n    \"Old_Persian\",\n    \"Xpeo\",\n    \"Old_South_Arabian\",\n    \"Sarb\",\n    \"Old_Turkic\",\n    \"Orkh\",\n    \"Oriya\",\n    \"Orya\",\n    \"Osage\",\n    \"Osge\",\n    \"Osmanya\",\n    \"Osma\",\n    \"Pahawh_Hmong\",\n    \"Hmng\",\n    \"Palmyrene\",\n    \"Palm\",\n    \"Pau_Cin_Hau\",\n    \"Pauc\",\n    \"Phags_Pa\",\n    \"Phag\",\n    \"Phoenician\",\n    \"Phnx\",\n    \"Psalter_Pahlavi\",\n    \"Phlp\",\n    \"Rejang\",\n    \"Rjng\",\n    \"Runic\",\n    \"Runr\",\n    \"Samaritan\",\n    \"Samr\",\n    \"Saurashtra\",\n    \"Saur\",\n    \"Sharada\",\n    \"Shrd\",\n    \"Shavian\",\n    \"Shaw\",\n    \"Siddham\",\n    \"Sidd\",\n    \"SignWriting\",\n    \"Sgnw\",\n    \"Sinhala\",\n    \"Sinh\",\n    \"Sora_Sompeng\",\n    \"Sora\",\n    \"Soyombo\",\n    \"Soyo\",\n    \"Sundanese\",\n    \"Sund\",\n    \"Syloti_Nagri\",\n    \"Sylo\",\n    \"Syriac\",\n    \"Syrc\",\n    \"Tagalog\",\n    \"Tglg\",\n    \"Tagbanwa\",\n    \"Tagb\",\n    \"Tai_Le\",\n    \"Tale\",\n    \"Tai_Tham\",\n    \"Lana\",\n    \"Tai_Viet\",\n    \"Tavt\",\n    \"Takri\",\n    \"Takr\",\n    \"Tamil\",\n    \"Taml\",\n    \"Tangut\",\n    \"Tang\",\n    \"Telugu\",\n    \"Telu\",\n    \"Thaana\",\n    \"Thaa\",\n    \"Thai\",\n    \"Tibetan\",\n    \"Tibt\",\n    \"Tifinagh\",\n    \"Tfng\",\n    \"Tirhuta\",\n    \"Tirh\",\n    \"Ugaritic\",\n    \"Ugar\",\n    \"Vai\",\n    \"Vaii\",\n    \"Warang_Citi\",\n    \"Wara\",\n    \"Yi\",\n    \"Yiii\",\n    \"Zanabazar_Square\",\n    \"Zanb\"\n  ]\n};\nArray.prototype.push.apply(data.$LONE, data.General_Category);\ndata.gc = data.General_Category;\ndata.sc = data.Script_Extensions = data.scx = data.Script;\n\nvar pp$9 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current () {\n  return this.at(this.pos)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead () {\n  return this.at(this.nextIndex(this.pos))\n};\n\nRegExpValidationState.prototype.advance = function advance () {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true\n  }\n  return false\n};\n\nfunction codePointToString$1(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpFlags = function(state) {\n  var this$1 = this;\n\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) == -1) {\n      this$1.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this$1.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$9.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$9.regexp_disjunction = function(state) {\n  var this$1 = this;\n\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this$1.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$9.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    {  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$9.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$9.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$9.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$9.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$9.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$9.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$9.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$9.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$9.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$9.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$9.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$9.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$9.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString$1(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$9.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$9.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$9.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$9.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$9.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$9.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$9.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$9.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      state.switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$9.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$9.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$9.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\npp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (data.$LONE.indexOf(nameOrValue) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$9.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$9.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$9.regexp_classRanges = function(state) {\n  var this$1 = this;\n\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$9.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$9.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$9.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$9.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$9.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$9.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code == 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next == 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next == 33 && code == 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch == 56 || ch == 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.5.3\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5lcy5qcz9lNGUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7O0FBRWxCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBLDBCQUEwQixJQUFJLG1DQUFtQztBQUNqRSwwQkFBMEI7QUFDMUIsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxtQ0FBbUM7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQ0FBaUM7QUFDM0QsK0JBQStCLGlDQUFpQztBQUNoRSxrQ0FBa0MsOENBQThDO0FBQ2hGLGdDQUFnQyxpREFBaUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyREFBMkQ7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUMsaUNBQWlDLDJCQUEyQjtBQUM1RCx5QkFBeUIsaURBQWlEO0FBQzFFLHFCQUFxQixpREFBaUQ7QUFDdEUseUJBQXlCLGlEQUFpRDtBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0EsRUFBRSxFQUFFOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLHlFQUF5RTs7QUFFOUU7QUFDQSxLQUFLLDZCQUE2Qjs7QUFFbEM7QUFDQSxLQUFLLGlEQUFpRDs7QUFFdEQ7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBLEtBQUssNkRBQTZEOztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMERBQTBEO0FBQ2pFO0FBQ0EsT0FBTyw4QkFBOEI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxPQUFPLG1DQUFtQyxRQUFRO0FBQ2xELHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyx5QkFBeUI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQsa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUVBQXVFO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELG1CQUFtQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVFQUF1RTtBQUM5RTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLLDhHQUE4RztBQUNuSDtBQUNBLG9CQUFvQix3REFBd0Q7QUFDNUU7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUssd0dBQXdHO0FBQzdHO0FBQ0EsS0FBSywwRUFBMEU7QUFDL0U7O0FBRUE7QUFDQTtBQUNBLEtBQUsseUVBQXlFO0FBQzlFO0FBQ0EsS0FBSyx5RUFBeUU7QUFDOUU7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCLG1CQUFtQjs7QUFFbkI7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWMsTUFBTTtBQUMzRDtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0ZBQWtGO0FBQzNGO0FBQ0EsU0FBUywyRkFBMkY7QUFDcEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQWtEO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQkFBc0I7QUFDM0I7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZELFNBQVMsT0FBTywyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQsT0FBTyxPQUFPLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssd0RBQXdEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsc0JBQXNCO0FBQzdFLFFBQVEsd0NBQXdDLGtCQUFrQjtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5QkFBeUIsMEVBQTBFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNERBQTREO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkRBQTJEO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaURBQWlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0Esb0JBQW9CLHdEQUF3RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUVBQXVFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrRUFBa0U7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1Q0FBdUM7QUFDNUM7QUFDQSxLQUFLLHdCQUF3Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLDhEQUE4RDs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUVBQXVFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DLHlGQUF5RjtBQUN6RixxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtFQUFrRTtBQUNyRyxzQkFBc0IsMkRBQTJEO0FBQ2pGLGtCQUFrQiwrREFBK0Q7QUFDakY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJFQUEyRTtBQUNoRjtBQUNBLEtBQUssbUZBQW1GO0FBQ3hGO0FBQ0EsS0FBSyxzRkFBc0Y7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0VBQWtFO0FBQ3pFO0FBQ0EsT0FBTyxnRkFBZ0Y7QUFDdkY7QUFDQTtBQUNBLEdBQUcsT0FBTyxZQUFZLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxLQUFLLCtEQUErRDtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssZ0RBQWdEO0FBQ3JEO0FBQ0EsS0FBSyx1Q0FBdUMsaUJBQWlCO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLHlDQUF5QyxxQkFBcUI7QUFDbkU7O0FBRUEsa0JBQWtCLHlDQUF5QztBQUMzRCxLQUFLO0FBQ0w7QUFDQSxLQUFLLDZDQUE2QztBQUNsRDtBQUNBLEtBQUssNENBQTRDO0FBQ2pEO0FBQ0EsS0FBSyxnREFBZ0Q7QUFDckQ7QUFDQSxLQUFLLGtEQUFrRDtBQUN2RDs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQiwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxLQUFLLE9BQU8sZUFBZTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxLQUFLLE9BQU8sZUFBZTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUFtRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzRkFBc0Y7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyx1REFBdUQ7QUFDMUYsNkNBQTZDLGlCQUFpQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsNkVBQTZFO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyx1REFBdUQ7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEVBQThFO0FBQ3ZGOztBQUVBO0FBQ0Esa0NBQWtDLDBGQUEwRjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQ0FBbUMsdURBQXVEO0FBQzdGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsY0FBYyxxQ0FBcUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNDQUFzQztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxtQkFBbUI7O0FBRXhCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkVBQTZFO0FBQ3JIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlIQUFpSDtBQUN4SDtBQUNBO0FBQ0EsU0FBUywwREFBMEQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnRUFBZ0U7QUFDdEY7O0FBRUE7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTs7QUFFQSxlQUFlLG1EQUFtRDtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxnREFBZ0Q7QUFDL0g7QUFDQSxjQUFjLHdFQUF3RTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU8sOERBQThEO0FBQ3JFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4RUFBOEU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssb0NBQW9DO0FBQ3pDO0FBQ0EsdUJBQXVCLDREQUE0RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBa0Q7QUFDcEYsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQywwREFBMEQ7QUFDM0Y7QUFDQSw0QkFBNEIsNkRBQTZEO0FBQ3pGLDhCQUE4Qix5REFBeUQ7QUFDdkY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPLDZFQUE2RTtBQUNwRixVQUFVLGlCQUFpQjtBQUMzQjtBQUNBLEdBQUc7QUFDSDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EscUVBQXFFLGlEQUFpRDtBQUN0SCxtRUFBbUUsK0NBQStDO0FBQ2xIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFnRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG1CQUFtQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQW9EO0FBQzdEO0FBQ0EsU0FBUyxrREFBa0Q7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQ0FBMEMsNkVBQTZFO0FBQ3ZIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLG9DQUFvQztBQUM5RSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrR0FBa0c7QUFDekc7QUFDQSxPQUFPLCtFQUErRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5RkFBeUY7QUFDeEgsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUJBQW1CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsS0FBSyxPQUFPLGVBQWU7O0FBRTNCO0FBQ0EscUJBQXFCLCtEQUErRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9DQUFvQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLG1CQUFtQjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUE4RDtBQUN2RTtBQUNBLFNBQVMsc0VBQXNFO0FBQy9FLEtBQUs7QUFDTDtBQUNBLFNBQVMsb0ZBQW9GO0FBQzdGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyxxREFBcUQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPLG1CQUFtQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLDhCQUE4QjtBQUNuQztBQUNBLEtBQUssd0JBQXdCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0JBQXdCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnSEFBZ0g7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLEtBQUssT0FBTyxlQUFlOztBQUUzQjtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFNBQVMscURBQXFEO0FBQzlELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLHNGQUFzRjtBQUMzRjtBQUNBLEtBQUssNEZBQTRGO0FBQ2pHO0FBQ0EsS0FBSywwREFBMEQ7QUFDL0Q7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RkFBdUY7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsNEJBQTRCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsNEJBQTRCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGlCQUFpQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxhQUFhLGNBQWMsb0JBQW9CO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sYUFBYSxjQUFjOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDRDQUE0QztBQUNqRDtBQUNBLEtBQUssbURBQW1EO0FBQ3hEO0FBQ0EsS0FBSyx1QkFBdUI7QUFDNUI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0JBQW9CO0FBQ3pCO0FBQ0EsS0FBSyxxQkFBcUI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSx3REFBd0QsaUNBQWlDLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSywwQkFBMEI7QUFDL0I7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBLEtBQUssb0NBQW9DO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtQ0FBbUM7QUFDeEM7QUFDQSxLQUFLLG1DQUFtQztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQjtBQUN6QjtBQUNBLEtBQUssbUNBQW1DO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBDQUEwQztBQUNqRDtBQUNBLE9BQU8scUNBQXFDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0I7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdEQUF3RDtBQUM3RDtBQUNBLEtBQUssK0JBQStCO0FBQ3BDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLHVDQUF1Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGlDQUFpQyxLQUFLOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjs7QUFFbkU7QUFDQSwrQkFBK0Isb0NBQW9DO0FBQ25FLHNDQUFzQzs7QUFFdEMsNEJBQTRCO0FBQzVCLFFBQVEsMENBQTBDO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrREFBa0Q7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0EseUJBQXlCLFlBQVk7QUFDckMsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0Esc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0Esb0JBQW9CO0FBQ3BCLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtDQUFrQztBQUN4RTtBQUNBLHdDQUF3QyxpQ0FBaUM7QUFDekUsdUNBQXVDLGlDQUFpQztBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLHdEQUF3RDtBQUNwRztBQUNBLDZCQUE2Qix3REFBd0Q7QUFDckY7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDLHVDQUF1QyxpQkFBaUI7QUFDeEQsd0NBQXdDO0FBQ3hDO0FBQ0EsS0FBSyxPQUFPLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsNkNBQTZDO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQSxxQkFBcUIsc0JBQXNCLEVBQUU7QUFDN0MsMEJBQTBCLHNCQUFzQixFQUFFO0FBQ2xELHdDQUF3QyxpQkFBaUIsRUFBRTtBQUMzRCxVQUFVLGdCQUFnQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esb0JBQW9CLGlFQUFpRTtBQUNyRixvREFBb0QsMERBQTBEO0FBQzlHO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxxQ0FBcUM7QUFDekY7QUFDQSw2QkFBNkIscUNBQXFDO0FBQ2xFLGdFQUFnRSxlQUFlO0FBQy9FO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EscUNBQXFDLFlBQVksRUFBRTtBQUNuRCxvQ0FBb0MscUNBQXFDO0FBQ3pFO0FBQ0Esb0RBQW9ELDBEQUEwRDs7QUFFOUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsTUFBTTtBQUN6Qix1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsMEJBQTBCLDhEQUE4RDtBQUN4RixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCw0Q0FBNEMsNERBQTREO0FBQ3hHO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCLDREQUE0RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsNENBQTRDLHFEQUFxRDtBQUNqRztBQUNBLG9GQUFvRixZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw4QkFBOEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWSxFQUFFO0FBQ3RFO0FBQ0EsaUNBQWlDLDJCQUEyQixnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBbUU7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0ZBQW9GO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0RBQStEO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUVBQXlFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFUSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9hY29ybi9kaXN0L2Fjb3JuLmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVzZXJ2ZWQgd29yZCBsaXN0cyBmb3IgdmFyaW91cyBkaWFsZWN0cyBvZiB0aGUgbGFuZ3VhZ2VcblxudmFyIHJlc2VydmVkV29yZHMgPSB7XG4gIDM6IFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiLFxuICA1OiBcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIsXG4gIDY6IFwiZW51bVwiLFxuICBzdHJpY3Q6IFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiLFxuICBzdHJpY3RCaW5kOiBcImV2YWwgYXJndW1lbnRzXCJcbn07XG5cbi8vIEFuZCB0aGUga2V5d29yZHNcblxudmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxudmFyIGtleXdvcmRzID0ge1xuICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG4vLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGJkXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJlXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmVhXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YWVcXHVhN2IwLVxcdWE3YjdcXHVhN2Y3LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjVcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkNC1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwM1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmMi1cXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjYsNDUsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDc4NSw1Miw3Niw0NCwzMywyNCwyNywzNSw0MiwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMyw1NCw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDg2LDI1LDM5MSw2MywzMiwwLDI1NywwLDExLDM5LDgsMCwyMiwwLDEyLDM5LDMsMyw1NSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCw2OTgsOTIxLDEwMywxMTAsMTgsMTk1LDI3NDksMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDExNCwyOSwxOSw0NywxNywzLDMyLDIwLDYsMTgsODgxLDY4LDEyLDAsNjcsMTIsNjUsMSwzMSw2MTI0LDIwLDc1NCw5NDg2LDI4Niw4MiwzOTUsMjMwOSwxMDYsNiwxMiw0LDgsOCw5LDU5OTEsODQsMiw3MCwyLDEsMywwLDMsMSwzLDMsMiwxMSwyLDAsMiw2LDIsNjQsMiwzLDMsNywyLDYsMiwyNywyLDMsMiw0LDIsMCw0LDYsMiwzMzksMywyNCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDcsNDE0OSwxOTYsNjAsNjcsMTIxMywzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxMCw0Miw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MV07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDEzMDYsMiw1NCwxNCwzMiw5LDE2LDMsNDYsMTAsNTQsOSw3LDIsMzcsMTMsMiw5LDUyLDAsMTMsMiw0OSwxMywxMCwyLDQsOSw4MywxMSw3LDAsMTYxLDExLDYsOSw3LDMsNTcsMCwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw4NywxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSw0MjMsOSwyODAsOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDE5NzE5LDksMTM1LDQsNjAsNiwyNiw5LDEwMTYsNDUsMTcsMywxOTcyMywxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDIyMTQsNiwxMTAsNiw2LDksNzkyNDg3LDIzOV07XG5cbi8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbi8vIGFzc3VtcHRpb24gaXMgdGhhdCBsb29raW5nIHVwIGFzdHJhbCBpZGVudGlmaWVyIGNoYXJhY3RlcnMgaXNcbi8vIHJhcmUuXG5mdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX07XG52YXIgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbnZhciBrZXl3b3JkcyQxID0ge307XG5cbi8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbmZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyA9IHtcbiAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gIC8vXG4gIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gIC8vXG4gIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIEtleXdvcmQgdG9rZW4gdHlwZXMuXG4gIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gIF9pZjoga3coXCJpZlwiKSxcbiAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gIF90cnk6IGt3KFwidHJ5XCIpLFxuICBfdmFyOiBrdyhcInZhclwiKSxcbiAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIpLFxuICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG59O1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xudmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8IGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjlcbn1cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbnZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG52YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gPSBjb2w7XG59O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG59O1xuXG52YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICB9XG4gIH1cbn1cblxuLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4vLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdFxuICAvLyBiZSBlaXRoZXIgMywgNSwgNiAoMjAxNSksIDcgKDIwMTYpLCBvciA4ICgyMDE3KS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnRcbiAgLy8gZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3JcbiAgLy8gbmV3IHN5bnRheCBmZWF0dXJlcy4gVGhlIGRlZmF1bHQgaXMgNy5cbiAgZWNtYVZlcnNpb246IDcsXG4gIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGggcG9zaXRpb24gb2YgdGhlIGNvbW1hIGFzIGFuIG9mZnNldCwgYW5kIGlmIGBsb2NhdGlvbnNgIGlzXG4gIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Db21tZW50OiBudWxsLFxuICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgLy8gYHRydWVgLlxuICAvL1xuICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgcHJvZ3JhbTogbnVsbCxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICBzb3VyY2VGaWxlOiBudWxsLFxuICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gIHByZXNlcnZlUGFyZW5zOiBmYWxzZSxcbiAgcGx1Z2luczoge31cbn07XG5cbi8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpXG4gICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICB9XG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgdmFsdWU6IHRleHQsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gIH1cbn1cblxuLy8gUmVnaXN0ZXJlZCBwbHVnaW5zXG52YXIgcGx1Z2lucyA9IHt9O1xuXG5mdW5jdGlvbiBrZXl3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG59XG5cbnZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gIHRoaXMua2V5d29yZHMgPSBrZXl3b3JkUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiA1XSk7XG4gIHZhciByZXNlcnZlZCA9IFwiXCI7XG4gIGlmICghb3B0aW9ucy5hbGxvd1Jlc2VydmVkKSB7XG4gICAgZm9yICh2YXIgdiA9IG9wdGlvbnMuZWNtYVZlcnNpb247OyB2LS0pXG4gICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgfVxuICB0aGlzLnJlc2VydmVkV29yZHMgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkKTtcbiAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IGtleXdvcmRSZWdleHAocmVzZXJ2ZWRTdHJpY3QpO1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAvLyBMb2FkIHBsdWdpbnNcbiAgdGhpcy5sb2FkUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuXG4gIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICBpZiAoc3RhcnRQb3MpIHtcbiAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICB9XG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcbiAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAvLyBGbGFncyB0byB0cmFjayB3aGV0aGVyIHdlIGFyZSBpbiBhIGZ1bmN0aW9uLCBhIGdlbmVyYXRvciwgYW4gYXN5bmMgZnVuY3Rpb24uXG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRoaXMuaW5HZW5lcmF0b3IgPSB0aGlzLmluQXN5bmMgPSBmYWxzZTtcbiAgLy8gUG9zaXRpb25zIHRvIGRlbGF5ZWQtY2hlY2sgdGhhdCB5aWVsZC9hd2FpdCBkb2VzIG5vdCBleGlzdCBpbiBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gMDtcbiAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICB0aGlzLmxhYmVscyA9IFtdO1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlckZ1bmN0aW9uU2NvcGUoKTtcblxuICAvLyBGb3IgUmVnRXhwIHZhbGlkYXRpb25cbiAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG59O1xuXG4vLyBERVBSRUNBVEVEIEtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHVudGlsIDMuMCBpbiBjYXNlIGEgcGx1Z2luIHVzZXMgdGhlbVxuUGFyc2VyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiBpc0tleXdvcmQgKHdvcmQpIHsgcmV0dXJuIHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSB9O1xuUGFyc2VyLnByb3RvdHlwZS5pc1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkICh3b3JkKSB7IHJldHVybiB0aGlzLnJlc2VydmVkV29yZHMudGVzdCh3b3JkKSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAobmFtZSwgZikge1xuICB0aGlzW25hbWVdID0gZih0aGlzW25hbWVdKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUubG9hZFBsdWdpbnMgPSBmdW5jdGlvbiBsb2FkUGx1Z2lucyAocGx1Z2luQ29uZmlncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luQ29uZmlncykge1xuICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgIGlmICghcGx1Z2luKSB7IHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiAnXCIgKyBuYW1lICsgXCInIG5vdCBmb3VuZFwiKSB9XG4gICAgcGx1Z2luKHRoaXMkMSwgcGx1Z2luQ29uZmlnc1tuYW1lXSk7XG4gIH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxufTtcblxudmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG52YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcLnxbXiddKSo/KSd8XCIoKD86XFxcXC58W15cIl0pKj8pXCJ8OykvO1xucHAuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICg7Oykge1xuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcyQxLmlucHV0KVswXS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMkMS5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PSBcInVzZSBzdHJpY3RcIikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgc3RhcnQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxucHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lICYmICF0aGlzLmNvbnRhaW5zRXNjXG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAuZXhwZWN0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNlUiB8fFxuICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbnBwLmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4vLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxucHAuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5lYXQodHlwZXMuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PSB0b2tUeXBlKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgIGlmICghbm90TmV4dClcbiAgICAgIHsgdGhpcy5uZXh0KCk7IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuXG4vLyBFeHBlY3QgYSB0b2tlbiBvZiBhIGdpdmVuIHR5cGUuIElmIGZvdW5kLCBjb25zdW1lIGl0LCBvdGhlcndpc2UsXG4vLyByYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxuLy8gUmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xufTtcblxuZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgLTE7XG59XG5cbnBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbn07XG5cbnBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gIGlmICghYW5kVGhyb3cpIHsgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDAgfVxuICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICBpZiAoZG91YmxlUHJvdG8gPj0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG59O1xuXG5wcC5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG59O1xuXG5wcC5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbn07XG5cbnZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMjIFN0YXRlbWVudCBwYXJzaW5nXG5cbi8vIFBhcnNlIGEgcHJvZ3JhbS4gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciwgcmVhZHMgYW55IG51bWJlciBvZlxuLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbi8vIGBwcm9ncmFtYCBhcmd1bWVudC4gIElmIHByZXNlbnQsIHRoZSBzdGF0ZW1lbnRzIHdpbGwgYmUgYXBwZW5kZWRcbi8vIHRvIGl0cyBib2R5IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgbm9kZS5cblxucHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZXhwb3J0cyA9IHt9O1xuICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5lb2YpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMkMS5wYXJzZVN0YXRlbWVudCh0cnVlLCB0cnVlLCBleHBvcnRzKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG59O1xuXG52YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifTtcbnZhciBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxucHAkMS5pc0xldCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gIGlmIChuZXh0Q2ggPT09IDkxIHx8IG5leHRDaCA9PSAxMjMpIHsgcmV0dXJuIHRydWUgfSAvLyAneycgYW5kICdbJ1xuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4vLyAtICdhc3luYyAvKmZvbyovIGZ1bmN0aW9uJyBpcyBPSy5cbi8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG5wcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoO1xuICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAobmV4dCArIDggPT0gdGhpcy5pbnB1dC5sZW5ndGggfHwgIWlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQXQobmV4dCArIDgpKSlcbn07XG5cbi8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbi8vXG4vLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2Vcbi8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbi8vIGRvZXMgbm90IGhlbHAuXG5cbnBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihkZWNsYXJhdGlvbiwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgaWYgKHRoaXMuaXNMZXQoKSkge1xuICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzLl9icmVhazogY2FzZSB0eXBlcy5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgY2FzZSB0eXBlcy5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICBpZiAoIWRlY2xhcmF0aW9uICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSlcbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgaWYgKCFkZWNsYXJhdGlvbikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgY2FzZSB0eXBlcy5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fY29uc3Q6IGNhc2UgdHlwZXMuX3ZhcjpcbiAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgIGlmICghZGVjbGFyYXRpb24gJiYga2luZCAhPSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZClcbiAgY2FzZSB0eXBlcy5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuYnJhY2VMOiByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKClcbiAgY2FzZSB0eXBlcy5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2V4cG9ydDpcbiAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgIC8vIElmIHRoZSBzdGF0ZW1lbnQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHN0YXRlbWVudCBrZXl3b3JkIG9yIGFcbiAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgIC8vIG5leHQgdG9rZW4gaXMgYSBjb2xvbiBhbmQgdGhlIGV4cHJlc3Npb24gd2FzIGEgc2ltcGxlXG4gICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gIGRlZmF1bHQ6XG4gICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlKVxuICAgIH1cblxuICAgIHZhciBtYXliZU5hbWUgPSB0aGlzLnZhbHVlLCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMuY29sb24pKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByKSB9XG4gICAgZWxzZSB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB9XG4gIH1cbn07XG5cbnBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2V5d29yZCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaXNCcmVhayA9IGtleXdvcmQgPT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgZWxzZSBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIGVsc2Uge1xuICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gIC8vIGNvbnRpbnVlIHRvLlxuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGFiID0gdGhpcyQxLmxhYmVsc1tpXTtcbiAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmluQXN5bmMgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICB0aGlzLmVudGVyTGV4aWNhbFNjb3BlKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICEoa2luZCAhPT0gXCJ2YXJcIiAmJiBpbml0JDEuZGVjbGFyYXRpb25zWzBdLmluaXQpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICB9XG4gIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgIH1cbiAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICB9XG4gIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUsIGZhbHNlLCBpc0FzeW5jKVxufTtcblxucHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAvLyBhbGxvdyBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgaW4gYnJhbmNoZXMsIGJ1dCBvbmx5IGluIG5vbi1zdHJpY3QgbW9kZVxuICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCF0aGlzLnN0cmljdCAmJiB0aGlzLnR5cGUgPT0gdHlwZXMuX2Z1bmN0aW9uKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KCF0aGlzLnN0cmljdCAmJiB0aGlzLnR5cGUgPT0gdHlwZXMuX2Z1bmN0aW9uKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUuYXJndW1lbnQgPSBudWxsOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuY2FzZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gIHRoaXMuZW50ZXJMZXhpY2FsU2NvcGUoKTtcblxuICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgdmFyIGN1cjtcbiAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT0gdHlwZXMuYnJhY2VSOykge1xuICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcyQxLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcyQxLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgaWYgKGN1cikgeyB0aGlzJDEuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMkMS5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgY3VyLnRlc3QgPSB0aGlzJDEucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZSh0aGlzJDEubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMkMS51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcyQxLnBhcnNlU3RhdGVtZW50KHRydWUpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG59O1xuXG4vLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxudmFyIGVtcHR5ID0gW107XG5cbnBwJDEucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXRjaCkge1xuICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgdGhpcy5lbnRlckxleGljYWxTY29wZSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgXCJsZXRcIik7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxufTtcblxucHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBtYXliZU5hbWUsIGV4cHIpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IHRoaXMkMS5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgIHsgdGhpcyQxLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH0gfVxuICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFiZWwkMSA9IHRoaXMkMS5sYWJlbHNbaV07XG4gICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT0gbm9kZS5zdGFydCkge1xuICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gIGlmIChub2RlLmJvZHkudHlwZSA9PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fFxuICAgICAgbm9kZS5ib2R5LnR5cGUgPT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiYgbm9kZS5ib2R5LmtpbmQgIT0gXCJ2YXJcIiB8fFxuICAgICAgbm9kZS5ib2R5LnR5cGUgPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgJiYgKHRoaXMuc3RyaWN0IHx8IG5vZGUuYm9keS5nZW5lcmF0b3IpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuYm9keS5zdGFydCwgXCJJbnZhbGlkIGxhYmVsZWQgZGVjbGFyYXRpb25cIik7IH1cbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIG5vZGUubGFiZWwgPSBleHByO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2Vcbi8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4vLyBmdW5jdGlvbiBib2RpZXMpLlxuXG5wcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggY3JlYXRlTmV3TGV4aWNhbFNjb3BlID09PSB2b2lkIDAgKSBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHtcbiAgICB0aGlzLmVudGVyTGV4aWNhbFNjb3BlKCk7XG4gIH1cbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzJDEucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgIHRoaXMuZXhpdExleGljYWxTY29wZSgpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3Rcbi8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxucHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICB2YXIgdHlwZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHR5cGUgPT0gXCJGb3JJblN0YXRlbWVudFwiKSB7XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiIHx8XG4gICAgICAoaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJiBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAgICAodGhpcy5zdHJpY3QgfHwgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpKSlcbiAgICAgIHsgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIkludmFsaWQgYXNzaWdubWVudCBpbiBmb3ItaW4gbG9vcCBoZWFkXCIpOyB9XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IHR5cGUgPT0gXCJGb3JJblN0YXRlbWVudFwiID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICB0aGlzLmV4aXRMZXhpY2FsU2NvcGUoKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpXG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG5wcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgbm9kZS5raW5kID0ga2luZDtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkZWNsID0gdGhpcyQxLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMkMS5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmICh0aGlzJDEuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgZGVjbC5pbml0ID0gdGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcyQxLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcyQxLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzJDEuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcyQxLnVuZXhwZWN0ZWQoKTtcbiAgICB9IGVsc2UgaWYgKGRlY2wuaWQudHlwZSAhPSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMkMS5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICB0aGlzJDEucmFpc2UodGhpcyQxLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcyQxLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgIGlmICghdGhpcyQxLmVhdCh0eXBlcy5jb21tYSkpIHsgYnJlYWsgfVxuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQxLnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oa2luZCk7XG4gIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIGtpbmQsIGZhbHNlKTtcbn07XG5cbi8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcCQxLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5IHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFpc0FzeW5jKVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgaWYgKGlzU3RhdGVtZW50KSB7XG4gICAgbm9kZS5pZCA9IGlzU3RhdGVtZW50ID09PSBcIm51bGxhYmxlSURcIiAmJiB0aGlzLnR5cGUgIT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICBpZiAobm9kZS5pZCkge1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgXCJ2YXJcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9sZEluR2VuID0gdGhpcy5pbkdlbmVyYXRvciwgb2xkSW5Bc3luYyA9IHRoaXMuaW5Bc3luYyxcbiAgICAgIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRJbkZ1bmMgPSB0aGlzLmluRnVuY3Rpb247XG4gIHRoaXMuaW5HZW5lcmF0b3IgPSBub2RlLmdlbmVyYXRvcjtcbiAgdGhpcy5pbkFzeW5jID0gbm9kZS5hc3luYztcbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmluRnVuY3Rpb24gPSB0cnVlO1xuICB0aGlzLmVudGVyRnVuY3Rpb25TY29wZSgpO1xuXG4gIGlmICghaXNTdGF0ZW1lbnQpXG4gICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09IHR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSk7XG5cbiAgdGhpcy5pbkdlbmVyYXRvciA9IG9sZEluR2VuO1xuICB0aGlzLmluQXN5bmMgPSBvbGRJbkFzeW5jO1xuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG59O1xuXG4vLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0KCk7XG5cbiAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQpO1xuICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICB2YXIgbWVtYmVyID0gdGhpcyQxLnBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5KTtcbiAgICBpZiAobWVtYmVyICYmIG1lbWJlci50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBtZW1iZXIua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcyQxLnJhaXNlKG1lbWJlci5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgIGhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NNZW1iZXIgPSBmdW5jdGlvbihjbGFzc0JvZHkpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIHRyeUNvbnRleHR1YWwgPSBmdW5jdGlvbiAoaywgbm9MaW5lQnJlYWspIHtcbiAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcyQxLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvYztcbiAgICBpZiAoIXRoaXMkMS5lYXRDb250ZXh0dWFsKGspKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKG1ldGhvZC5rZXkpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICBtZXRob2Qua2V5Lm5hbWUgPSBrO1xuICAgIHRoaXMkMS5maW5pc2hOb2RlKG1ldGhvZC5rZXksIFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiB0cnlDb250ZXh0dWFsKFwiYXN5bmNcIiwgdHJ1ZSkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJnZXRcIikpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJnZXRcIjtcbiAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJzZXRcIjtcbiAgICB9XG4gIH1cbiAgaWYgKCFtZXRob2Qua2V5KSB7IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTsgfVxuICB2YXIga2V5ID0gbWV0aG9kLmtleTtcbiAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgaWYgKG1ldGhvZC5raW5kICE9PSBcIm1ldGhvZFwiKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGhhdmUgZ2V0L3NldCBtb2RpZmllclwiKTsgfVxuICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICB9XG4gIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgcmV0dXJuIG1ldGhvZFxufTtcblxucHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24oY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKSk7XG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIG5vZGUuaWQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IGlzU3RhdGVtZW50ID09PSB0cnVlID8gdGhpcy51bmV4cGVjdGVkKCkgOiBudWxsO1xufTtcblxucHAkMS5wYXJzZUNsYXNzU3VwZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbn07XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24obm9kZSwgZXhwb3J0cykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLm5leHQoKTtcbiAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbiAgfVxuICBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICB2YXIgaXNBc3luYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIFwibnVsbGFibGVJRFwiLCBmYWxzZSwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jbGFzcykge1xuICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICB9XG4gIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgaWYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgZm9yIGtleXdvcmRzIHVzZWQgYXMgbG9jYWwgbmFtZXNcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcyQxLmNoZWNrVW5yZXNlcnZlZChzcGVjLmxvY2FsKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG59O1xuXG5wcCQxLmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBpZiAoaGFzKGV4cG9ydHMsIG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG59O1xuXG5wcCQxLmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICBpZiAodHlwZSA9PSBcIklkZW50aWZpZXJcIilcbiAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcyQxLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwcm9wKTtcbiAgICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgaWYgKGVsdCkgeyB0aGlzJDEuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PSBcIlByb3BlcnR5XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICBlbHNlIGlmICh0eXBlID09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxufTtcblxucHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICB0aGlzJDEuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICB9XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG5wcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMkMS5wYXJzZUlkZW50KHRydWUpO1xuICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzJDEuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgIHRoaXMkMS5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgIG5vZGVzLnB1c2godGhpcyQxLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgXCJsZXRcIik7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpIHtcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlJDEubG9jYWwsIFwibGV0XCIpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgIHJldHVybiBub2Rlc1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUkMiA9IHRoaXMkMS5zdGFydE5vZGUoKTtcbiAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzJDEucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAodGhpcyQxLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcyQxLnBhcnNlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcyQxLmNoZWNrVW5yZXNlcnZlZChub2RlJDIuaW1wb3J0ZWQpO1xuICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgIH1cbiAgICB0aGlzJDEuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgXCJsZXRcIik7XG4gICAgbm9kZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMkMS50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzJDEucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT0gXCJQcm9wZXJ0eVwiXG4gICAgICBpZiAobm9kZS5raW5kICE9PSBcImluaXRcIikgeyB0aGlzLnJhaXNlKG5vZGUua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIkFycmF5UGF0dGVyblwiO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICBub2RlLnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmFyZ3VtZW50LCBpc0JpbmRpbmcpO1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5hcmd1bWVudC5zdGFydCwgXCJSZXN0IGVsZW1lbnRzIGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7IHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTsgfVxuICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoIHRvIEFzc2lnbm1lbnRQYXR0ZXJuXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBiaW5kaW5nIGxpc3QuXG5cbnBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICBpZiAoZWx0KSB7IHRoaXMkMS50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgfVxuICByZXR1cm4gZXhwckxpc3Rcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG59O1xuXG5wcCQyLnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZXMgbHZhbHVlIChhc3NpZ25hYmxlKSBhdG9tLlxuXG5wcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmoodHJ1ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgIGVsc2UgeyB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTsgfVxuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICB2YXIgcmVzdCA9IHRoaXMkMS5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICB0aGlzJDEucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICB0aGlzJDEuZXhwZWN0KGNsb3NlKTtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbGVtID0gdGhpcyQxLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMkMS5zdGFydCwgdGhpcyQxLnN0YXJ0TG9jKTtcbiAgICAgIHRoaXMkMS5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDIucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICByZXR1cm4gcGFyYW1cbn07XG5cbi8vIFBhcnNlcyBhc3NpZ25tZW50IHBhdHRlcm4gYXJvdW5kIGdpdmVuIGF0b20gaWYgcG9zc2libGUuXG5cbnBwJDIucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcy5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbn07XG5cbi8vIFZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsIOKAlCBzb21ldGhpbmcgdGhhdCBjYW4gYmUgYXNzaWduZWRcbi8vIHRvLlxuLy8gYmluZGluZ1R5cGUgY2FuIGJlIGVpdGhlcjpcbi8vICd2YXInIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgJ3ZhcicgYmluZGluZ1xuLy8gJ2xldCcgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSBsZXhpY2FsICgnbGV0JyBvciAnY29uc3QnKSBiaW5kaW5nXG4vLyAnbm9uZScgaW5kaWNhdGluZyB0aGF0IHRoZSBiaW5kaW5nIHNob3VsZCBiZSBjaGVja2VkIGZvciBpbGxlZ2FsIGlkZW50aWZpZXJzLCBidXQgbm90IGZvciBkdXBsaWNhdGUgcmVmZXJlbmNlc1xuXG5wcCQyLmNoZWNrTFZhbCA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBpZiAodGhpcy5zdHJpY3QgJiYgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZC50ZXN0KGV4cHIubmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgIGlmIChoYXMoY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgIGNoZWNrQ2xhc2hlc1tleHByLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYmIGJpbmRpbmdUeXBlICE9PSBcIm5vbmVcIikge1xuICAgICAgaWYgKFxuICAgICAgICBiaW5kaW5nVHlwZSA9PT0gXCJ2YXJcIiAmJiAhdGhpcy5jYW5EZWNsYXJlVmFyTmFtZShleHByLm5hbWUpIHx8XG4gICAgICAgIGJpbmRpbmdUeXBlICE9PSBcInZhclwiICYmICF0aGlzLmNhbkRlY2xhcmVMZXhpY2FsTmFtZShleHByLm5hbWUpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChcIklkZW50aWZpZXIgJ1wiICsgKGV4cHIubmFtZSkgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IFwidmFyXCIpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJlVmFyTmFtZShleHByLm5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWNsYXJlTGV4aWNhbE5hbWUoZXhwci5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGlmIChiaW5kaW5nVHlwZSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uXCIpOyB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwci5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICB0aGlzJDEuY2hlY2tMVmFsKHByb3AsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT0gXCJQcm9wZXJ0eVwiXG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzJDEuY2hlY2tMVmFsKGVsZW0sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpOyB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5sZWZ0LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICB9XG59O1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG52YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENoZWNrIGlmIHByb3BlcnR5IG5hbWUgY2xhc2hlcyB3aXRoIGFscmVhZHkgYWRkZWQuXG4vLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4vLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4vLyBzdHJpY3QgbW9kZSwgaW5pdCBwcm9wZXJ0aWVzIGFyZSBhbHNvIG5vdCBhbGxvd2VkIHRvIGJlIHJlcGVhdGVkLlxuXG5wcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgeyByZXR1cm4gfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgIHsgcmV0dXJuIH1cbiAgdmFyIGtleSA9IHByb3Aua2V5O1xuICB2YXIgbmFtZTtcbiAgc3dpdGNoIChrZXkudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOiBuYW1lID0ga2V5Lm5hbWU7IGJyZWFrXG4gIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgZGVmYXVsdDogcmV0dXJuXG4gIH1cbiAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiICYmIGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA8IDApIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDsgfVxuICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGtsdWRnZS4gQ2FuIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjBcbiAgICAgICAgZWxzZSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICAgICAgfVxuICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBuYW1lID0gXCIkXCIgKyBuYW1lO1xuICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgaWYgKG90aGVyKSB7XG4gICAgdmFyIHJlZGVmaW5pdGlvbjtcbiAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IHRoaXMuc3RyaWN0ICYmIG90aGVyLmluaXQgfHwgb3RoZXIuZ2V0IHx8IG90aGVyLnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICB9XG4gICAgaWYgKHJlZGVmaW5pdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgaW5pdDogZmFsc2UsXG4gICAgICBnZXQ6IGZhbHNlLFxuICAgICAgc2V0OiBmYWxzZVxuICAgIH07XG4gIH1cbiAgb3RoZXJba2luZF0gPSB0cnVlO1xufTtcblxuLy8gIyMjIEV4cHJlc3Npb24gcGFyc2luZ1xuXG4vLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbi8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4vLyB0aGUgZnVuY3Rpb25zIHdpbGwgc2ltcGx5IGxldCB0aGUgZnVuY3Rpb24ocykgYmVsb3cgdGhlbSBwYXJzZSxcbi8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4vLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbi8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4vLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuLy8gYW5kIHByb3ZpZGUgcmVmZXJlbmNlIGZvciBzdG9yaW5nICc9JyBvcGVyYXRvciBpbnNpZGUgc2hvcnRoYW5kXG4vLyBwcm9wZXJ0eSBhc3NpZ25tZW50IGluIGNvbnRleHRzIHdoZXJlIGJvdGggb2JqZWN0IGV4cHJlc3Npb25cbi8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2Vcbi8vIGRlbGF5ZWQgc3ludGF4IGVycm9yIGF0IGNvcnJlY3QgcG9zaXRpb24pLlxuXG5wcCQzLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuLy8gb3BlcmF0b3JzIGxpa2UgYCs9YC5cblxucHAkMy5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKCkgfVxuXG4gIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMTtcbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBvbGRQYXJlbkFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbjtcbiAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgaWYgKHRoaXMudHlwZSA9PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09IHR5cGVzLm5hbWUpXG4gICAgeyB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0OyB9XG4gIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIDogbGVmdDtcbiAgICBpZiAoIW93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgRGVzdHJ1Y3R1cmluZ0Vycm9ycy5jYWxsKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSAtMTsgLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIH1cbiAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbnBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICByZXR1cm4gZXhwci5zdGFydCA9PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQzLnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5idWlsZEJpbmFyeShsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVmdFxufTtcblxucHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLm9wZXJhdG9yID0gb3A7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwcjtcbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiB0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpKSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMkMS52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzJDEuY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgIGV4cHIgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXJzdGFyKSlcbiAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gIGVsc2VcbiAgICB7IHJldHVybiBleHByIH1cbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHZhciBza2lwQXJyb3dTdWJzY3JpcHRzID0gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCI7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5pbnB1dC5zbGljZShiYXNlLnN0YXJ0LCBiYXNlLmVuZCkgPT09IFwiYXN5bmNcIjtcbiAgZm9yICh2YXIgY29tcHV0ZWQgPSAodm9pZCAwKTs7KSB7XG4gICAgaWYgKChjb21wdXRlZCA9IHRoaXMkMS5lYXQodHlwZXMuYnJhY2tldEwpKSB8fCB0aGlzJDEuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzJDEucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzJDEucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7IHRoaXMkMS5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcyQxLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMkMS55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzJDEuYXdhaXRQb3M7XG4gICAgICB0aGlzJDEueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcyQxLmF3YWl0UG9zID0gMDtcbiAgICAgIHZhciBleHByTGlzdCA9IHRoaXMkMS5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcyQxLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMkMS5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMkMS5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzJDEuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIHRoaXMkMS55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzJDEuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMkMS5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIHRydWUpXG4gICAgICB9XG4gICAgICB0aGlzJDEuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcyQxLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcyQxLnlpZWxkUG9zO1xuICAgICAgdGhpcyQxLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcyQxLmF3YWl0UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQxLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZSkge1xuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgICBub2RlJDIucXVhc2kgPSB0aGlzJDEucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICAgIGJhc2UgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZVxuICAgIH1cbiAgfVxufTtcblxuLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4vLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4vLyBvciBge31gLlxuXG5wcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09IHRoaXMuc3RhcnQ7XG4gIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBvdXRzaWRlIG9mIGZ1bmN0aW9uIG9yIGNsYXNzXCIpOyB9XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgLy8gVGhlIGBzdXBlcmAga2V5d29yZCBjYW4gYXBwZWFyIGF0IGJlbG93OlxuICAgIC8vIFN1cGVyUHJvcGVydHk6XG4gICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgLy8gICAgIHN1cGVyIC4gSWRlbnRpZmllck5hbWVcbiAgICAvLyBTdXBlckNhbGw6XG4gICAgLy8gICAgIHN1cGVyIEFyZ3VtZW50c1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLmRvdCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNrZXRMICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKVxuXG4gIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcy5uYW1lOlxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIHZhciBpZCA9IHRoaXMucGFyc2VJZGVudCh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBmYWxzZSwgZmFsc2UsIHRydWUpIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIGZhbHNlKSB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiAhY29udGFpbnNFc2MpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG5cbiAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMubnVtOiBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICBjYXNlIHR5cGVzLl9udWxsOiBjYXNlIHR5cGVzLl90cnVlOiBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcy5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl90cnVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LCBleHByID0gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCAmJiAhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByKSlcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBzdGFydDsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSBzdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuXG4gIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgZmFsc2UpXG5cbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxufTtcblxucHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgcmV0dXJuIHZhbFxufTtcblxucHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5wYXJlblIpIHtcbiAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLnBhcmVuUiwgdHJ1ZSkpIHtcbiAgICAgICAgbGFzdElzQ29tbWEgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgc3ByZWFkU3RhcnQgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcyQxLnBhcnNlUGFyZW5JdGVtKHRoaXMkMS5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzJDEucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcyQxLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyRW5kTG9jID0gdGhpcy5zdGFydExvYztcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgIH1cblxuICAgIGlmICghZXhwckxpc3QubGVuZ3RoIHx8IGxhc3RJc0NvbW1hKSB7IHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7IH1cbiAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhbCA9IHRoaXMuc3RhcnROb2RlQXQoaW5uZXJTdGFydFBvcywgaW5uZXJTdGFydExvYyk7XG4gICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucHJlc2VydmVQYXJlbnMpIHtcbiAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIHBhci5leHByZXNzaW9uID0gdmFsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocGFyLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG59O1xuXG5wcCQzLnBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICByZXR1cm4gaXRlbVxufTtcblxucHAkMy5wYXJzZVBhcmVuQXJyb3dMaXN0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0KVxufTtcblxuLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50IHRvXG4vLyBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXQgbGVhc3QsXG4vLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuLy8gYXJndW1lbnQgdG8gcGFyc2VTdWJzY3JpcHRzIHRvIHByZXZlbnQgaXQgZnJvbSBjb25zdW1pbmcgdGhlXG4vLyBhcmd1bWVudCBsaXN0LlxuXG52YXIgZW1wdHkkMSA9IFtdO1xuXG5wcCQzLnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIiB8fCBjb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIG5ldy50YXJnZXRcIik7IH1cbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwibmV3LnRhcmdldCBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9uc1wiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgfVxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudHMgPSBlbXB0eSQxOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG5wcCQzLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkge1xuICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICB9XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy52YWx1ZSxcbiAgICAgIGNvb2tlZDogbnVsbFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgIH07XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpXG59O1xuXG5wcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzJDEucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgIHRoaXMkMS5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMkMS5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG59O1xuXG5wcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbnBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLm5leHQoKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMkMS5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcyQxLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICB9XG4gICAgLy8gVG8gZGlzYWxsb3cgcGFyZW50aGVzaXplZCBpZGVudGlmaWVyIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGFyZ3VtZW50LlxuICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvLyBGaW5pc2hcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB9XG4gICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgfVxuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIH0gZWxzZSB7XG4gICAgaXNBc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29sb24pXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAodGhpcy50eXBlICE9IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPSB0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIHJldHVybiBwcm9wLmtleVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbn07XG5cbi8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxucHAkMy5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxufTtcblxuLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxucHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkSW5HZW4gPSB0aGlzLmluR2VuZXJhdG9yLCBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLFxuICAgICAgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEluRnVuYyA9IHRoaXMuaW5GdW5jdGlvbjtcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO1xuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRydWU7XG4gIHRoaXMuZW50ZXJGdW5jdGlvblNjb3BlKCk7XG5cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlKTtcblxuICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHZhciBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3IsIG9sZEluQXN5bmMgPSB0aGlzLmluQXN5bmMsXG4gICAgICBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkSW5GdW5jID0gdGhpcy5pbkZ1bmN0aW9uO1xuXG4gIHRoaXMuZW50ZXJGdW5jdGlvblNjb3BlKCk7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy5pbkdlbmVyYXRvciA9IGZhbHNlO1xuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRydWU7XG5cbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcblxuICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxucHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbikge1xuICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VMO1xuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgLy8gaWYgYSBsZXQvY29uc3QgZGVjbGFyYXRpb24gaW4gdGhlIGZ1bmN0aW9uIGNsYXNoZXMgd2l0aCBvbmUgb2YgdGhlIHBhcmFtcy5cbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5leGl0RnVuY3Rpb25TY29wZSgpO1xuXG4gIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7XG4gICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgXCJub25lXCIpO1xuICB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xufTtcblxucHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbi8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG5wcCQzLmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBuYW1lSGFzaCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIHRoaXMkMS5jaGVja0xWYWwocGFyYW0sIFwidmFyXCIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4vLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4vLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG5wcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMkMS5zdGFydDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzJDEucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQzLmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW4gbm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbiBub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgaWYgKHRoaXMuaXNLZXl3b3JkKG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPSAtMSkgeyByZXR1cm4gfVxuICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW4gbm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAobGliZXJhbCAmJiB0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBcIm5ldmVyXCIpIHsgbGliZXJhbCA9IGZhbHNlOyB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7IHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpOyB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG52YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICB0aHJvdyBlcnJcbn07XG5cbnBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbnBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgfVxufTtcblxudmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBPYmplY3QuYXNzaWduIHBvbHlmaWxsXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHNvdXJjZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIHNvdXJjZSA9IGxpc3RbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59O1xuXG4vLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbnBwJDUuZW50ZXJGdW5jdGlvblNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHZhcjogYSBoYXNoIG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIC8vIGxleGljYWw6IGEgaGFzaCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAvLyBjaGlsZFZhcjogYSBoYXNoIG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiBhbGwgY2hpbGQgbGV4aWNhbCBzY29wZXMgb2YgdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSAod2l0aGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHNjb3BlKVxuICAvLyBwYXJlbnRMZXhpY2FsOiBhIGhhc2ggb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIGFsbCBwYXJlbnQgbGV4aWNhbCBzY29wZXMgb2YgdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSAod2l0aGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHNjb3BlKVxuICB0aGlzLnNjb3BlU3RhY2sucHVzaCh7dmFyOiB7fSwgbGV4aWNhbDoge30sIGNoaWxkVmFyOiB7fSwgcGFyZW50TGV4aWNhbDoge319KTtcbn07XG5cbnBwJDUuZXhpdEZ1bmN0aW9uU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xufTtcblxucHAkNS5lbnRlckxleGljYWxTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB2YXIgY2hpbGRTY29wZSA9IHt2YXI6IHt9LCBsZXhpY2FsOiB7fSwgY2hpbGRWYXI6IHt9LCBwYXJlbnRMZXhpY2FsOiB7fX07XG5cbiAgdGhpcy5zY29wZVN0YWNrLnB1c2goY2hpbGRTY29wZSk7XG4gIGFzc2lnbihjaGlsZFNjb3BlLnBhcmVudExleGljYWwsIHBhcmVudFNjb3BlLmxleGljYWwsIHBhcmVudFNjb3BlLnBhcmVudExleGljYWwpO1xufTtcblxucHAkNS5leGl0TGV4aWNhbFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGlsZFNjb3BlID0gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gIGFzc2lnbihwYXJlbnRTY29wZS5jaGlsZFZhciwgY2hpbGRTY29wZS52YXIsIGNoaWxkU2NvcGUuY2hpbGRWYXIpO1xufTtcblxuLyoqXG4gKiBBIG5hbWUgY2FuIGJlIGRlY2xhcmVkIHdpdGggYHZhcmAgaWYgdGhlcmUgYXJlIG5vIHZhcmlhYmxlcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGVjbGFyZWQgd2l0aCBgbGV0YC9gY29uc3RgXG4gKiBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlIG9yIGFueSBvZiB0aGUgcGFyZW50IGxleGljYWwgc2NvcGVzIGluIHRoaXMgZnVuY3Rpb24uXG4gKi9cbnBwJDUuY2FuRGVjbGFyZVZhck5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjdXJyZW50U2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gIHJldHVybiAhaGFzKGN1cnJlbnRTY29wZS5sZXhpY2FsLCBuYW1lKSAmJiAhaGFzKGN1cnJlbnRTY29wZS5wYXJlbnRMZXhpY2FsLCBuYW1lKVxufTtcblxuLyoqXG4gKiBBIG5hbWUgY2FuIGJlIGRlY2xhcmVkIHdpdGggYGxldGAvYGNvbnN0YCBpZiB0aGVyZSBhcmUgbm8gdmFyaWFibGVzIHdpdGggdGhlIHNhbWUgbmFtZSBkZWNsYXJlZCB3aXRoIGBsZXRgL2Bjb25zdGBcbiAqIGluIHRoZSBjdXJyZW50IHNjb3BlLCBhbmQgdGhlcmUgYXJlIG5vIHZhcmlhYmxlcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGVjbGFyZWQgd2l0aCBgdmFyYCBpbiB0aGUgY3VycmVudCBzY29wZSBvciBpblxuICogYW55IGNoaWxkIGxleGljYWwgc2NvcGVzIGluIHRoaXMgZnVuY3Rpb24uXG4gKi9cbnBwJDUuY2FuRGVjbGFyZUxleGljYWxOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3VycmVudFNjb3BlID0gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcblxuICByZXR1cm4gIWhhcyhjdXJyZW50U2NvcGUubGV4aWNhbCwgbmFtZSkgJiYgIWhhcyhjdXJyZW50U2NvcGUudmFyLCBuYW1lKSAmJiAhaGFzKGN1cnJlbnRTY29wZS5jaGlsZFZhciwgbmFtZSlcbn07XG5cbnBwJDUuZGVjbGFyZVZhck5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV0udmFyW25hbWVdID0gdHJ1ZTtcbn07XG5cbnBwJDUuZGVjbGFyZUxleGljYWxOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdLmxleGljYWxbbmFtZV0gPSB0cnVlO1xufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgdGhpcy50eXBlID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IHBvcztcbiAgdGhpcy5lbmQgPSAwO1xuICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG59O1xuXG4vLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG52YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQ2LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbi8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcbi8vIGdpdmVuIHBvaW50IGluIHRoZSBwcm9ncmFtIGlzIGxvb3NlbHkgYmFzZWQgb24gc3dlZXQuanMnIGFwcHJvYWNoLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cbnZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbn07XG5cbnZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNy5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3R5cGVzJDEuYl9zdGF0XVxufTtcblxucHAkNy5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmIChwYXJlbnQgPT09IHR5cGVzJDEuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMkMS5mX3N0YXQpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcyQxLmJfZXhwcikpXG4gICAgeyByZXR1cm4gIXBhcmVudC5pc0V4cHIgfVxuXG4gIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgLy8gYWZ0ZXIgYSBgeWllbGRgIG9yIGBvZmAgY29uc3RydWN0LiBTZWUgdGhlIGB1cGRhdGVDb250ZXh0YCBmb3JcbiAgLy8gYHR0Lm5hbWVgLlxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT0gdHlwZXMubmFtZSAmJiB0aGlzLmV4cHJBbGxvd2VkKVxuICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PSB0eXBlcy5hcnJvdylcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09IHR5cGVzLmJyYWNlTClcbiAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IH1cbiAgaWYgKHByZXZUeXBlID09IHR5cGVzLl92YXIgfHwgcHJldlR5cGUgPT0gdHlwZXMubmFtZSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxufTtcblxucHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyQxLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT0gdHlwZXMuZG90KVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG59O1xuXG4vLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbnR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT0gMSkge1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzJDEuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xufTtcblxudHlwZXMuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcyQxLmJfc3RhdCA6IHR5cGVzJDEuYl9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmJfdG1wbCk7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aGlsZTtcbiAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wX3N0YXQgOiB0eXBlcyQxLnBfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG59O1xuXG50eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzLnNlbWkgJiYgcHJldlR5cGUgIT09IHR5cGVzLl9lbHNlICYmXG4gICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYl9zdGF0KSlcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9leHByKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfc3RhdCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLnFfdG1wbCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLnZhbHVlID09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICB0aGlzLnZhbHVlID09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgeyBhbGxvd2VkID0gdHJ1ZTsgfVxuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xufTtcblxudmFyIGRhdGEgPSB7XG4gIFwiJExPTkVcIjogW1xuICAgIFwiQVNDSUlcIixcbiAgICBcIkFTQ0lJX0hleF9EaWdpdFwiLFxuICAgIFwiQUhleFwiLFxuICAgIFwiQWxwaGFiZXRpY1wiLFxuICAgIFwiQWxwaGFcIixcbiAgICBcIkFueVwiLFxuICAgIFwiQXNzaWduZWRcIixcbiAgICBcIkJpZGlfQ29udHJvbFwiLFxuICAgIFwiQmlkaV9DXCIsXG4gICAgXCJCaWRpX01pcnJvcmVkXCIsXG4gICAgXCJCaWRpX01cIixcbiAgICBcIkNhc2VfSWdub3JhYmxlXCIsXG4gICAgXCJDSVwiLFxuICAgIFwiQ2FzZWRcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9DYXNlZm9sZGVkXCIsXG4gICAgXCJDV0NGXCIsXG4gICAgXCJDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZFwiLFxuICAgIFwiQ1dDTVwiLFxuICAgIFwiQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWRcIixcbiAgICBcIkNXTFwiLFxuICAgIFwiQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZFwiLFxuICAgIFwiQ1dLQ0ZcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9UaXRsZWNhc2VkXCIsXG4gICAgXCJDV1RcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9VcHBlcmNhc2VkXCIsXG4gICAgXCJDV1VcIixcbiAgICBcIkRhc2hcIixcbiAgICBcIkRlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnRcIixcbiAgICBcIkRJXCIsXG4gICAgXCJEZXByZWNhdGVkXCIsXG4gICAgXCJEZXBcIixcbiAgICBcIkRpYWNyaXRpY1wiLFxuICAgIFwiRGlhXCIsXG4gICAgXCJFbW9qaVwiLFxuICAgIFwiRW1vamlfQ29tcG9uZW50XCIsXG4gICAgXCJFbW9qaV9Nb2RpZmllclwiLFxuICAgIFwiRW1vamlfTW9kaWZpZXJfQmFzZVwiLFxuICAgIFwiRW1vamlfUHJlc2VudGF0aW9uXCIsXG4gICAgXCJFeHRlbmRlclwiLFxuICAgIFwiRXh0XCIsXG4gICAgXCJHcmFwaGVtZV9CYXNlXCIsXG4gICAgXCJHcl9CYXNlXCIsXG4gICAgXCJHcmFwaGVtZV9FeHRlbmRcIixcbiAgICBcIkdyX0V4dFwiLFxuICAgIFwiSGV4X0RpZ2l0XCIsXG4gICAgXCJIZXhcIixcbiAgICBcIklEU19CaW5hcnlfT3BlcmF0b3JcIixcbiAgICBcIklEU0JcIixcbiAgICBcIklEU19UcmluYXJ5X09wZXJhdG9yXCIsXG4gICAgXCJJRFNUXCIsXG4gICAgXCJJRF9Db250aW51ZVwiLFxuICAgIFwiSURDXCIsXG4gICAgXCJJRF9TdGFydFwiLFxuICAgIFwiSURTXCIsXG4gICAgXCJJZGVvZ3JhcGhpY1wiLFxuICAgIFwiSWRlb1wiLFxuICAgIFwiSm9pbl9Db250cm9sXCIsXG4gICAgXCJKb2luX0NcIixcbiAgICBcIkxvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uXCIsXG4gICAgXCJMT0VcIixcbiAgICBcIkxvd2VyY2FzZVwiLFxuICAgIFwiTG93ZXJcIixcbiAgICBcIk1hdGhcIixcbiAgICBcIk5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50XCIsXG4gICAgXCJOQ2hhclwiLFxuICAgIFwiUGF0dGVybl9TeW50YXhcIixcbiAgICBcIlBhdF9TeW5cIixcbiAgICBcIlBhdHRlcm5fV2hpdGVfU3BhY2VcIixcbiAgICBcIlBhdF9XU1wiLFxuICAgIFwiUXVvdGF0aW9uX01hcmtcIixcbiAgICBcIlFNYXJrXCIsXG4gICAgXCJSYWRpY2FsXCIsXG4gICAgXCJSZWdpb25hbF9JbmRpY2F0b3JcIixcbiAgICBcIlJJXCIsXG4gICAgXCJTZW50ZW5jZV9UZXJtaW5hbFwiLFxuICAgIFwiU1Rlcm1cIixcbiAgICBcIlNvZnRfRG90dGVkXCIsXG4gICAgXCJTRFwiLFxuICAgIFwiVGVybWluYWxfUHVuY3R1YXRpb25cIixcbiAgICBcIlRlcm1cIixcbiAgICBcIlVuaWZpZWRfSWRlb2dyYXBoXCIsXG4gICAgXCJVSWRlb1wiLFxuICAgIFwiVXBwZXJjYXNlXCIsXG4gICAgXCJVcHBlclwiLFxuICAgIFwiVmFyaWF0aW9uX1NlbGVjdG9yXCIsXG4gICAgXCJWU1wiLFxuICAgIFwiV2hpdGVfU3BhY2VcIixcbiAgICBcInNwYWNlXCIsXG4gICAgXCJYSURfQ29udGludWVcIixcbiAgICBcIlhJRENcIixcbiAgICBcIlhJRF9TdGFydFwiLFxuICAgIFwiWElEU1wiXG4gIF0sXG4gIFwiR2VuZXJhbF9DYXRlZ29yeVwiOiBbXG4gICAgXCJDYXNlZF9MZXR0ZXJcIixcbiAgICBcIkxDXCIsXG4gICAgXCJDbG9zZV9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGVcIixcbiAgICBcIkNvbm5lY3Rvcl9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGNcIixcbiAgICBcIkNvbnRyb2xcIixcbiAgICBcIkNjXCIsXG4gICAgXCJjbnRybFwiLFxuICAgIFwiQ3VycmVuY3lfU3ltYm9sXCIsXG4gICAgXCJTY1wiLFxuICAgIFwiRGFzaF9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGRcIixcbiAgICBcIkRlY2ltYWxfTnVtYmVyXCIsXG4gICAgXCJOZFwiLFxuICAgIFwiZGlnaXRcIixcbiAgICBcIkVuY2xvc2luZ19NYXJrXCIsXG4gICAgXCJNZVwiLFxuICAgIFwiRmluYWxfUHVuY3R1YXRpb25cIixcbiAgICBcIlBmXCIsXG4gICAgXCJGb3JtYXRcIixcbiAgICBcIkNmXCIsXG4gICAgXCJJbml0aWFsX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQaVwiLFxuICAgIFwiTGV0dGVyXCIsXG4gICAgXCJMXCIsXG4gICAgXCJMZXR0ZXJfTnVtYmVyXCIsXG4gICAgXCJObFwiLFxuICAgIFwiTGluZV9TZXBhcmF0b3JcIixcbiAgICBcIlpsXCIsXG4gICAgXCJMb3dlcmNhc2VfTGV0dGVyXCIsXG4gICAgXCJMbFwiLFxuICAgIFwiTWFya1wiLFxuICAgIFwiTVwiLFxuICAgIFwiQ29tYmluaW5nX01hcmtcIixcbiAgICBcIk1hdGhfU3ltYm9sXCIsXG4gICAgXCJTbVwiLFxuICAgIFwiTW9kaWZpZXJfTGV0dGVyXCIsXG4gICAgXCJMbVwiLFxuICAgIFwiTW9kaWZpZXJfU3ltYm9sXCIsXG4gICAgXCJTa1wiLFxuICAgIFwiTm9uc3BhY2luZ19NYXJrXCIsXG4gICAgXCJNblwiLFxuICAgIFwiTnVtYmVyXCIsXG4gICAgXCJOXCIsXG4gICAgXCJPcGVuX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQc1wiLFxuICAgIFwiT3RoZXJcIixcbiAgICBcIkNcIixcbiAgICBcIk90aGVyX0xldHRlclwiLFxuICAgIFwiTG9cIixcbiAgICBcIk90aGVyX051bWJlclwiLFxuICAgIFwiTm9cIixcbiAgICBcIk90aGVyX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQb1wiLFxuICAgIFwiT3RoZXJfU3ltYm9sXCIsXG4gICAgXCJTb1wiLFxuICAgIFwiUGFyYWdyYXBoX1NlcGFyYXRvclwiLFxuICAgIFwiWnBcIixcbiAgICBcIlByaXZhdGVfVXNlXCIsXG4gICAgXCJDb1wiLFxuICAgIFwiUHVuY3R1YXRpb25cIixcbiAgICBcIlBcIixcbiAgICBcInB1bmN0XCIsXG4gICAgXCJTZXBhcmF0b3JcIixcbiAgICBcIlpcIixcbiAgICBcIlNwYWNlX1NlcGFyYXRvclwiLFxuICAgIFwiWnNcIixcbiAgICBcIlNwYWNpbmdfTWFya1wiLFxuICAgIFwiTWNcIixcbiAgICBcIlN1cnJvZ2F0ZVwiLFxuICAgIFwiQ3NcIixcbiAgICBcIlN5bWJvbFwiLFxuICAgIFwiU1wiLFxuICAgIFwiVGl0bGVjYXNlX0xldHRlclwiLFxuICAgIFwiTHRcIixcbiAgICBcIlVuYXNzaWduZWRcIixcbiAgICBcIkNuXCIsXG4gICAgXCJVcHBlcmNhc2VfTGV0dGVyXCIsXG4gICAgXCJMdVwiXG4gIF0sXG4gIFwiU2NyaXB0XCI6IFtcbiAgICBcIkFkbGFtXCIsXG4gICAgXCJBZGxtXCIsXG4gICAgXCJBaG9tXCIsXG4gICAgXCJBbmF0b2xpYW5fSGllcm9nbHlwaHNcIixcbiAgICBcIkhsdXdcIixcbiAgICBcIkFyYWJpY1wiLFxuICAgIFwiQXJhYlwiLFxuICAgIFwiQXJtZW5pYW5cIixcbiAgICBcIkFybW5cIixcbiAgICBcIkF2ZXN0YW5cIixcbiAgICBcIkF2c3RcIixcbiAgICBcIkJhbGluZXNlXCIsXG4gICAgXCJCYWxpXCIsXG4gICAgXCJCYW11bVwiLFxuICAgIFwiQmFtdVwiLFxuICAgIFwiQmFzc2FfVmFoXCIsXG4gICAgXCJCYXNzXCIsXG4gICAgXCJCYXRha1wiLFxuICAgIFwiQmF0a1wiLFxuICAgIFwiQmVuZ2FsaVwiLFxuICAgIFwiQmVuZ1wiLFxuICAgIFwiQmhhaWtzdWtpXCIsXG4gICAgXCJCaGtzXCIsXG4gICAgXCJCb3BvbW9mb1wiLFxuICAgIFwiQm9wb1wiLFxuICAgIFwiQnJhaG1pXCIsXG4gICAgXCJCcmFoXCIsXG4gICAgXCJCcmFpbGxlXCIsXG4gICAgXCJCcmFpXCIsXG4gICAgXCJCdWdpbmVzZVwiLFxuICAgIFwiQnVnaVwiLFxuICAgIFwiQnVoaWRcIixcbiAgICBcIkJ1aGRcIixcbiAgICBcIkNhbmFkaWFuX0Fib3JpZ2luYWxcIixcbiAgICBcIkNhbnNcIixcbiAgICBcIkNhcmlhblwiLFxuICAgIFwiQ2FyaVwiLFxuICAgIFwiQ2F1Y2FzaWFuX0FsYmFuaWFuXCIsXG4gICAgXCJBZ2hiXCIsXG4gICAgXCJDaGFrbWFcIixcbiAgICBcIkNha21cIixcbiAgICBcIkNoYW1cIixcbiAgICBcIkNoZXJva2VlXCIsXG4gICAgXCJDaGVyXCIsXG4gICAgXCJDb21tb25cIixcbiAgICBcIlp5eXlcIixcbiAgICBcIkNvcHRpY1wiLFxuICAgIFwiQ29wdFwiLFxuICAgIFwiUWFhY1wiLFxuICAgIFwiQ3VuZWlmb3JtXCIsXG4gICAgXCJYc3V4XCIsXG4gICAgXCJDeXByaW90XCIsXG4gICAgXCJDcHJ0XCIsXG4gICAgXCJDeXJpbGxpY1wiLFxuICAgIFwiQ3lybFwiLFxuICAgIFwiRGVzZXJldFwiLFxuICAgIFwiRHNydFwiLFxuICAgIFwiRGV2YW5hZ2FyaVwiLFxuICAgIFwiRGV2YVwiLFxuICAgIFwiRHVwbG95YW5cIixcbiAgICBcIkR1cGxcIixcbiAgICBcIkVneXB0aWFuX0hpZXJvZ2x5cGhzXCIsXG4gICAgXCJFZ3lwXCIsXG4gICAgXCJFbGJhc2FuXCIsXG4gICAgXCJFbGJhXCIsXG4gICAgXCJFdGhpb3BpY1wiLFxuICAgIFwiRXRoaVwiLFxuICAgIFwiR2VvcmdpYW5cIixcbiAgICBcIkdlb3JcIixcbiAgICBcIkdsYWdvbGl0aWNcIixcbiAgICBcIkdsYWdcIixcbiAgICBcIkdvdGhpY1wiLFxuICAgIFwiR290aFwiLFxuICAgIFwiR3JhbnRoYVwiLFxuICAgIFwiR3JhblwiLFxuICAgIFwiR3JlZWtcIixcbiAgICBcIkdyZWtcIixcbiAgICBcIkd1amFyYXRpXCIsXG4gICAgXCJHdWpyXCIsXG4gICAgXCJHdXJtdWtoaVwiLFxuICAgIFwiR3VydVwiLFxuICAgIFwiSGFuXCIsXG4gICAgXCJIYW5pXCIsXG4gICAgXCJIYW5ndWxcIixcbiAgICBcIkhhbmdcIixcbiAgICBcIkhhbnVub29cIixcbiAgICBcIkhhbm9cIixcbiAgICBcIkhhdHJhblwiLFxuICAgIFwiSGF0clwiLFxuICAgIFwiSGVicmV3XCIsXG4gICAgXCJIZWJyXCIsXG4gICAgXCJIaXJhZ2FuYVwiLFxuICAgIFwiSGlyYVwiLFxuICAgIFwiSW1wZXJpYWxfQXJhbWFpY1wiLFxuICAgIFwiQXJtaVwiLFxuICAgIFwiSW5oZXJpdGVkXCIsXG4gICAgXCJaaW5oXCIsXG4gICAgXCJRYWFpXCIsXG4gICAgXCJJbnNjcmlwdGlvbmFsX1BhaGxhdmlcIixcbiAgICBcIlBobGlcIixcbiAgICBcIkluc2NyaXB0aW9uYWxfUGFydGhpYW5cIixcbiAgICBcIlBydGlcIixcbiAgICBcIkphdmFuZXNlXCIsXG4gICAgXCJKYXZhXCIsXG4gICAgXCJLYWl0aGlcIixcbiAgICBcIkt0aGlcIixcbiAgICBcIkthbm5hZGFcIixcbiAgICBcIktuZGFcIixcbiAgICBcIkthdGFrYW5hXCIsXG4gICAgXCJLYW5hXCIsXG4gICAgXCJLYXlhaF9MaVwiLFxuICAgIFwiS2FsaVwiLFxuICAgIFwiS2hhcm9zaHRoaVwiLFxuICAgIFwiS2hhclwiLFxuICAgIFwiS2htZXJcIixcbiAgICBcIktobXJcIixcbiAgICBcIktob2praVwiLFxuICAgIFwiS2hvalwiLFxuICAgIFwiS2h1ZGF3YWRpXCIsXG4gICAgXCJTaW5kXCIsXG4gICAgXCJMYW9cIixcbiAgICBcIkxhb29cIixcbiAgICBcIkxhdGluXCIsXG4gICAgXCJMYXRuXCIsXG4gICAgXCJMZXBjaGFcIixcbiAgICBcIkxlcGNcIixcbiAgICBcIkxpbWJ1XCIsXG4gICAgXCJMaW1iXCIsXG4gICAgXCJMaW5lYXJfQVwiLFxuICAgIFwiTGluYVwiLFxuICAgIFwiTGluZWFyX0JcIixcbiAgICBcIkxpbmJcIixcbiAgICBcIkxpc3VcIixcbiAgICBcIkx5Y2lhblwiLFxuICAgIFwiTHljaVwiLFxuICAgIFwiTHlkaWFuXCIsXG4gICAgXCJMeWRpXCIsXG4gICAgXCJNYWhhamFuaVwiLFxuICAgIFwiTWFoalwiLFxuICAgIFwiTWFsYXlhbGFtXCIsXG4gICAgXCJNbHltXCIsXG4gICAgXCJNYW5kYWljXCIsXG4gICAgXCJNYW5kXCIsXG4gICAgXCJNYW5pY2hhZWFuXCIsXG4gICAgXCJNYW5pXCIsXG4gICAgXCJNYXJjaGVuXCIsXG4gICAgXCJNYXJjXCIsXG4gICAgXCJNYXNhcmFtX0dvbmRpXCIsXG4gICAgXCJHb25tXCIsXG4gICAgXCJNZWV0ZWlfTWF5ZWtcIixcbiAgICBcIk10ZWlcIixcbiAgICBcIk1lbmRlX0tpa2FrdWlcIixcbiAgICBcIk1lbmRcIixcbiAgICBcIk1lcm9pdGljX0N1cnNpdmVcIixcbiAgICBcIk1lcmNcIixcbiAgICBcIk1lcm9pdGljX0hpZXJvZ2x5cGhzXCIsXG4gICAgXCJNZXJvXCIsXG4gICAgXCJNaWFvXCIsXG4gICAgXCJQbHJkXCIsXG4gICAgXCJNb2RpXCIsXG4gICAgXCJNb25nb2xpYW5cIixcbiAgICBcIk1vbmdcIixcbiAgICBcIk1yb1wiLFxuICAgIFwiTXJvb1wiLFxuICAgIFwiTXVsdGFuaVwiLFxuICAgIFwiTXVsdFwiLFxuICAgIFwiTXlhbm1hclwiLFxuICAgIFwiTXltclwiLFxuICAgIFwiTmFiYXRhZWFuXCIsXG4gICAgXCJOYmF0XCIsXG4gICAgXCJOZXdfVGFpX0x1ZVwiLFxuICAgIFwiVGFsdVwiLFxuICAgIFwiTmV3YVwiLFxuICAgIFwiTmtvXCIsXG4gICAgXCJOa29vXCIsXG4gICAgXCJOdXNodVwiLFxuICAgIFwiTnNodVwiLFxuICAgIFwiT2doYW1cIixcbiAgICBcIk9nYW1cIixcbiAgICBcIk9sX0NoaWtpXCIsXG4gICAgXCJPbGNrXCIsXG4gICAgXCJPbGRfSHVuZ2FyaWFuXCIsXG4gICAgXCJIdW5nXCIsXG4gICAgXCJPbGRfSXRhbGljXCIsXG4gICAgXCJJdGFsXCIsXG4gICAgXCJPbGRfTm9ydGhfQXJhYmlhblwiLFxuICAgIFwiTmFyYlwiLFxuICAgIFwiT2xkX1Blcm1pY1wiLFxuICAgIFwiUGVybVwiLFxuICAgIFwiT2xkX1BlcnNpYW5cIixcbiAgICBcIlhwZW9cIixcbiAgICBcIk9sZF9Tb3V0aF9BcmFiaWFuXCIsXG4gICAgXCJTYXJiXCIsXG4gICAgXCJPbGRfVHVya2ljXCIsXG4gICAgXCJPcmtoXCIsXG4gICAgXCJPcml5YVwiLFxuICAgIFwiT3J5YVwiLFxuICAgIFwiT3NhZ2VcIixcbiAgICBcIk9zZ2VcIixcbiAgICBcIk9zbWFueWFcIixcbiAgICBcIk9zbWFcIixcbiAgICBcIlBhaGF3aF9IbW9uZ1wiLFxuICAgIFwiSG1uZ1wiLFxuICAgIFwiUGFsbXlyZW5lXCIsXG4gICAgXCJQYWxtXCIsXG4gICAgXCJQYXVfQ2luX0hhdVwiLFxuICAgIFwiUGF1Y1wiLFxuICAgIFwiUGhhZ3NfUGFcIixcbiAgICBcIlBoYWdcIixcbiAgICBcIlBob2VuaWNpYW5cIixcbiAgICBcIlBobnhcIixcbiAgICBcIlBzYWx0ZXJfUGFobGF2aVwiLFxuICAgIFwiUGhscFwiLFxuICAgIFwiUmVqYW5nXCIsXG4gICAgXCJSam5nXCIsXG4gICAgXCJSdW5pY1wiLFxuICAgIFwiUnVuclwiLFxuICAgIFwiU2FtYXJpdGFuXCIsXG4gICAgXCJTYW1yXCIsXG4gICAgXCJTYXVyYXNodHJhXCIsXG4gICAgXCJTYXVyXCIsXG4gICAgXCJTaGFyYWRhXCIsXG4gICAgXCJTaHJkXCIsXG4gICAgXCJTaGF2aWFuXCIsXG4gICAgXCJTaGF3XCIsXG4gICAgXCJTaWRkaGFtXCIsXG4gICAgXCJTaWRkXCIsXG4gICAgXCJTaWduV3JpdGluZ1wiLFxuICAgIFwiU2dud1wiLFxuICAgIFwiU2luaGFsYVwiLFxuICAgIFwiU2luaFwiLFxuICAgIFwiU29yYV9Tb21wZW5nXCIsXG4gICAgXCJTb3JhXCIsXG4gICAgXCJTb3lvbWJvXCIsXG4gICAgXCJTb3lvXCIsXG4gICAgXCJTdW5kYW5lc2VcIixcbiAgICBcIlN1bmRcIixcbiAgICBcIlN5bG90aV9OYWdyaVwiLFxuICAgIFwiU3lsb1wiLFxuICAgIFwiU3lyaWFjXCIsXG4gICAgXCJTeXJjXCIsXG4gICAgXCJUYWdhbG9nXCIsXG4gICAgXCJUZ2xnXCIsXG4gICAgXCJUYWdiYW53YVwiLFxuICAgIFwiVGFnYlwiLFxuICAgIFwiVGFpX0xlXCIsXG4gICAgXCJUYWxlXCIsXG4gICAgXCJUYWlfVGhhbVwiLFxuICAgIFwiTGFuYVwiLFxuICAgIFwiVGFpX1ZpZXRcIixcbiAgICBcIlRhdnRcIixcbiAgICBcIlRha3JpXCIsXG4gICAgXCJUYWtyXCIsXG4gICAgXCJUYW1pbFwiLFxuICAgIFwiVGFtbFwiLFxuICAgIFwiVGFuZ3V0XCIsXG4gICAgXCJUYW5nXCIsXG4gICAgXCJUZWx1Z3VcIixcbiAgICBcIlRlbHVcIixcbiAgICBcIlRoYWFuYVwiLFxuICAgIFwiVGhhYVwiLFxuICAgIFwiVGhhaVwiLFxuICAgIFwiVGliZXRhblwiLFxuICAgIFwiVGlidFwiLFxuICAgIFwiVGlmaW5hZ2hcIixcbiAgICBcIlRmbmdcIixcbiAgICBcIlRpcmh1dGFcIixcbiAgICBcIlRpcmhcIixcbiAgICBcIlVnYXJpdGljXCIsXG4gICAgXCJVZ2FyXCIsXG4gICAgXCJWYWlcIixcbiAgICBcIlZhaWlcIixcbiAgICBcIldhcmFuZ19DaXRpXCIsXG4gICAgXCJXYXJhXCIsXG4gICAgXCJZaVwiLFxuICAgIFwiWWlpaVwiLFxuICAgIFwiWmFuYWJhemFyX1NxdWFyZVwiLFxuICAgIFwiWmFuYlwiXG4gIF1cbn07XG5BcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkYXRhLiRMT05FLCBkYXRhLkdlbmVyYWxfQ2F0ZWdvcnkpO1xuZGF0YS5nYyA9IGRhdGEuR2VuZXJhbF9DYXRlZ29yeTtcbmRhdGEuc2MgPSBkYXRhLlNjcmlwdF9FeHRlbnNpb25zID0gZGF0YS5zY3ggPSBkYXRhLlNjcmlwdDtcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gIHRoaXMuc291cmNlID0gXCJcIjtcbiAgdGhpcy5mbGFncyA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG59O1xuXG4vLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgcmV0dXJuIGNcbiAgfVxuICByZXR1cm4gKGMgPDwgMTApICsgcy5jaGFyQ29kZUF0KGkgKyAxKSAtIDB4MzVGREMwMFxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiBsXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICByZXR1cm4gaSArIDFcbiAgfVxuICByZXR1cm4gaSArIDJcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKCkge1xuICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcylcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkICgpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoKSB7XG4gIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoKSB7XG4gIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gY2gpIHtcbiAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjaCkge1xuICBpZiAoY2ggPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSB9XG4gIGNoIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDkudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT0gLTEpIHtcbiAgICAgIHRoaXMkMS5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgdGhpcyQxLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkOS52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbnBwJDkucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5wb3MgPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogWyAqLykgfHwgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxucHAkOS5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIHRoaXMkMS5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICB9XG5cbiAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICB9XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BbHRlcm5hdGl2ZVxucHAkOS5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICB7ICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxucHAkOS5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxucHAkOS5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAvLyBeLCAkXG4gIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBcXGIgXFxCXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxucHAkOS5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG5wcCQ5LnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICApXG59O1xucHAkOS5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG5wcCQ5LnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICApXG59O1xucHAkOS5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ5LnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDkucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxucHAkOS5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG5wcCQ5LnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbnBwJDkucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuLy8gQnV0IGVhdCBlYWdlci5cbnBwJDkucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxucHAkOS5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoXG4gICAgY2ggIT09IC0xICYmXG4gICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICApIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIEdyb3VwU3BlY2lmaWVyW1VdIDo6XG4vLyAgIFtlbXB0eV1cbi8vICAgYD9gIEdyb3VwTmFtZVs/VV1cbnBwJDkucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2Yoc3RhdGUubGFzdFN0cmluZ1ZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUuZ3JvdXBOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICB9XG59O1xuXG4vLyBHcm91cE5hbWVbVV0gOjpcbi8vICAgYDxgIFJlZ0V4cElkZW50aWZpZXJOYW1lWz9VXSBgPmBcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkOS5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJOYW1lW1VdIDo6XG4vLyAgIFJlZ0V4cElkZW50aWZpZXJTdGFydFs/VV1cbi8vICAgUmVnRXhwSWRlbnRpZmllck5hbWVbP1VdIFJlZ0V4cElkZW50aWZpZXJQYXJ0Wz9VXVxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQ5LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmckMShzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllclN0YXJ0W1VdIDo6XG4vLyAgIFVuaWNvZGVJRFN0YXJ0XG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbP1VdXG5wcCQ5LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gUmVnRXhwSWRlbnRpZmllclBhcnRbVV0gOjpcbi8vICAgVW5pY29kZUlEQ29udGludWVcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV1cbi8vICAgPFpXTko+XG4vLyAgIDxaV0o+XG5wcCQ5LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqLyB8fCBjaCA9PT0gMHgyMDBDIC8qIDxaV05KPiAqLyB8fCBjaCA9PT0gMHgyMDBEIC8qIDxaV0o+ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1BdG9tRXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXRBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKFxuICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgLyogYyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDkucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKHN0YXRlKSkge1xuICAgIHZhciBuID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBGb3IgU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy1hdG9tZXNjYXBlXG4gICAgICBpZiAobiA+IHN0YXRlLm1heEJhY2tSZWZlcmVuY2UpIHtcbiAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDkucmVnZXhwX2VhdEtHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCByZWZlcmVuY2VcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0WmVybyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgKCFzdGF0ZS5zd2l0Y2hVICYmIHRoaXMucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlKHN0YXRlKVxuICApXG59O1xucHAkOS5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOS5yZWdleHBfZWF0WmVybyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4MzAgLyogMCAqLyAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xFc2NhcGVcbnBwJDkucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA9PT0gMHg3NCAvKiB0ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwOTsgLyogXFx0ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDZFIC8qIG4gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBBOyAvKiBcXG4gKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzYgLyogdiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEI7IC8qIFxcdiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2NiAvKiBmICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQzsgLyogXFxmICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDcyIC8qIHIgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBEOyAvKiBcXHIgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xMZXR0ZXJcbnBwJDkucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzQ29udHJvbExldHRlcihjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg1QSAvKiBaICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg3QSAvKiB6ICovKVxuICApXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVxucHAkOS5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgbGVhZCA+PSAweEQ4MDAgJiYgbGVhZCA8PSAweERCRkYpIHtcbiAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykgJiYgc3RhdGUuZWF0KDB4NzUgLyogdSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgdmFyIHRyYWlsID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zID0gbGVhZFN1cnJvZ2F0ZUVuZDtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSAmJlxuICAgICAgaXNWYWxpZFVuaWNvZGUoc3RhdGUubGFzdEludFZhbHVlKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1ZhbGlkVW5pY29kZShjaCkge1xuICByZXR1cm4gY2ggPj0gMCAmJiBjaCA8PSAweDEwRkZGRlxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSWRlbnRpdHlFc2NhcGVcbnBwJDkucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDJGIC8qIC8gKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyAvKiAvICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDYzIC8qIGMgKi8gJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCIC8qIGsgKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxFc2NhcGVcbnBwJDkucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCA+PSAweDMxIC8qIDEgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB7XG4gICAgZG8ge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2hhcmFjdGVyQ2xhc3NFc2NhcGVcbnBwJDkucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKFxuICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJlxuICAgIChjaCA9PT0gMHg1MCAvKiBQICovIHx8IGNoID09PSAweDcwIC8qIHAgKi8pXG4gICkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICBpZiAoXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDY0IC8qIGQgKi8gfHxcbiAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgY2ggPT09IDB4NzMgLyogcyAqLyB8fFxuICAgIGNoID09PSAweDUzIC8qIFMgKi8gfHxcbiAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgY2ggPT09IDB4NTcgLyogVyAqL1xuICApXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbnBwJDkucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgLyogPSAqLykpIHtcbiAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgLy8gTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUsIG5hbWVPclZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDkucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBkYXRhW25hbWVdLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICB9XG59O1xucHAkOS5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICBpZiAoZGF0YS4kTE9ORS5pbmRleE9mKG5hbWVPclZhbHVlKSA9PT0gLTEpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfVxufTtcblxuLy8gVW5pY29kZVByb3BlcnR5TmFtZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyc1xucHAkOS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQ5LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG59XG5cbi8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDkucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG5wcCQ5LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgIHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHRoaXMucmVnZXhwX2NsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogWyAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFVucmVhY2hhYmxlIHNpbmNlIGl0IHRocmV3IFwidW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiIGVycm9yIGJlZm9yZS5cbiAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxucHAkOS5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzJDEucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIChsZWZ0ID09PSAtMSB8fCByaWdodCA9PT0gLTEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICB9XG4gICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbU5vRGFzaFxucHAkOS5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgdmFyIGNoJDEgPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgICBpZiAoY2gkMSA9PT0gMHg2MyAvKiBjICovIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2xhc3MgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCAhPT0gMHg1RCAvKiBbICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0VzY2FwZVxucHAkOS5yZWdleHBfZWF0Q2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwODsgLyogPEJTPiAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkQ7IC8qIC0gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKCFzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0NvbnRyb2xMZXR0ZXJcbnBwJDkucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbnBwJDkucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NzggLyogeCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRGlnaXRzXG5wcCQ5LnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcbmZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0c1xucHAkOS5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICB3aGlsZSAoaXNIZXhEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHx8XG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pXG4gIClcbn1cbmZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gIGlmIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB7XG4gICAgcmV0dXJuIDEwICsgKGNoIC0gMHg0MSAvKiBBICovKVxuICB9XG4gIGlmIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKSB7XG4gICAgcmV0dXJuIDEwICsgKGNoIC0gMHg2MSAvKiBhICovKVxuICB9XG4gIHJldHVybiBjaCAtIDB4MzAgLyogMCAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItTGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZVxuLy8gQWxsb3dzIG9ubHkgMC0zNzcob2N0YWwpIGkuZS4gMC0yNTUoZGVjaW1hbCkuXG5wcCQ5LnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA2NCArIG4yICogOCArIHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU9jdGFsRGlnaXRcbnBwJDkucmVnZXhwX2VhdE9jdGFsRGlnaXQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggLSAweDMwOyAvKiAwICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzNyAvKiA3ICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleDREaWdpdHNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0XG4vLyBBbmQgSGV4RGlnaXQgSGV4RGlnaXQgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RXNjYXBlU2VxdWVuY2VcbnBwJDkucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBPYmplY3QgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCB0b2tlbnMuIE5vdGUgdGhhdCBub3JtYWxseSwgdG9rZW5zXG4vLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4vLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxudmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxufTtcblxuLy8gIyMgVG9rZW5pemVyXG5cbnZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG5wcCQ4Lm5leHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5vblRva2VuKVxuICAgIHsgdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IFRva2VuKHRoaXMpKTsgfVxuXG4gIHRoaXMubGFzdFRva0VuZCA9IHRoaXMuZW5kO1xuICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhcnQ7XG4gIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jO1xuICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHRoaXMubmV4dFRva2VuKCk7XG59O1xuXG5wcCQ4LmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gbmV3IFRva2VuKHRoaXMpXG59O1xuXG4vLyBJZiB3ZSdyZSBpbiBhbiBFUzYgZW52aXJvbm1lbnQsIG1ha2UgcGFyc2VycyBpdGVyYWJsZVxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gIHsgcHAkOFtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEuZ2V0VG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSB0eXBlcy5lb2YsXG4gICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IH1cblxuLy8gVG9nZ2xlIHN0cmljdCBtb2RlLiBSZS1yZWFkcyB0aGUgbmV4dCBudW1iZXIgb3Igc3RyaW5nIHRvIHBsZWFzZVxuLy8gcGVkYW50aWMgdGVzdHMgKGBcInVzZSBzdHJpY3RcIjsgMDEwO2Agc2hvdWxkIGZhaWwpLlxuXG5wcCQ4LmN1ckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV1cbn07XG5cbi8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuLy8gcHJvcGVydGllcy5cblxucHAkOC5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKSB9XG5cbiAgaWYgKGN1ckNvbnRleHQub3ZlcnJpZGUpIHsgcmV0dXJuIGN1ckNvbnRleHQub3ZlcnJpZGUodGhpcykgfVxuICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxufTtcblxucHAkOC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiAvKiAnXFwnICovKVxuICAgIHsgcmV0dXJuIHRoaXMucmVhZFdvcmQoKSB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxufTtcblxucHAkOC5mdWxsQ2hhckNvZGVBdFBvcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZTAwMCkgeyByZXR1cm4gY29kZSB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHJldHVybiAoY29kZSA8PCAxMCkgKyBuZXh0IC0gMHgzNWZkYzAwXG59O1xuXG5wcCQ4LnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnBvcyArPSAyKTtcbiAgaWYgKGVuZCA9PT0gLTEpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIik7IH1cbiAgdGhpcy5wb3MgPSBlbmQgKyAyO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgdmFyIG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5wb3MpIHtcbiAgICAgICsrdGhpcyQxLmN1ckxpbmU7XG4gICAgICB0aGlzJDEubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbnBwJDguc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoICYmICFpc05ld0xpbmUoY2gpKSB7XG4gICAgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMkMS5wb3MpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxucHAkOC5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDEzOlxuICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgfVxuICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgaWYgKHRoaXMkMS5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMkMS5jdXJMaW5lO1xuICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSA0NzogLy8gJy8nXG4gICAgICBzd2l0Y2ggKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSkge1xuICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgIHRoaXMkMS5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzJDEuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4vLyBtYWludGFpbnMgYGNvbnRleHRgIGFuZCBgZXhwckFsbG93ZWRgLCBhbmQgc2tpcHMgdGhlIHNwYWNlIGFmdGVyXG4vLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuLy8gcmlnaHQgcG9zaXRpb24uXG5cbnBwJDguZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwJDgucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0NikgeyAvLyA0NiA9IGRvdCAnLidcbiAgICB0aGlzLnBvcyArPSAzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKVxuICB9IGVsc2Uge1xuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KVxuICB9XG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5zbGFzaCwgMSlcbn07XG5cbnBwJDgucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzLnN0YXIgOiB0eXBlcy5tb2R1bG87XG5cbiAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICsrc2l6ZTtcbiAgICB0b2tlbnR5cGUgPSB0eXBlcy5zdGFyc3RhcjtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0b2tlbnR5cGUsIHNpemUpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJ3wmJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5sb2dpY2FsT1IgOiB0eXBlcy5sb2dpY2FsQU5ELCAyKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbn07XG5cbnBwJDgucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJystJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgIGlmIChuZXh0ID09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09IDYyICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuaW5jRGVjLCAyKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSlcbn07XG5cbnBwJDgucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0U2hpZnQsIHNpemUpXG4gIH1cbiAgaWYgKG5leHQgPT0gMzMgJiYgY29kZSA9PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PSA0NSAmJlxuICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT0gNDUpIHtcbiAgICAvLyBgPCEtLWAsIGFuIFhNTC1zdHlsZSBjb21tZW50IHRoYXQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgbGluZSBjb21tZW50XG4gICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCBzaXplKVxufTtcblxucHAkOC5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJz0hJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2MiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyAvLyAnPT4nXG4gICAgdGhpcy5wb3MgKz0gMjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdylcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKVxufTtcblxucHAkOC5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAvLyBieSBhIGRpZ2l0IG9yIGFub3RoZXIgdHdvIGRvdHMuXG4gIGNhc2UgNDY6IC8vICcuJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKVxuICBjYXNlIDQxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlblIpXG4gIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnNlbWkpXG4gIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKVxuICBjYXNlIDkxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TClcbiAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldFIpXG4gIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZUwpXG4gIGNhc2UgMTI1OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpXG4gIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbG9uKVxuICBjYXNlIDYzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5xdWVzdGlvbilcblxuICBjYXNlIDk2OiAvLyAnYCdcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyBicmVhayB9XG4gICAgKyt0aGlzLnBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG5cbiAgY2FzZSA0ODogLy8gJzAnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCkgfSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICB9XG5cbiAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgY2FzZSAzNDogY2FzZSAzOTogLy8gJ1wiJywgXCInXCJcbiAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cblxuICBjYXNlIDQ3OiAvLyAnLydcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gIGNhc2UgMzc6IGNhc2UgNDI6IC8vICclKidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICBjYXNlIDk0OiAvLyAnXidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSlcblxuICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgY2FzZSAxMjY6IC8vICd+J1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnByZWZpeCwgMSlcbiAgfVxuXG4gIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmcoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcCQ4LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxufTtcblxucHAkOC5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgeyB0aGlzJDEucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQXQodGhpcyQxLnBvcyk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzJDEucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMkMS5wb3M7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHZhciBmbGFnc1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMudW5leHBlY3RlZChmbGFnc1N0YXJ0KTsgfVxuXG4gIC8vIFZhbGlkYXRlIHBhdHRlcm5cbiAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgLy8gQ3JlYXRlIExpdGVyYWwjdmFsdWUgcHJvcGVydHkgdmFsdWUuXG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvYTI3MDAzYWRmNGZkN2JmYWQ0NGRlOWNlZjM3MmEyZWFjZDUyN2IxYy9lczUubWQjcmVnZXhwbGl0ZXJhbFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyIGluIHRoZSBnaXZlbiByYWRpeC4gUmV0dXJuIG51bGwgaWYgemVybyBkaWdpdHNcbi8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4vLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxucHAkOC5yZWFkSW50ID0gZnVuY3Rpb24ocmFkaXgsIGxlbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpLCB2YWwgPSAodm9pZCAwKTtcbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICArK3RoaXMkMS5wb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICByZXR1cm4gdG90YWxcbn07XG5cbnBwJDgucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbnBwJDgucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgdmFyIG9jdGFsID0gdGhpcy5wb3MgLSBzdGFydCA+PSAyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4O1xuICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICBpZiAob2N0YWwgJiYgL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICB2YXIgdmFsID0gb2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxucHAkOC5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgaWYgKGNoID09PSAxMjMpIHsgLy8gJ3snXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpIHtcbiAgLy8gVVRGLTE2IERlY29kaW5nXG4gIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gIGNvZGUgLT0gMHgxMDAwMDtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxufVxuXG5wcCQ4LnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcyQxLnBvcyA+PSB0aGlzJDEuaW5wdXQubGVuZ3RoKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpO1xuICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgIG91dCArPSB0aGlzJDEucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICB9XG4gIH1cbiAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnN0cmluZywgb3V0KVxufTtcblxuLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxudmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbnBwJDgudHJ5UmVhZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gIHRyeSB7XG4gICAgdGhpcy5yZWFkVG1wbFRva2VuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICB0aGlzLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG59O1xuXG5wcCQ4LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgfVxufTtcblxucHAkOC5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcyQxLnBvcyA+PSB0aGlzJDEuaW5wdXQubGVuZ3RoKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyk7XG4gICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyArIDEpID09PSAxMjMpIHsgLy8gJ2AnLCAnJHsnXG4gICAgICBpZiAodGhpcyQxLnBvcyA9PT0gdGhpcyQxLnN0YXJ0ICYmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMudGVtcGxhdGUgfHwgdGhpcyQxLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgIHRoaXMkMS5wb3MgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR5cGVzLmRvbGxhckJyYWNlTClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR5cGVzLnRlbXBsYXRlLCBvdXQpXG4gICAgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgIG91dCArPSB0aGlzJDEucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpID09PSAxMCkgeyArK3RoaXMkMS5wb3M7IH1cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMkMS5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMkMS5jdXJMaW5lO1xuICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgIH1cbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG5wcCQ4LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgIHN3aXRjaCAodGhpcyQxLmlucHV0W3RoaXMkMS5wb3NdKSB7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiJFwiOlxuICAgICAgaWYgKHRoaXMkMS5pbnB1dFt0aGlzJDEucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgY2FzZSBcImBcIjpcbiAgICAgIHJldHVybiB0aGlzJDEuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzJDEuaW5wdXQuc2xpY2UodGhpcyQxLnN0YXJ0LCB0aGlzJDEucG9zKSlcblxuICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH1cbiAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxucHAkOC5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgc3dpdGNoIChjaCkge1xuICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICByZXR1cm4gXCJcIlxuICBkZWZhdWx0OlxuICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PSA1NiB8fCBjaCA9PSA1NykgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICBpblRlbXBsYXRlXG4gICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKVxuICB9XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG5wcCQ4LnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gIHJldHVybiBuXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuY29udGFpbnNFc2NgXG4vLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbi8vXG4vLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4vLyBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxucHAkOC5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcyQxLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgIHRoaXMkMS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICB0aGlzJDEuY29udGFpbnNFc2MgPSB0cnVlO1xuICAgICAgd29yZCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcyQxLnBvcykgIT0gMTE3KSAvLyBcInVcIlxuICAgICAgICB7IHRoaXMkMS5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcyQxLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgICB2YXIgZXNjID0gdGhpcyQxLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgIHsgdGhpcyQxLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nKGVzYyk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbi8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG5wcCQ4LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgdmFyIHR5cGUgPSB0eXBlcy5uYW1lO1xuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB3b3JkKTsgfVxuICAgIHR5cGUgPSBrZXl3b3JkcyQxW3dvcmRdO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG59O1xuXG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UsIEluZ3ZhciBTdGVwYW55YW4sIGFuZFxuLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi5naXRcbi8vXG4vLyBQbGVhc2UgdXNlIHRoZSBbZ2l0aHViIGJ1ZyB0cmFja2VyXVtnaGJ0XSB0byByZXBvcnQgaXNzdWVzLlxuLy9cbi8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzXG4vL1xuLy8gVGhpcyBmaWxlIGRlZmluZXMgdGhlIG1haW4gcGFyc2VyIGludGVyZmFjZS4gVGhlIGxpYnJhcnkgYWxzbyBjb21lc1xuLy8gd2l0aCBhIFtlcnJvci10b2xlcmFudCBwYXJzZXJdW2RhbW1pdF0gYW5kIGFuXG4vLyBbYWJzdHJhY3Qgc3ludGF4IHRyZWUgd2Fsa2VyXVt3YWxrXSwgZGVmaW5lZCBpbiBvdGhlciBmaWxlcy5cbi8vXG4vLyBbZGFtbWl0XTogYWNvcm5fbG9vc2UuanNcbi8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cbnZhciB2ZXJzaW9uID0gXCI1LjUuM1wiO1xuXG4vLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbi8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuLy8gQVBJXVthcGldLlxuLy9cbi8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHAgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwLm5leHRUb2tlbigpO1xuICByZXR1cm4gcC5wYXJzZUV4cHJlc3Npb24oKVxufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KVxufVxuXG4vLyBUaGlzIGlzIGEgdGVycmlibGUga2x1ZGdlIHRvIHN1cHBvcnQgdGhlIGV4aXN0aW5nLCBwcmUtRVM2XG4vLyBpbnRlcmZhY2Ugd2hlcmUgdGhlIGxvb3NlIHBhcnNlciBtb2R1bGUgcmV0cm9hY3RpdmVseSBhZGRzIGV4cG9ydHNcbi8vIHRvIHRoaXMgbW9kdWxlLlxudmFyIHBhcnNlX2RhbW1pdDtcbnZhciBMb29zZVBhcnNlcjtcbnZhciBwbHVnaW5zTG9vc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5mdW5jdGlvbiBhZGRMb29zZUV4cG9ydHMocGFyc2UsIFBhcnNlciQkMSwgcGx1Z2lucyQkMSkge1xuICBwYXJzZV9kYW1taXQgPSBwYXJzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgTG9vc2VQYXJzZXIgPSBQYXJzZXIkJDE7XG4gIHBsdWdpbnNMb29zZSA9IHBsdWdpbnMkJDE7XG59XG5cbmV4cG9ydCB7IHZlcnNpb24sIHBhcnNlLCBwYXJzZUV4cHJlc3Npb25BdCwgdG9rZW5pemVyLCBwYXJzZV9kYW1taXQsIExvb3NlUGFyc2VyLCBwbHVnaW5zTG9vc2UsIGFkZExvb3NlRXhwb3J0cywgUGFyc2VyLCBwbHVnaW5zLCBkZWZhdWx0T3B0aW9ucywgUG9zaXRpb24sIFNvdXJjZUxvY2F0aW9uLCBnZXRMaW5lSW5mbywgTm9kZSwgVG9rZW5UeXBlLCB0eXBlcyBhcyB0b2tUeXBlcywga2V5d29yZHMkMSBhcyBrZXl3b3JkVHlwZXMsIFRva0NvbnRleHQsIHR5cGVzJDEgYXMgdG9rQ29udGV4dHMsIGlzSWRlbnRpZmllckNoYXIsIGlzSWRlbnRpZmllclN0YXJ0LCBUb2tlbiwgaXNOZXdMaW5lLCBsaW5lQnJlYWssIGxpbmVCcmVha0csIG5vbkFTQ0lJd2hpdGVzcGFjZSB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/acorn/dist/acorn.es.js\n");

/***/ }),

/***/ "./node_modules/after/index.js":
/*!*************************************!*\
  !*** ./node_modules/after/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanM/Y2NjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcbiAgICB2YXIgYmFpbCA9IGZhbHNlXG4gICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3BcbiAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cbiAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG4gICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcbiAgICAgICAgfVxuICAgICAgICAtLXByb3h5LmNvdW50XG5cbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2JcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWVcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/after/index.js\n");

/***/ }),

/***/ "./node_modules/arraybuffer.slice/index.js":
/*!*************************************************!*\
  !*** ./node_modules/arraybuffer.slice/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanM/Y2E5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHNDQUFzQzs7QUFFaEUsa0JBQWtCLGdCQUFnQjtBQUNsQyxnQkFBZ0IsY0FBYztBQUM5QixvQkFBb0IsYUFBYTs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/arraybuffer.slice/index.js\n");

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzPzBiNjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/backo2/index.js\n");

/***/ }),

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanM/ODM5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\n");

/***/ }),

/***/ "./node_modules/blob/index.js":
/*!************************************!*\
  !*** ./node_modules/blob/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var a = new Blob(['hi']);\n    return a.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if Blob constructor supports ArrayBufferViews\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\n */\n\nvar blobSupportsArrayBufferView = blobSupported && (function() {\n  try {\n    var b = new Blob([new Uint8Array([1,2])]);\n    return b.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\n/**\n * Helper function that maps ArrayBufferViews to ArrayBuffers\n * Used by BlobBuilder constructor and old browsers that didn't\n * support it in the Blob constructor.\n */\n\nfunction mapArrayBufferViews(ary) {\n  for (var i = 0; i < ary.length; i++) {\n    var chunk = ary[i];\n    if (chunk.buffer instanceof ArrayBuffer) {\n      var buf = chunk.buffer;\n\n      // if this is a subarray, make a copy so we only\n      // include the subarray region from the underlying buffer\n      if (chunk.byteLength !== buf.byteLength) {\n        var copy = new Uint8Array(chunk.byteLength);\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n        buf = copy.buffer;\n      }\n\n      ary[i] = buf;\n    }\n  }\n}\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  mapArrayBufferViews(ary);\n\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nfunction BlobConstructor(ary, options) {\n  mapArrayBufferViews(ary);\n  return new Blob(ary, options || {});\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcz9kNzgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/blob/index.js\n");

/***/ }),

/***/ "./node_modules/component-bind/index.js":
/*!**********************************************!*\
  !*** ./node_modules/component-bind/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanM/NDBkZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/component-bind/index.js\n");

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (true) {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanM/NzI5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/component-emitter/index.js\n");

/***/ }),

/***/ "./node_modules/component-inherit/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-inherit/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWluaGVyaXQvaW5kZXguanM/NjJmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/component-inherit/index.js\n");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanM/MzRlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzPzk2ZmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/debug/src/debug.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nmodule.exports = __webpack_require__(/*! ./socket */ \"./node_modules/engine.io-client/lib/socket.js\");\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanM/OTRhYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/index.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar transports = __webpack_require__(/*! ./transports/index */ \"./node_modules/engine.io-client/lib/transports/index.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('engine.io-client:socket');\nvar index = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar parseuri = __webpack_require__(/*! parseuri */ \"./node_modules/parseuri/index.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (global.location && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.transportOptions = opts.transportOptions || {};\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global === 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = __webpack_require__(/*! ./transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nSocket.transports = __webpack_require__(/*! ./transports/index */ \"./node_modules/engine.io-client/lib/transports/index.js\");\nSocket.parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // per-transport options\n  var options = this.transportOptions[name] || {};\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    query: query,\n    socket: this,\n    agent: options.agent || this.agent,\n    hostname: options.hostname || this.hostname,\n    port: options.port || this.port,\n    secure: options.secure || this.secure,\n    path: options.path || this.path,\n    forceJSONP: options.forceJSONP || this.forceJSONP,\n    jsonp: options.jsonp || this.jsonp,\n    forceBase64: options.forceBase64 || this.forceBase64,\n    enablesXDR: options.enablesXDR || this.enablesXDR,\n    timestampRequests: options.timestampRequests || this.timestampRequests,\n    timestampParam: options.timestampParam || this.timestampParam,\n    policyPort: options.policyPort || this.policyPort,\n    pfx: options.pfx || this.pfx,\n    key: options.key || this.key,\n    passphrase: options.passphrase || this.passphrase,\n    cert: options.cert || this.cert,\n    ca: options.ca || this.ca,\n    ciphers: options.ciphers || this.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,\n    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,\n    extraHeaders: options.extraHeaders || this.extraHeaders,\n    forceNode: options.forceNode || this.forceNode,\n    localAddress: options.localAddress || this.localAddress,\n    requestTimeout: options.requestTimeout || this.requestTimeout,\n    protocols: options.protocols || void (0)\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(JSON.parse(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzP2RhOTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGOztBQUUzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCAodXJpLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuICAgIDogKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgID8gbG9jYXRpb24ucG9ydFxuICAgICAgOiAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMudHJhbnNwb3J0T3B0aW9ucyA9IG9wdHMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cbiAgaWYgKHRydWUgPT09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkID0gMTAyNDtcbiAgfVxuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCkge1xuICAgIGlmIChvcHRzLmV4dHJhSGVhZGVycyAmJiBPYmplY3Qua2V5cyhvcHRzLmV4dHJhSGVhZGVycykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IG9uIGhhbmRzaGFrZVxuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy51cGdyYWRlcyA9IG51bGw7XG4gIHRoaXMucGluZ0ludGVydmFsID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cbiAgLy8gc2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLnRyYW5zcG9ydE9wdGlvbnNbbmFtZV0gfHwge307XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiBvcHRpb25zLmhvc3RuYW1lIHx8IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogb3B0aW9ucy5wb3J0IHx8IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGgsXG4gICAgZm9yY2VKU09OUDogb3B0aW9ucy5mb3JjZUpTT05QIHx8IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiBvcHRpb25zLmZvcmNlQmFzZTY0IHx8IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogb3B0aW9ucy5lbmFibGVzWERSIHx8IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KTtcbiAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3BlbiAoKSB7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09PSBtc2cudHlwZSAmJiAncHJvYmUnID09PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yIChlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG4gICAgb25lcnJvcigndHJhbnNwb3J0IGNsb3NlZCcpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSAodG8pIHtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHJpdmF0ZVxuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/socket.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzPzE5YjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuICB0aGlzLmZvcmNlTm9kZSA9IG9wdHMuZm9yY2VOb2RlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/transport.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\nvar XHR = __webpack_require__(/*! ./polling-xhr */ \"./node_modules/engine.io-client/lib/transports/polling-xhr.js\");\nvar JSONP = __webpack_require__(/*! ./polling-jsonp */ \"./node_modules/engine.io-client/lib/transports/polling-jsonp.js\");\nvar websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/engine.io-client/lib/transports/websocket.js\");\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcz82YTQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/transports/index.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module requirements.\n */\n\nvar Polling = __webpack_require__(/*! ./polling */ \"./node_modules/engine.io-client/lib/transports/polling.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzPzBhNWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH0gZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/transports/polling-jsonp.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\nvar Polling = __webpack_require__(/*! ./polling */ \"./node_modules/engine.io-client/lib/transports/polling.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n  this.extraHeaders = opts.extraHeaders;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname !== global.location.hostname ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 2) {\n          try {\n            var contentType = xhr.getResponseHeader('Content-Type');\n            if (self.supportsBinary && contentType === 'application/octet-stream') {\n              xhr.responseType = 'arraybuffer';\n            }\n          } catch (e) {}\n        }\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type');\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      data = this.xhr.responseText;\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (global.document) {\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcz9kMzNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpREFBaUQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwyREFBMkQ7QUFDM0Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkge31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9PSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcbiAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIG9wdHMucmVxdWVzdFRpbWVvdXQgPSB0aGlzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoJ1BPU1QnID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc3VwcG9ydHNCaW5hcnkgJiYgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/transports/polling-xhr.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar yeast = __webpack_require__(/*! yeast */ \"./node_modules/yeast/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/engine.io-client/lib/xmlhttprequest.js\");\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n     ('http' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzPzA5NDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG9uUGF1c2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSAoKSB7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/transports/polling.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/browser.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar yeast = __webpack_require__(/*! yeast */ \"./node_modules/yeast/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\nvar NodeWebSocket;\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = __webpack_require__(/*! ws */ 0);\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  WebSocket = NodeWebSocket;\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  this.protocols = opts.protocols;\n  if (!this.usingBrowserWebSocket) {\n    WebSocket = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = this.protocols;\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanM/MDg4MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgeWVhc3QgPSByZXF1aXJlKCd5ZWFzdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcbnZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xudmFyIE5vZGVXZWJTb2NrZXQ7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHJ5IHtcbiAgICBOb2RlV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgfSBjYXRjaCAoZSkgeyB9XG59XG5cbi8qKlxuICogR2V0IGVpdGhlciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIgb3IgdHJ5IHRvIHJlc29sdmUgV2ViU29ja2V0LWNvbXBhdGlibGVcbiAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcbmlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIFdlYlNvY2tldCA9IE5vZGVXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG4gIHRoaXMucHJvdG9jb2xzID0gb3B0cy5wcm90b2NvbHM7XG4gIGlmICghdGhpcy51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHRoaXMucHJvdG9jb2xzO1xuICB2YXIgb3B0cyA9IHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZVxuICB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgb3B0cy5oZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG4gIH1cbiAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgb3B0cy5sb2NhbEFkZHJlc3MgPSB0aGlzLmxvY2FsQWRkcmVzcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gKHByb3RvY29scyA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIDogbmV3IFdlYlNvY2tldCh1cmkpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdub2RlYnVmZmVyJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB9XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICB2YXIgdG90YWwgPSBwYWNrZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b3RhbDsgaSA8IGw7IGkrKykge1xuICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG4gICAgICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxlbiA9ICdzdHJpbmcnID09PSB0eXBlb2YgZGF0YSA/IGdsb2JhbC5CdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/transports/websocket.js\n");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!*************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module\n\nvar hasCORS = __webpack_require__(/*! has-cors */ \"./node_modules/has-cors/index.js\");\n\nmodule.exports = function (opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');\n    } catch (e) { }\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanM/MDFkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi94bWxodHRwcmVxdWVzdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW1snQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyldKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/engine.io-client/lib/xmlhttprequest.js\n");

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * Module dependencies.\n */\n\nvar keys = __webpack_require__(/*! ./keys */ \"./node_modules/engine.io-parser/lib/keys.js\");\nvar hasBinary = __webpack_require__(/*! has-binary2 */ \"./node_modules/has-binary2/index.js\");\nvar sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ \"./node_modules/arraybuffer.slice/index.js\");\nvar after = __webpack_require__(/*! after */ \"./node_modules/after/index.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"./node_modules/engine.io-parser/lib/utf8.js\");\n\nvar base64encoder;\nif (global && global.ArrayBuffer) {\n  base64encoder = __webpack_require__(/*! base64-arraybuffer */ \"./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\");\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = __webpack_require__(/*! blob */ \"./node_modules/blob/index.js\");\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data === 'string') {\n    if (data.charAt(0) === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var ret = callback(packet, i + n, l);\n      if (false === ret) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] === 255) break;\n\n      // 310 = char length of Number.MAX_VALUE\n      if (msgLength.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcz81YTZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQixvQ0FBb0M7QUFDcEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKGdsb2JhbCAmJiBnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/engine.io-parser/lib/browser.js\n");

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/keys.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcz83NjRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-parser/lib/keys.js\n");

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/utf8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.1.2 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint, strict) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tif (strict) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t\t' is not a scalar value'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint, strict) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tif (!checkScalarValue(codePoint, strict)) {\n\t\t\t\tcodePoint = 0xFFFD;\n\t\t\t}\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string, opts) {\n\t\topts = opts || {};\n\t\tvar strict = false !== opts.strict;\n\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint, strict);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol(strict) {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\treturn checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString, opts) {\n\t\topts = opts || {};\n\t\tvar strict = false !== opts.strict;\n\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol(strict)) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.1.2',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn utf8;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\telse { var key, hasOwnProperty, object; }\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcz9hMDgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJzREFBQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFBQTtBQUNILEVBQUUsMENBWUY7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi91dGY4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdHRocm93IEVycm9yKFxuXHRcdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICghY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkpIHtcblx0XHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdFx0fVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuXHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKHN0cmljdCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdFx0b3B0cyA9IG9wdHMgfHwge307XG5cdFx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblxuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMS4yJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/engine.io-parser/lib/utf8.js\n");

/***/ }),

/***/ "./node_modules/has-binary2/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-binary2/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/* global Blob File */\n\n/*\n * Module requirements.\n */\n\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Supports Buffer, ArrayBuffer, Blob and File.\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary (obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  if (isArray(obj)) {\n    for (var i = 0, l = obj.length; i < l; i++) {\n      if (hasBinary(obj[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||\n     (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||\n     (withNativeBlob && obj instanceof Blob) ||\n     (withNativeFile && obj instanceof File)\n    ) {\n    return true;\n  }\n\n  // see: https://github.com/Automattic/has-binary/pull/4\n  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {\n    return hasBinary(obj.toJSON(), true);\n  }\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeTIvaW5kZXguanM/NThiMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEJsb2IgRmlsZSAqL1xuXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBnbG9iYWwuQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5CbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG52YXIgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgZ2xvYmFsLkZpbGUgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuRmlsZSkgPT09ICdbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl0nO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogU3VwcG9ydHMgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQmxvYiBhbmQgRmlsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIGdsb2JhbC5CdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2hhcy1iaW5hcnkvcHVsbC80XG4gIGlmIChvYmoudG9KU09OICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/has-binary2/index.js\n");

/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-cors/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWNvcnMvaW5kZXguanM/YzllYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/has-cors/index.js\n");

/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcz9lZTM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/indexof/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lM2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MTQ2OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ms/index.js\n");

/***/ }),

/***/ "./node_modules/paper/dist/paper-full.js":
/*!***********************************************!*\
  !*** ./node_modules/paper/dist/paper-full.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Paper.js v0.11.5 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey\n * http://scratchdisk.com/ & http://jonathanpuckey.com/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Thu Oct 5 16:16:29 2017 +0200\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2016 Juerg Lehni\n * http://scratchdisk.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * http://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = function(self, undefined) {\n\nself = self || __webpack_require__(/*! ./node/self.js */ 1);\nvar window = self.window,\n\tdocument = self.document;\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\tarray = [],\n\t\tslice = array.slice,\n\t\tcreate = Object.create,\n\t\tdescribe = Object.getOwnPropertyDescriptor,\n\t\tdefine = Object.defineProperty,\n\n\t\tforEach = array.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this) {\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tset = Object.assign || function(dst) {\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tfor (var key in src) {\n\t\t\t\t\tif (src.hasOwnProperty(key))\n\t\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\n\t\teach = function(obj, iter, bind) {\n\t\t\tif (obj) {\n\t\t\t\tvar desc = describe(obj, 'length');\n\t\t\t\t(desc && typeof desc.value === 'number' ? forEach : forIn)\n\t\t\t\t\t.call(obj, iter, bind = bind || obj);\n\t\t\t}\n\t\t\treturn bind;\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res)) {\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t}\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable != null ? enumerable : !bean;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tvar src = arguments[i];\n\t\t\tif (src)\n\t\t\t\tset(this, src);\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn inject(Base, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, null, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, obj, l = arguments.length;\n\t\t\t\t\ti < l && !(ctor && proto); i++) {\n\t\t\t\tobj = arguments[i];\n\t\t\t\tctor = ctor || obj.initialize;\n\t\t\t\tproto = proto || obj.prototype;\n\t\t\t}\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = proto || create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}).inject({\n\t\tenumerable: false,\n\n\t\tinitialize: Base,\n\n\t\tset: Base,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src) {\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\tset: set,\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t},\n\n\t\t\tslice: function(list, begin, end) {\n\t\t\t\treturn slice.call(list, begin, end);\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (true)\n\tmodule.exports = Base;\n\nBase.inject({\n\tenumerable: false,\n\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\timportJSON: function(json) {\n\t\treturn Base.importJSON(json, this);\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\tset: function(props, exclude) {\n\t\tif (props)\n\t\t\tBase.filter(this, props, exclude, this._prioritize);\n\t\treturn this;\n\t}\n}, {\n\nbeans: false,\nstatics: {\n\texports: {},\n\n\textend: function extend() {\n\t\tvar res = extend.base.apply(this, arguments),\n\t\t\tname = res.prototype._class;\n\t\tif (name && !Base.exports[name])\n\t\t\tBase.exports[name] = res;\n\t\treturn res;\n\t},\n\n\tequals: function(obj1, obj2) {\n\t\tif (obj1 === obj2)\n\t\t\treturn true;\n\t\tif (obj1 && obj1.equals)\n\t\t\treturn obj1.equals(obj2);\n\t\tif (obj2 && obj2.equals)\n\t\t\treturn obj2.equals(obj1);\n\t\tif (obj1 && obj2\n\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\tvar length = obj1.length;\n\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\tlength = keys.length;\n\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tread: function(list, start, options, amount) {\n\t\tif (this === Base) {\n\t\t\tvar value = this.peek(list, start);\n\t\t\tlist.__index++;\n\t\t\treturn value;\n\t\t}\n\t\tvar proto = this.prototype,\n\t\t\treadIndex = proto._readIndex,\n\t\t\tbegin = start || readIndex && list.__index || 0,\n\t\t\tlength = list.length,\n\t\t\tobj = list[begin];\n\t\tamount = amount || length - begin;\n\t\tif (obj instanceof this\n\t\t\t|| options && options.readNull && obj == null && amount <= 1) {\n\t\t\tif (readIndex)\n\t\t\t\tlist.__index = begin + 1;\n\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t}\n\t\tobj = Base.create(proto);\n\t\tif (readIndex)\n\t\t\tobj.__read = true;\n\t\tobj = obj.initialize.apply(obj, begin > 0 || begin + amount < length\n\t\t\t\t? Base.slice(list, begin, begin + amount)\n\t\t\t\t: list) || obj;\n\t\tif (readIndex) {\n\t\t\tlist.__index = begin + obj.__read;\n\t\t\tvar filtered = obj.__filtered;\n\t\t\tif (filtered) {\n\t\t\t\tlist.__filtered = filtered;\n\t\t\t\tobj.__filtered = undefined;\n\t\t\t}\n\t\t\tobj.__read = undefined;\n\t\t}\n\t\treturn obj;\n\t},\n\n\tpeek: function(list, start) {\n\t\treturn list[list.__index = start || list.__index || 0];\n\t},\n\n\tremain: function(list) {\n\t\treturn list.length - (list.__index || 0);\n\t},\n\n\treadList: function(list, start, options, amount) {\n\t\tvar res = [],\n\t\t\tentry,\n\t\t\tbegin = start || 0,\n\t\t\tend = amount ? begin + amount : list.length;\n\t\tfor (var i = begin; i < end; i++) {\n\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t}\n\t\treturn res;\n\t},\n\n\treadNamed: function(list, name, start, options, amount) {\n\t\tvar value = this.getNamed(list, name),\n\t\t\thasObject = value !== undefined;\n\t\tif (hasObject) {\n\t\t\tvar filtered = list.__filtered;\n\t\t\tif (!filtered) {\n\t\t\t\tfiltered = list.__filtered = Base.create(list[0]);\n\t\t\t\tfiltered.__unfiltered = list[0];\n\t\t\t}\n\t\t\tfiltered[name] = undefined;\n\t\t}\n\t\tvar l = hasObject ? [value] : list,\n\t\t\tres = this.read(l, start, options, amount);\n\t\treturn res;\n\t},\n\n\tgetNamed: function(list, name) {\n\t\tvar arg = list[0];\n\t\tif (list._hasObject === undefined)\n\t\t\tlist._hasObject = list.length === 1 && Base.isPlainObject(arg);\n\t\tif (list._hasObject)\n\t\t\treturn name ? arg[name] : list.__filtered || arg;\n\t},\n\n\thasNamed: function(list, name) {\n\t\treturn !!this.getNamed(list, name);\n\t},\n\n\tfilter: function(dest, source, exclude, prioritize) {\n\t\tvar processed;\n\n\t\tfunction handleKey(key) {\n\t\t\tif (!(exclude && key in exclude) &&\n\t\t\t\t!(processed && key in processed)) {\n\t\t\t\tvar value = source[key];\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\tdest[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tif (prioritize) {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0, key, l = prioritize.length; i < l; i++) {\n\t\t\t\tif ((key = prioritize[i]) in source) {\n\t\t\t\t\thandleKey(key);\n\t\t\t\t\tkeys[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed = keys;\n\t\t}\n\n\t\tObject.keys(source.__unfiltered || source).forEach(handleKey);\n\t\treturn dest;\n\t},\n\n\tisPlainValue: function(obj, asString) {\n\t\treturn Base.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t|| asString && typeof obj === 'string';\n\t},\n\n\tserialize: function(obj, options, compact, dictionary) {\n\t\toptions = options || {};\n\n\t\tvar isRoot = !dictionary,\n\t\t\tres;\n\t\tif (isRoot) {\n\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\tdictionary = {\n\t\t\t\tlength: 0,\n\t\t\t\tdefinitions: {},\n\t\t\t\treferences: {},\n\t\t\t\tadd: function(item, create) {\n\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t}\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (obj && obj._serialize) {\n\t\t\tres = obj._serialize(options, dictionary);\n\t\t\tvar name = obj._class;\n\t\t\tif (name && !obj._compactSerialize && (isRoot || !compact)\n\t\t\t\t\t&& res[0] !== name) {\n\t\t\t\tres.unshift(name);\n\t\t\t}\n\t\t} else if (Array.isArray(obj)) {\n\t\t\tres = [];\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\tres[i] = Base.serialize(obj[i], options, compact, dictionary);\n\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\tres = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\tdictionary);\n\t\t\t}\n\t\t} else if (typeof obj === 'number') {\n\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t} else {\n\t\t\tres = obj;\n\t\t}\n\t\treturn isRoot && dictionary.length > 0\n\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t: res;\n\t},\n\n\tdeserialize: function(json, create, _data, _setDictionary, _isRoot) {\n\t\tvar res = json,\n\t\t\tisFirst = !_data,\n\t\t\thasDictionary = isFirst && json && json.length\n\t\t\t\t&& json[0][0] === 'dictionary';\n\t\t_data = _data || {};\n\t\tif (Array.isArray(json)) {\n\t\t\tvar type = json[0],\n\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\tif (json.length == 1 && /^#/.test(type)) {\n\t\t\t\treturn _data.dictionary[type];\n\t\t\t}\n\t\t\ttype = Base.exports[type];\n\t\t\tres = [];\n\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++) {\n\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\tisDictionary, hasDictionary));\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tvar args = res;\n\t\t\t\tif (create) {\n\t\t\t\t\tres = create(type, args, isFirst || _isRoot);\n\t\t\t\t} else {\n\t\t\t\t\tres = Base.create(type.prototype);\n\t\t\t\t\ttype.apply(res, args);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Base.isPlainObject(json)) {\n\t\t\tres = {};\n\t\t\tif (_setDictionary)\n\t\t\t\t_data.dictionary = res;\n\t\t\tfor (var key in json)\n\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t}\n\t\treturn hasDictionary ? res[1] : res;\n\t},\n\n\texportJSON: function(obj, options) {\n\t\tvar json = Base.serialize(obj, options);\n\t\treturn options && options.asString == false\n\t\t\t\t? json\n\t\t\t\t: JSON.stringify(json);\n\t},\n\n\timportJSON: function(json, target) {\n\t\treturn Base.deserialize(\n\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\tfunction(ctor, args, isRoot) {\n\t\t\t\t\tvar useTarget = isRoot && target\n\t\t\t\t\t\t\t&& target.constructor === ctor,\n\t\t\t\t\t\tobj = useTarget ? target\n\t\t\t\t\t\t\t: Base.create(ctor.prototype);\n\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t&& (useTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\tif (Base.isPlainObject(arg))\n\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t}\n\t\t\t\t\t(useTarget ? obj.set : ctor).apply(obj, args);\n\t\t\t\t\tif (useTarget)\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\treturn obj;\n\t\t\t\t});\n\t},\n\n\tsplice: function(list, items, index, remove) {\n\t\tvar amount = items && items.length,\n\t\t\tappend = index === undefined;\n\t\tindex = append ? list.length : index;\n\t\tif (index > list.length)\n\t\t\tindex = list.length;\n\t\tfor (var i = 0; i < amount; i++)\n\t\t\titems[i]._index = index + i;\n\t\tif (append) {\n\t\t\tlist.push.apply(list, items);\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar args = [index, remove];\n\t\t\tif (items)\n\t\t\t\targs.push.apply(args, items);\n\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\tremoved[i]._index = undefined;\n\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\tlist[i]._index = i;\n\t\t\treturn removed;\n\t\t}\n\t},\n\n\tcapitalize: function(str) {\n\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t},\n\n\tcamelize: function(str) {\n\t\treturn str.replace(/-(.)/g, function(match, chr) {\n\t\t\treturn chr.toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(str) {\n\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t}\n}});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, func);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = Base.slice(arguments, 1),\n\t\t\tsetTarget = event && event.target && !event.currentTarget;\n\t\thandlers = handlers.slice();\n\t\tif (setTarget)\n\t\t\tevent.currentTarget = this;\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) == false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t   }\n\t\t}\n\t\tif (setTarget)\n\t\t\tdelete event.currentTarget;\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar types = this._eventTypes,\n\t\t\thandlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tif (types) {\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar entry = types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\tinsertItems: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1) || {};\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\t\tif (!this.agent) {\n\t\t\tvar user = self.navigator.userAgent.toLowerCase(),\n\t\t\t\tos = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],\n\t\t\t\tplatform = os === 'darwin' ? 'mac' : os,\n\t\t\t\tagent = proto.agent = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tagent[platform] = true;\n\t\t\tuser.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g,\n\t\t\t\tfunction(match, n, v1, v2, rv) {\n\t\t\t\t\tif (!agent.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 :\n\t\t\t\t\t\t\t\t/^(node|trident)$/.test(n) ? rv : v1;\n\t\t\t\t\t\tagent.version = v;\n\t\t\t\t\t\tagent.versionNumber = parseFloat(v);\n\t\t\t\t\t\tn = n === 'trident' ? 'msie' : n;\n\t\t\t\t\t\tagent.name = n;\n\t\t\t\t\t\tagent[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (agent.chrome)\n\t\t\t\tdelete agent.webkit;\n\t\t\tif (agent.atom)\n\t\t\t\tdelete agent.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.11.5\",\n\n\tgetView: function() {\n\t\tvar project = this.project;\n\t\treturn project && project._view;\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, options) {\n\t\tpaper.PaperScript.execute(code, this, options);\n\t\tView.updateFocus();\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tcreateCanvas: function(width, height) {\n\t\treturn CanvasProvider.getCanvas(width, height);\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tvar projects = this.projects,\n\t\t\ttools = this.tools;\n\t\tfor (var i = projects.length - 1; i >= 0; i--)\n\t\t\tprojects[i].remove();\n\t\tfor (var i = tools.length - 1; i >= 0; i--)\n\t\t\ttools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._scope.getView();\n\t}\n});\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = Base.pick(precision, 5);\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn this.precision < 16\n\t\t\t\t? Math.round(val * this.multiplier) / this.multiplier : val;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tlog2 = Math.log2 || function(x) {\n\t\t\treturn Math.log(x) * Math.LOG2E;\n\t\t},\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clamp(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\tfunction getDiscriminant(a, b, c) {\n\t\tfunction split(v) {\n\t\t\tvar x = v * 134217729,\n\t\t\t\ty = v - x,\n\t\t\t\thi = y + x,\n\t\t\t\tlo = v - hi;\n\t\t\treturn [hi, lo];\n\t\t}\n\n\t\tvar D = b * b - a * c,\n\t\t\tE = b * b + a * c;\n\t\tif (abs(D) * 3 < E) {\n\t\t\tvar ad = split(a),\n\t\t\t\tbd = split(b),\n\t\t\t\tcd = split(c),\n\t\t\t\tp = b * b,\n\t\t\t\tdp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],\n\t\t\t\tq = a * c,\n\t\t\t\tdq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])\n\t\t\t\t\t\t+ ad[1] * cd[1];\n\t\t\tD = (p - q) + (dp - dq);\n\t\t}\n\t\treturn D;\n\t}\n\n\tfunction getNormalizationFactor() {\n\t\tvar norm = Math.max.apply(Math, arguments);\n\t\treturn norm && (norm < 1e-8 || norm > 1e8)\n\t\t\t\t? pow(2, -Math.round(log2(norm)))\n\t\t\t\t: 0;\n\t}\n\n\treturn {\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 1e-8,\n\t\tGEOMETRIC_EPSILON: 1e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-8,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tclamp: clamp,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance) {\n\t\t\t\t\tx = nx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clamp(x, a, b);\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar x1, x2 = Infinity;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(b) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / b;\n\t\t\t} else {\n\t\t\t\tb *= -0.5;\n\t\t\t\tvar D = getDiscriminant(a, b, c);\n\t\t\t\tif (D && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c));\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\ta *= f;\n\t\t\t\t\t\tb *= f;\n\t\t\t\t\t\tc *= f;\n\t\t\t\t\t\tD = getDiscriminant(a, b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0,\n\t\t\t\tboundless = min == null,\n\t\t\t\tminB = min - EPSILON,\n\t\t\t\tmaxB = max + EPSILON;\n\t\t\tif (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))\n\t\t\t\troots[count++] = boundless ? x1 : clamp(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))\n\t\t\t\troots[count++] = boundless ? x2 : clamp(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),\n\t\t\t\tx, b1, c2, qd, q;\n\t\t\tif (f) {\n\t\t\t\ta *= f;\n\t\t\t\tb *= f;\n\t\t\t\tc *= f;\n\t\t\t\td *= f;\n\t\t\t}\n\n\t\t\tfunction evaluate(x0) {\n\t\t\t\tx = x0;\n\t\t\t\tvar tmp = a * x;\n\t\t\t\tb1 = tmp + b;\n\t\t\t\tc2 = b1 * x + c;\n\t\t\t\tqd = (tmp + b1) * x + c2;\n\t\t\t\tq = c2 * x + d;\n\t\t\t}\n\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tevaluate(-(b / a) / 3);\n\t\t\t\tvar t = q / a,\n\t\t\t\t\tr = pow(abs(t), 1/3),\n\t\t\t\t\ts = t < 0 ? -1 : 1,\n\t\t\t\t\ttd = -qd / a,\n\t\t\t\t\trd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,\n\t\t\t\t\tx0 = x - s * rd;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tevaluate(x0);\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),\n\t\t\t\tboundless = min == null;\n\t\t\tif (isFinite(x) && (count === 0\n\t\t\t\t\t|| count > 0 && x !== roots[0] && x !== roots[1])\n\t\t\t\t\t&& (boundless || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = boundless ? x : clamp(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(name) {\n\t\tif (name) {\n\t\t\tvar pool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasY ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('angle' in obj) {\n\t\t\t\tthis._set(obj.length || 0, 0);\n\t\t\t\tthis.setAngle(obj.angle || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis._set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(arguments);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\ttolerance = Base.read(arguments);\n\t\treturn this.getDistance(point) <= tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.x) && isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tisInQuadrant: function(q) {\n\t\treturn this.x * (q > 1 && q < 4 ? -1 : 1) >= 0\n\t\t\t&& this.y * (q > 2 ? -1 : 1) >= 0;\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar point1 = Point.read(arguments),\n\t\t\t\tpoint2 = Point.read(arguments);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\treturn this._setter === 'setPosition' ? 4 : 0;\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasHeight ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.width) && isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar type = typeof arg0,\n\t\t\tread;\n\t\tif (type === 'number') {\n\t\t\tthis._set(arg0, arg1, arg2, arg3);\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0, 0, 0);\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis._set.apply(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis._set(arg0.x || 0, arg0.y || 0,\n\t\t\t\t\t\targ0.width || 0, arg0.height || 0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis._set(0, 0, 0, 0);\n\t\t\t\tBase.filter(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t}\n\t\t}\n\t\tif (read === undefined) {\n\t\t\tvar frm = Point.readNamed(arguments, 'from'),\n\t\t\t\tnext = Base.peek(arguments),\n\t\t\t\tx = frm.x,\n\t\t\t\ty = frm.y,\n\t\t\t\twidth,\n\t\t\t\theight;\n\t\t\tif (next && next.x !== undefined\n\t\t\t\t\t|| Base.hasNamed(arguments, 'to')) {\n\t\t\t\tvar to = Point.readNamed(arguments, 'to');\n\t\t\t\twidth = to.x - x;\n\t\t\t\theight = to.y - y;\n\t\t\t\tif (width < 0) {\n\t\t\t\t\tx = to.x;\n\t\t\t\t\twidth = -width;\n\t\t\t\t}\n\t\t\t\tif (height < 0) {\n\t\t\t\t\ty = to.y;\n\t\t\t\t\theight = -height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\twidth = size.width;\n\t\t\t\theight = size.height;\n\t\t\t}\n\t\t\tthis._set(x, y, width, height);\n\t\t\tread = arguments.__index;\n\t\t\tvar filtered = arguments.__filtered;\n\t\t\tif (filtered)\n\t\t\t\tthis.__filtered = filtered;\n\t\t}\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\t_fw: 1,\n\t_fh: 1,\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tsx = this._sx,\n\t\t\tsy = this._sy,\n\t\t\tw = size.width,\n\t\t\th = size.height;\n\t\tif (sx) {\n\t\t\tthis.x += (this.width - w) * sx;\n\t\t}\n\t\tif (sy) {\n\t\t\tthis.y += (this.height - h) * sy;\n\t\t}\n\t\tthis.width = w;\n\t\tthis.height = h;\n\t\tthis._fw = this._fh = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = left - this.x;\n\t\t\tthis.width -= this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = left;\n\t\tthis._sx = this._fw = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = top - this.y;\n\t\t\tthis.height -= this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = top;\n\t\tthis._sy = this._fh = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = right - this.x;\n\t\t\tthis.width = this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = right - this.width;\n\t\tthis._sx = 1;\n\t\tthis._fw = 0;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = bottom - this.y;\n\t\t\tthis.height = this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = bottom - this.height;\n\t\tthis._sy = 1;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width / 2;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tif (this._fw || this._sx === 0.5) {\n\t\t\tthis.x = x - this.width / 2;\n\t\t} else {\n\t\t\tif (this._sx) {\n\t\t\t\tthis.x += (x - this.x) * 2 * this._sx;\n\t\t\t}\n\t\t\tthis.width = (x - this.x) * 2;\n\t\t}\n\t\tthis._sx = 0.5;\n\t\tthis._fw = 0;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height / 2;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tif (this._fh || this._sy === 0.5) {\n\t\t\tthis.y = y - this.height / 2;\n\t\t} else {\n\t\t\tif (this._sy) {\n\t\t\t\tthis.y += (y - this.y) * 2 * this._sy;\n\t\t\t}\n\t\t\tthis.height = (y - this.y) * 2;\n\t\t}\n\t\tthis._sy = 0.5;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length === 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tepsilon = Base.read(arguments) || 0;\n\t\treturn rect.x + rect.width > this.x - epsilon\n\t\t\t\t&& rect.y + rect.height > this.y - epsilon\n\t\t\t\t&& rect.x < this.x + this.width + epsilon\n\t\t\t\t&& rect.y < this.y + this.height + epsilon;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join(''),\n\t\t\txFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis._set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tinternal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn !!(this._owner._selection & 2);\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner._changeSelection) {\n\t\t\t\t\towner._changeSelection(2, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg, _dontNotify) {\n\t\tvar count = arguments.length,\n\t\t\tok = true;\n\t\tif (count >= 6) {\n\t\t\tthis._set.apply(this, arguments);\n\t\t} else if (count === 1 || count === 2) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,\n\t\t\t\t\t\t_dontNotify);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis._set.apply(this,\n\t\t\t\t\t\t_dontNotify ? arg.concat([_dontNotify]) : arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (!count) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok) {\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t}\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(a, b, c, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._b = b;\n\t\tthis._c = c;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.getValues(), options, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(9);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._c),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._b), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._b = this._c = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, true, Base.pick(recursively, true),\n\t\t\t\t\t_setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._c;\n\t\tthis._ty += x * this._b + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar scale = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._b *= scale.x;\n\t\tthis._c *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * c;\n\t\tthis._b = cos * b + sin * d;\n\t\tthis._c = -sin * a + cos * c;\n\t\tthis._d = -sin * b + cos * d;\n\t\tthis._tx += tx * a + ty * c;\n\t\tthis._ty += tx * b + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar shear = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tb = this._b;\n\t\tthis._a += shear.y * this._c;\n\t\tthis._b += shear.y * this._d;\n\t\tthis._c += shear.x * a;\n\t\tthis._d += shear.x * b;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar skew = Point.read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tappend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * c1;\n\t\t\tthis._c = b2 * a1 + d2 * c1;\n\t\t\tthis._b = a2 * b1 + c2 * d1;\n\t\t\tthis._d = b2 * b1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * c1;\n\t\t\tthis._ty += tx2 * b1 + ty2 * d1;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tprepend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * b1;\n\t\t\tthis._c = a2 * c1 + b2 * d1;\n\t\t\tthis._b = c2 * a1 + d2 * b1;\n\t\t\tthis._d = c2 * c1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tappended: function(mx) {\n\t\treturn this.clone().append(mx);\n\t},\n\n\tprepended: function(mx) {\n\t\treturn this.clone().prepend(mx);\n\t},\n\n\tinvert: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tthis._a = d / det;\n\t\t\tthis._b = -b / det;\n\t\t\tthis._c = -c / det;\n\t\t\tthis._d = a / det;\n\t\t\tthis._tx = (c * ty - d * tx) / det;\n\t\t\tthis._ty = (b * tx - a * ty) / det;\n\t\t\tres = this;\n\t\t}\n\t\treturn res;\n\t},\n\n\tinverted: function() {\n\t\treturn this.clone().invert();\n\t},\n\n\tconcatenate: '#append',\n\tpreConcatenate: '#prepend',\n\tchain: '#appended',\n\n\t_shiftless: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n\t},\n\n\t_orNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\tisInvertible: function() {\n\t\tvar det = this._a * this._d - this._c * this._b;\n\t\treturn det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n\t},\n\n\tisSingular: function() {\n\t\treturn !this.isInvertible();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest._set(\n\t\t\t\tx * this._a + y * this._c + this._tx,\n\t\t\t\tx * this._b + y * this._d + this._ty,\n\t\t\t\t_dontNotify);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tfor (var i = 0, max = 2 * count; i < max; i += 2) {\n\t\t\tvar x = src[i],\n\t\t\t\ty = src[i + 1];\n\t\t\tdst[i] = x * this._a + y * this._c + this._tx;\n\t\t\tdst[i + 1] = x * this._b + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j]) {\n\t\t\t\tmin[j] = val;\n\t\t\t} else if (val > max[j]) {\n\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\tres = dest._set(\n\t\t\t\t\t(x * d - y * c) / det,\n\t\t\t\t\t(y * a - x * b) / det,\n\t\t\t\t\t_dontNotify);\n\t\t}\n\t\treturn res;\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\tdet = a * d - b * c,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tatan2 = Math.atan2,\n\t\t\tdegrees = 180 / Math.PI,\n\t\t\trotate,\n\t\t\tscale,\n\t\t\tskew;\n\t\tif (a !== 0 || b !== 0) {\n\t\t\tvar r = sqrt(a * a + b * b);\n\t\t\trotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n\t\t\tscale = [r, det / r];\n\t\t\tskew = [atan2(a * c + b * d, r * r), 0];\n\t\t} else if (c !== 0 || d !== 0) {\n\t\t\tvar s = sqrt(c * c + d * d);\n\t\t\trotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);\n\t\t\tscale = [det / s, s];\n\t\t\tskew = [0, atan2(a * c + b * d, s * s)];\n\t\t} else {\n\t\t\trotate = 0;\n\t\t\tskew = scale = [0, 0];\n\t\t}\n\t\treturn {\n\t\t\ttranslation: this.getTranslation(),\n\t\t\trotation: rotate * degrees,\n\t\t\tscaling: new Point(scale),\n\t\t\tskewing: new Point(skew[0] * degrees, skew[1] * degrees)\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._b, this._c, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn (this.decompose() || {}).scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn (this.decompose() || {}).rotation;\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tif (!this.isIdentity()) {\n\t\t\tctx.transform(this._a, this._b, this._c, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t}\n\t}\n}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {\n\tvar part = Base.capitalize(key),\n\t\tprop = '_' + key;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(this.getSignedDistance(point));\n\t},\n\n\tgetSignedDistance: function(point) {\n\t\treturn Line.getSignedDistance(this._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true);\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (!isInfinite && Numerical.isZero(ccw)) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\treturn vx === 0 ? vy > 0 ? x - px : px - x\n\t\t\t\t : vy === 0 ? vx < 0 ? y - py : py - y\n\t\t\t\t : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);\n\t\t},\n\n\t\tgetDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\treturn Math.abs(\n\t\t\t\t\tLine.getSignedDistance(px, py, vx, vy, x, y, asVector));\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\t_compactSerialize: true,\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis._activeLayer = null;\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectionItems = {};\n\t\tthis._selectionCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this._children, options, true, dictionary);\n\t},\n\n\t_changed: function(flags, item) {\n\t\tif (flags & 1) {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview._needsUpdate = true;\n\t\t\t\tif (!view._requested && view._autoUpdate)\n\t\t\t\t\tview.requestUpdate();\n\t\t\t}\n\t\t}\n\t\tvar changes = this._changes;\n\t\tif (changes && item) {\n\t\t\tvar changesById = this._changesById,\n\t\t\t\tid = item._id,\n\t\t\t\tentry = changesById[id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tchanges.push(changesById[id] = { item: item, flags: flags });\n\t\t\t}\n\t\t}\n\t},\n\n\tclear: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--)\n\t\t\tchildren[i].remove();\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children.length;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.set(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetLayers: function() {\n\t\treturn this._children;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this, insert: true });\n\t},\n\n\tgetSymbolDefinitions: function() {\n\t\tvar definitions = [],\n\t\t\tids = {};\n\t\tthis.getItems({\n\t\t\tclass: SymbolItem,\n\t\t\tmatch: function(item) {\n\t\t\t\tvar definition = item._definition,\n\t\t\t\t\tid = definition._id;\n\t\t\t\tif (!ids[id]) {\n\t\t\t\t\tids[id] = true;\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn definitions;\n\t},\n\n\tgetSymbols: 'getSymbolDefinitions',\n\n\tgetSelectedItems: function() {\n\t\tvar selectionItems = this._selectionItems,\n\t\t\titems = [];\n\t\tfor (var id in selectionItems) {\n\t\t\tvar item = selectionItems[id],\n\t\t\t\tselection = item._selection;\n\t\t\tif ((selection & 1) && item.isInserted()) {\n\t\t\t\titems.push(item);\n\t\t\t} else if (!selection) {\n\t\t\t\tthis._updateSelection(item);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectionItems = this._selectionItems;\n\t\tif (item._selection) {\n\t\t\tif (selectionItems[id] !== item) {\n\t\t\t\tthis._selectionCount++;\n\t\t\t\tselectionItems[id] = item;\n\t\t\t}\n\t\t} else if (selectionItems[id] === item) {\n\t\t\tthis._selectionCount--;\n\t\t\tdelete selectionItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectionItems = this._selectionItems;\n\t\tfor (var i in selectionItems)\n\t\t\tselectionItems[i].setFullySelected(false);\n\t},\n\n\taddLayer: function(layer) {\n\t\treturn this.insertLayer(undefined, layer);\n\t},\n\n\tinsertLayer: function(index, layer) {\n\t\tif (layer instanceof Layer) {\n\t\t\tlayer._remove(false, true);\n\t\t\tBase.splice(this._children, [layer], index, 0);\n\t\t\tlayer._setProject(this, true);\n\t\t\tvar name = layer._name;\n\t\t\tif (name)\n\t\t\t\tlayer.setName(name);\n\t\t\tif (this._changes)\n\t\t\t\tlayer._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = layer;\n\t\t} else {\n\t\t\tlayer = null;\n\t\t}\n\t\treturn layer;\n\t},\n\n\t_insertItem: function(index, item, _created) {\n\t\titem = this.insertLayer(index, item)\n\t\t\t\t|| (this._activeLayer || this._insertItem(undefined,\n\t\t\t\t\t\tnew Layer(Item.NO_INSERT), true))\n\t\t\t\t\t\t.insertChild(index, item);\n\t\tif (_created && item.activate)\n\t\t\titem.activate();\n\t\treturn item;\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tremoveOn: function(type) {\n\t\tvar sets = this._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar children = this._children,\n\t\t\tparam = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].draw(ctx, param);\n\t\t}\n\t\tctx.restore();\n\n\t\tif (this._selectionCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectionItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items) {\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = Base.set({},\n\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_name: null,\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_canScaleStroke: false,\n\t_pivot: null,\n\t_visible: true,\n\t_blendMode: 'normal',\n\t_opacity: 1,\n\t_locked: false,\n\t_guide: false,\n\t_clipMask: false,\n\t_selection: 0,\n\t_selectBounds: true,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tlocked: false,\n\t\tguide: false,\n\t\tclipMask: false,\n\t\tselected: false,\n\t\tdata: {}\n\t},\n\t_prioritize: ['applyMatrix']\n},\nnew function() {\n\tvar handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];\n\treturn Base.each(handlers,\n\t\tfunction(name) {\n\t\t\tthis._events[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, 1);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, -1);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\t_events: {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tonLoad: {},\n\t\t\t\tonError: {}\n\t\t\t},\n\t\t\tstatics: {\n\t\t\t\t_itemHandlers: handlers\n\t\t\t}\n\t\t}\n\t);\n}, {\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project,\n\t\t\tsettings = paper.settings;\n\t\tthis._id = internal ? null : UID.get();\n\t\tthis._parent = this._index = null;\n\t\tthis._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (internal || hasProps && props.insert == false\n\t\t\t|| !settings.insertItems && !(hasProps && props.insert === true)) {\n\t\t\tthis._setProject(project);\n\t\t} else {\n\t\t\t(hasProps && props.parent || project)\n\t\t\t\t\t._insertItem(undefined, this, true);\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT) {\n\t\t\tthis.set(props, {\n\t\t\t\tinternal: true, insert: true, project: true, parent: true\n\t\t\t});\n\t\t}\n\t\treturn hasProps;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._symbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed =\n\t\t\t\t\tthis._globalMatrix = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 40)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project)\n\t\t\tproject._changed(flags, this);\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar owner = this._getOwner();\n\t\tif (name && owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tif (!(name in children))\n\t\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(128);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tkey = '_' + name,\n\t\t\tflags = {\n\t\t\t\tlocked: 128,\n\t\t\t\tvisible: 137\n\t\t\t};\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[key];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[key]) {\n\t\t\t\tthis[key] = value;\n\t\t\t\tthis._changed(flags[name] || 129);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tif (selection !== this._selection) {\n\t\t\tthis._selection = selection;\n\t\t\tvar project = this._project;\n\t\t\tif (project) {\n\t\t\t\tproject._updateSelection(this);\n\t\t\t\tthis._changed(129);\n\t\t\t}\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn !!(this._selection & 1);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisFullySelected: function() {\n\t\tvar children = this._children,\n\t\t\tselected = !!(this._selection & 1);\n\t\tif (children && selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(129);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(1024);\n\t\t}\n\t},\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar position = this._position,\n\t\t\tctor = _dontLink ? Point : LinkedPoint;\n\t\tif (!position) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tposition = this._position = pivot\n\t\t\t\t\t? this._matrix._transformPoint(pivot)\n\t\t\t\t\t: this.getBounds().getCenter(true);\n\t\t}\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\tgetPivot: function() {\n\t\tvar pivot = this._pivot;\n\t\treturn pivot\n\t\t\t\t? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')\n\t\t\t\t: null;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t}\n}, Base.each({\n\t\tgetStrokeBounds: { stroke: true },\n\t\tgetHandleBounds: { handle: true },\n\t\tgetInternalBounds: { internal: true }\n\t},\n\tfunction(options, key) {\n\t\tthis[key] = function(matrix) {\n\t\t\treturn this.getBounds(matrix, options);\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\tgetBounds: function(matrix, options) {\n\t\tvar hasMatrix = options || matrix instanceof Matrix,\n\t\t\topts = Base.set({}, hasMatrix ? options : matrix,\n\t\t\t\t\tthis._boundsOptions);\n\t\tif (!opts.stroke || this.getStrokeScaling())\n\t\t\topts.cacheItem = this;\n\t\tvar rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n\t\treturn !arguments.length\n\t\t\t\t? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,\n\t\t\t\t\tthis, 'setBounds')\n\t\t\t\t: rect;\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\t_matrix = this._matrix,\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tif (!_matrix.isInvertible()) {\n\t\t\t\t_matrix.set(_matrix._backup\n\t\t\t\t\t\t|| new Matrix().translate(_matrix.getTranslation()));\n\t\t\t\tbounds = this.getBounds();\n\t\t\t}\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width !== 0 ? rect.width / bounds.width : 0,\n\t\t\t\t\tbounds.height !== 0 ? rect.height / bounds.height : 0);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar children = this._children;\n\t\tif (!children || !children.length)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, options.cacheItem);\n\t\treturn Item._getBounds(children, matrix, options);\n\t},\n\n\t_getBoundsCacheKey: function(options, internal) {\n\t\treturn [\n\t\t\toptions.stroke ? 1 : 0,\n\t\t\toptions.handle ? 1 : 0,\n\t\t\tinternal ? 1 : 0\n\t\t].join('');\n\t},\n\n\t_getCachedBounds: function(matrix, options, noInternal) {\n\t\tmatrix = matrix && matrix._orNullIfIdentity();\n\t\tvar internal = options.internal && !noInternal,\n\t\t\tcacheItem = options.cacheItem,\n\t\t\t_matrix = internal ? null : this._matrix._orNullIfIdentity(),\n\t\t\tcacheKey = cacheItem && (!matrix || matrix.equals(_matrix))\n\t\t\t\t&& this._getBoundsCacheKey(options, internal),\n\t\t\tbounds = this._bounds;\n\t\tItem._updateBoundsCache(this._parent || this._symbol, cacheItem);\n\t\tif (cacheKey && bounds && cacheKey in bounds) {\n\t\t\tvar cached = bounds[cacheKey];\n\t\t\treturn {\n\t\t\t\trect: cached.rect.clone(),\n\t\t\t\tnonscaling: cached.nonscaling\n\t\t\t};\n\t\t}\n\t\tvar res = this._getBounds(matrix || _matrix, options),\n\t\t\trect = res.rect || res,\n\t\t\tstyle = this._style,\n\t\t\tnonscaling = res.nonscaling || style.hasStroke()\n\t\t\t\t&& !style.getStrokeScaling();\n\t\tif (cacheKey) {\n\t\t\tif (!bounds) {\n\t\t\t\tthis._bounds = bounds = {};\n\t\t\t}\n\t\t\tvar cached = bounds[cacheKey] = {\n\t\t\t\trect: rect.clone(),\n\t\t\t\tnonscaling: nonscaling,\n\t\t\t\tinternal: internal\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trect: rect,\n\t\t\tnonscaling: nonscaling\n\t\t};\n\t},\n\n\t_getStrokeMatrix: function(matrix, options) {\n\t\tvar parent = this.getStrokeScaling() ? null\n\t\t\t\t: options && options.internal ? this\n\t\t\t\t\t: this._parent || this._symbol && this._symbol._item,\n\t\t\tmx = parent ? parent.getViewMatrix().invert() : matrix;\n\t\treturn mx && mx._shiftless();\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent && item) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getBounds: function(items, matrix, options) {\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2,\n\t\t\t\tnonscaling = false;\n\t\t\toptions = options || {};\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._visible && !item.isEmpty()) {\n\t\t\t\t\tvar bounds = item._getCachedBounds(\n\t\t\t\t\t\tmatrix && matrix.appended(item._matrix), options, true),\n\t\t\t\t\t\trect = bounds.rect;\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t\tif (bounds.nonscaling)\n\t\t\t\t\t\tnonscaling = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\trect: isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle(),\n\t\t\t\tnonscaling: nonscaling\n\t\t\t};\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._applyMatrix\n\t\t\t? null\n\t\t\t: this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed ? decomposed.rotation : 0;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\ts = decomposed && decomposed.scaling;\n\t\treturn new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling && !current.equals(scaling)) {\n\t\t\tvar rotation = this.getRotation(),\n\t\t\t\tdecomposed = this._decomposed,\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tcenter = this.getPosition(true);\n\t\t\tmatrix.translate(center);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(rotation);\n\t\t\tmatrix.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\tif (rotation)\n\t\t\t\tmatrix.rotate(-rotation);\n\t\t\tmatrix.translate(center.negate());\n\t\t\tthis.transform(matrix);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix,\n\t\t\tupdateVersion = this._project._updateVersion;\n\t\tif (matrix && matrix._updateVersion !== updateVersion)\n\t\t\tmatrix = null;\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.prepend(parent.getGlobalMatrix(true));\n\t\t\tmatrix._updateVersion = updateVersion;\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetViewMatrix: function() {\n\t\treturn this.getGlobalMatrix().prepend(this.getView()._matrix);\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\t_getOwner: '#getParent',\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(options) {\n\t\tvar copy = new this.constructor(Item.NO_INSERT),\n\t\t\tchildren = this._children,\n\t\t\tinsert = Base.pick(options ? options.insert : undefined,\n\t\t\t\t\toptions === undefined || options === true),\n\t\t\tdeep = Base.pick(options ? options.deep : undefined, true);\n\t\tif (children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (!children || deep)\n\t\t\tcopy.copyContent(this);\n\t\tif (!children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (insert)\n\t\t\tcopy.insertAbove(this);\n\t\tvar name = this._name,\n\t\t\tparent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\tif (name !== orig)\n\t\t\t\tcopy.setName(name);\n\t\t}\n\t\treturn copy;\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar children = source._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tthis.addChild(children[i].clone(false), true);\n\t\t}\n\t},\n\n\tcopyAttributes: function(source, excludeMatrix) {\n\t\tthis.setStyle(source._style);\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (source.hasOwnProperty(key))\n\t\t\t\tthis[key] = source[key];\n\t\t}\n\t\tif (!excludeMatrix)\n\t\t\tthis._matrix.set(source._matrix, true);\n\t\tthis.setApplyMatrix(source._applyMatrix);\n\t\tthis.setPivot(source._pivot);\n\t\tthis.setSelection(source._selection);\n\t\tvar data = source._data,\n\t\t\tname = source._name;\n\t\tthis._data = data ? Base.clone(data) : null;\n\t\tif (name)\n\t\t\tthis.setName(name);\n\t},\n\n\trasterize: function(resolution, insert) {\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tsize = new Size(bottomRight.subtract(topLeft)),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\tif (!size.isZero()) {\n\t\t\tvar canvas = CanvasProvider.getCanvas(size.multiply(scale)),\n\t\t\t\tctx = canvas.getContext('2d'),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t\traster.setCanvas(canvas);\n\t\t}\n\t\traster.transform(new Matrix().translate(topLeft.add(size.divide(2)))\n\t\t\t\t.scale(1 / scale));\n\t\tif (insert === undefined || insert)\n\t\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\treturn !!this._contains(\n\t\t\t\tthis._matrix._inverseTransform(Point.read(arguments)));\n\t},\n\n\t_contains: function(point) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tif (children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix, true).length > 0;\n\t}\n},\nnew function() {\n\tfunction hitTest() {\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(arguments),\n\t\t\t\tHitResult.getOptions(arguments));\n\t}\n\n\tfunction hitTestAll() {\n\t\tvar point = Point.read(arguments),\n\t\t\toptions = HitResult.getOptions(arguments),\n\t\t\tall = [];\n\t\tthis._hitTest(point, Base.set({ all: all }, options));\n\t\treturn all;\n\t}\n\n\tfunction hitTestChildren(point, options, viewMatrix, _exclude) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar res = child !== _exclude && child._hitTest(point, options,\n\t\t\t\t\t\tviewMatrix);\n\t\t\t\tif (res && !options.all)\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tProject.inject({\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTest: hitTestChildren\n\t});\n\n\treturn {\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTestChildren: hitTestChildren,\n\t};\n}, {\n\n\t_hitTest: function(point, options, parentViewMatrix) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar matrix = this._matrix,\n\t\t\tviewMatrix = parentViewMatrix\n\t\t\t\t\t? parentViewMatrix.appended(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().prepend(this.getView()._matrix),\n\t\t\ttolerance = Math.max(options.tolerance, 1e-12),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\tPath._getStrokePadding(tolerance,\n\t\t\t\t\t\tmatrix._shiftless().invert()));\n\t\tpoint = matrix._inverseTransform(point);\n\t\tif (!point || !this._children &&\n\t\t\t!this.getBounds({ internal: true, stroke: true, handle: true })\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this.isSelected()\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tmatch = options.match,\n\t\t\tthat = this,\n\t\t\tbounds,\n\t\t\tres;\n\n\t\tfunction filter(hit) {\n\t\t\tif (hit && match && !match(hit))\n\t\t\t\thit = null;\n\t\t\tif (hit && options.all)\n\t\t\t\toptions.all.push(hit);\n\t\t\treturn hit;\n\t\t}\n\n\t\tfunction checkPoint(type, part) {\n\t\t\tvar pt = part ? bounds['get' + part]() : that.getPosition();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1) {\n\t\t\t\treturn new HitResult(type, that, {\n\t\t\t\t\tname: part ? Base.hyphenate(part) : type,\n\t\t\t\t\tpoint: pt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar checkPosition = options.position,\n\t\t\tcheckCenter = options.center,\n\t\t\tcheckBounds = options.bounds;\n\t\tif (checkSelf && this._parent\n\t\t\t\t&& (checkPosition || checkCenter || checkBounds)) {\n\t\t\tif (checkCenter || checkBounds) {\n\t\t\t\tbounds = this.getInternalBounds();\n\t\t\t}\n\t\t\tres = checkPosition && checkPoint('position') ||\n\t\t\t\t\tcheckCenter && checkPoint('center', 'Center');\n\t\t\tif (!res && checkBounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++) {\n\t\t\t\t\tres = checkPoint('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = filter(res);\n\t\t}\n\n\t\tif (!res) {\n\t\t\tres = this._hitTestChildren(point, options, viewMatrix)\n\t\t\t\t|| checkSelf\n\t\t\t\t\t&& filter(this._hitTestSelf(point, options, viewMatrix,\n\t\t\t\t\t\tthis.getStrokeScaling() ? null\n\t\t\t\t\t\t\t: viewMatrix._shiftless().invert()))\n\t\t\t\t|| null;\n\t\t}\n\t\tif (res && res.point) {\n\t\t\tres.point = matrix.transform(res.point);\n\t\t}\n\t\treturn res;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else if (name === 'match') {\n\t\t\treturn compare(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (name === 'class') {\n\t\t\t\tif (typeof compare === 'function')\n\t\t\t\t\treturn this instanceof compare;\n\t\t\t\tvalue = this._class;\n\t\t\t}\n\t\t\tif (typeof compare === 'function') {\n\t\t\t\treturn !!compare(value);\n\t\t\t} else if (compare) {\n\t\t\t\tif (compare.test) {\n\t\t\t\t\treturn compare.test(value);\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\treturn matchObject(compare, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Base.equals(value, compare);\n\t\t}\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix, null, true)[0]\n\t\t\t\t|| null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(item, options, matrix, param, firstOnly) {\n\t\t\tif (!param) {\n\t\t\t\tvar obj = typeof options === 'object' && options,\n\t\t\t\t\toverlapping = obj && obj.overlapping,\n\t\t\t\t\tinside = obj && obj.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\trecursive: obj && obj.recursive !== false,\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (obj) {\n\t\t\t\t\toptions = Base.filter({}, options, {\n\t\t\t\t\t\trecursive: true, inside: true, overlapping: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = item._children,\n\t\t\t\titems = param.items,\n\t\t\t\trect = param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.appended(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(rect.contains(bounds)\n\t\t\t\t\t\t\t|| param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(options)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (param.recursive !== false) {\n\t\t\t\t\t_getItems(child, options, childMatrix, param, firstOnly);\n\t\t\t\t}\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this ? this.addChild(res) : res;\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tvar res = item ? this.insertChildren(index, [item]) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items) {\n\t\treturn this.insertChildren(this._children.length, items);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Base.slice(items);\n\t\t\tvar inserted = {};\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tid = item && item._id;\n\t\t\t\tif (!item || inserted[id]) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\titem._remove(false, true);\n\t\t\t\t\tinserted[id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tname = item._name;\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(project, true);\n\t\t\t\tif (name)\n\t\t\t\t\titem.setName(name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\titem._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertItem: '#insertChild',\n\n\t_insertAt: function(item, offset) {\n\t\tvar owner = item && item._getOwner(),\n\t\t\tres = item !== this && owner ? this : null;\n\t\tif (res) {\n\t\t\tres._remove(false, true);\n\t\t\towner._insertItem(item._index + offset, res);\n\t\t}\n\t\treturn res;\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn this._insertAt(item, 1);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn this._insertAt(item, 0);\n\t},\n\n\tsendToBack: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(0, this) : null;\n\t},\n\n\tbringToFront: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(undefined, this) : null;\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\taddTo: function(owner) {\n\t\treturn owner._insertItem(undefined, this);\n\t},\n\n\tcopyTo: function(owner) {\n\t\treturn this.clone(false).addTo(owner);\n\t},\n\n\treduce: function(options) {\n\t\tvar children = this._children;\n\t\tif (children && children.length === 1) {\n\t\t\tvar child = children[0].reduce(options);\n\t\t\tif (this._parent) {\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tthis.remove();\n\t\t\t} else {\n\t\t\t\tchild.remove();\n\t\t\t}\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar owner = this._getOwner();\n\t\tif (owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[0];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar owner = this._getOwner(),\n\t\t\tproject = this._project,\n\t\t\tindex = this._index;\n\t\tif (owner) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (index != null) {\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(owner._children, null, index, 1);\n\t\t\t}\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent)\n\t\t\t\towner._changed(11, this);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(start, end) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, start, end - start);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function() {\n\t\tvar children = this._children;\n\t\treturn !children || !children.length;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent === item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\ttransform: function(matrix, _applyMatrix, _applyRecursively,\n\t\t\t_setApplyMatrix) {\n\t\tvar _matrix = this._matrix,\n\t\t\ttransform = matrix && !matrix.isIdentity(),\n\t\t\tapplyMatrix = (_applyMatrix || this._applyMatrix)\n\t\t\t\t\t&& ((!_matrix.isIdentity() || transform)\n\t\t\t\t\t\t|| _applyMatrix && _applyRecursively && this._children);\n\t\tif (!transform && !applyMatrix)\n\t\t\treturn this;\n\t\tif (transform) {\n\t\t\tif (!matrix.isInvertible() && _matrix.isInvertible())\n\t\t\t\t_matrix._backup = _matrix.getValues();\n\t\t\t_matrix.prepend(matrix, true);\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\t\tif (applyMatrix && (applyMatrix = this._transformContent(_matrix,\n\t\t\t\t_applyRecursively, _setApplyMatrix))) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tif (transform || applyMatrix) {\n\t\t\tthis._changed(9);\n\t\t}\n\t\tvar decomp = transform && bounds && matrix.decompose();\n\t\tif (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar cache = bounds[key];\n\t\t\t\tif (cache.nonscaling) {\n\t\t\t\t\tdelete bounds[key];\n\t\t\t\t} else if (applyMatrix || !cache.internal) {\n\t\t\t\t\tvar rect = cache.rect;\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bounds = bounds;\n\t\t\tvar cached = bounds[this._getBoundsCacheKey(\n\t\t\t\t\tthis._boundsOptions || {})];\n\t\t\tif (cached) {\n\t\t\t\tthis._position = cached.rect.getCenter(true);\n\t\t\t}\n\t\t} else if (transform && position && this._pivot) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].transform(matrix, true, applyRecursively,\n\t\t\t\t\t\tsetApplyMatrix);\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t}\n}), {\n\n\t_setStyles: function(ctx, param, viewMatrix) {\n\t\tvar style = this._style,\n\t\t\tmatrix = this._matrix;\n\t\tif (style.hasFill()) {\n\t\t\tctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n\t\t}\n\t\tif (style.hasStroke()) {\n\t\t\tctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n\t\t\tctx.lineWidth = style.getStrokeWidth();\n\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\tif (strokeJoin)\n\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\tif (strokeCap)\n\t\t\t\tctx.lineCap = strokeCap;\n\t\t\tif (miterLimit)\n\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\tif (paper.support.nativeDash) {\n\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (style.hasShadow()) {\n\t\t\tvar pixelRatio = param.pixelRatio || 1,\n\t\t\t\tmx = viewMatrix._shiftless().prepend(\n\t\t\t\t\tnew Matrix().scale(pixelRatio, pixelRatio)),\n\t\t\t\tblur = mx.transform(new Point(style.getShadowBlur(), 0)),\n\t\t\t\toffset = mx.transform(this.getShadowOffset());\n\t\t\tctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n\t\t\tctx.shadowBlur = blur.getLength();\n\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\tctx.shadowOffsetY = offset.y;\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].appended(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tviewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)\n\t\t\t\t: globalMatrix;\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tglobalMatrix._updateVersion = updateVersion;\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = this._opacity,\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(viewMatrix);\n\t\t\tif (!bounds.width || !bounds.height)\n\t\t\t\treturn;\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.appended(matrix)\n\t\t\t\t: this._canScaleStroke && !this.getStrokeScaling(true)\n\t\t\t\t\t&& viewMatrix,\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform) {\n\t\t\t(direct ? matrix : viewMatrix).applyToContext(ctx);\n\t\t}\n\t\tif (clip) {\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, viewMatrix, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish)\n\t\t\tctx.clip();\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n\t\tvar selection = this._selection,\n\t\t\titemSelected = selection & 1,\n\t\t\tboundsSelected = selection & 2\n\t\t\t\t\t|| itemSelected && this._selectBounds,\n\t\t\tpositionSelected = selection & 4;\n\t\tif (!this._drawSelected)\n\t\t\titemSelected = false;\n\t\tif ((itemSelected || boundsSelected || positionSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar layer,\n\t\t\t\tcolor = this.getSelectedColor(true) || (layer = this.getLayer())\n\t\t\t\t\t&& layer.getSelectedColor(true),\n\t\t\t\tmx = matrix.appended(this.getGlobalMatrix(true)),\n\t\t\t\thalf = size / 2;\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (itemSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectionItems);\n\t\t\tif (positionSelected) {\n\t\t\t\tvar point = this.getPosition(true),\n\t\t\t\t\tx = point.x,\n\t\t\t\t\ty = point.y;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.stroke();\n\t\t\t\tvar deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],\n\t\t\t\t\tstart = half,\n\t\t\t\t\tend = size + 1;\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar delta = deltas[i],\n\t\t\t\t\t\tdx = delta[0],\n\t\t\t\t\t\tdy = delta[1];\n\t\t\t\t\tctx.moveTo(x + dx * start, y + dy * start);\n\t\t\t\t\tctx.lineTo(x + dx * end, y + dy * end);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (boundsSelected) {\n\t\t\t\tvar coords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(key) {\n\tthis['removeOn' + Base.capitalize(key)] = function() {\n\t\tvar hash = {};\n\t\thash[key] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}));\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectBounds: false,\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 1026) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i]._clipMask) {\n\t\t\t\t\tclipItem = children[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_getBounds: function _getBounds(matrix, options) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn clipItem\n\t\t\t? clipItem._getCachedBounds(\n\t\t\t\tmatrix && matrix.appended(clipItem._matrix),\n\t\t\t\tBase.set({}, options, { stroke: false }))\n\t\t\t: _getBounds.base.call(this, matrix, options);\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn (!clipItem || clipItem.contains(point))\n\t\t\t\t&& _hitTestChildren.base.call(this, point, options, viewMatrix,\n\t\t\t\t\tclipItem);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem();\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tctx.beginPath();\n\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar item = children[i];\n\t\t\tif (item !== clipItem)\n\t\t\t\titem.draw(ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer() {\n\t\tGroup.apply(this, arguments);\n\t},\n\n\t_getOwner: function() {\n\t\treturn this._parent || this._index != null && this._project;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_hitTestSelf: function() {\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_canScaleStroke: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props, point) {\n\t\tthis._initialize(props, point);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setType(source._type);\n\t\tthis.setSize(source._size);\n\t\tthis.setRadius(source._radius);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tthis._radius.set(Size.min(this._radius, size.divide(2)));\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius._set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size._set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size._set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size._set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t});\n\t\tpath.copyAttributes(this);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\tif (insert === undefined || insert)\n\t\t\tpath.insertAbove(this);\n\t\treturn path;\n\t},\n\n\ttoShape: '#clone',\n\n\t_asPathItem: function() {\n\t\treturn this.toPath(false);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\tstyle = this._style,\n\t\t\tstrokeWidth = options.stroke && style.hasStroke()\n\t\t\t\t\t&& style.getStrokeWidth();\n\t\tif (matrix)\n\t\t\trect = matrix._transformBounds(rect);\n\t\treturn strokeWidth\n\t\t\t\t? rect.expand(Path._getStrokePadding(strokeWidth,\n\t\t\t\t\tthis._getStrokeMatrix(matrix, options)))\n\t\t\t\t: rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var q = 1; q <= 4; q++) {\n\t\t\t\tvar dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(\n\t\t\t\t\t\t\texpand ? corner.add(dir.multiply(expand)) : corner,\n\t\t\t\t\t\t\tcenter);\n\t\t\t\tif (rect.contains(point))\n\t\t\t\t\treturn { point: center, quadrant: q };\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isOnEllipseStroke(point, radius, padding, quadrant) {\n\t\tvar vector = point.divide(radius);\n\t\treturn (!quadrant || vector.isInQuadrant(quadrant)) &&\n\t\t\t\tvector.subtract(vector.normalize()).multiply(radius)\n\t\t\t\t\t.divide(padding).length <= 1;\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center.point).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,\n\t\t\t\tstrokeMatrix) {\n\t\t\tvar hit = false,\n\t\t\t\tstyle = this._style,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill();\n\t\t\tif (hitStroke || hitFill) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\t\tstrokePadding = options._tolerancePadding.add(\n\t\t\t\t\t\tPath._getStrokePadding(strokeRadius,\n\t\t\t\t\t\t\t!style.getStrokeScaling() && strokeMatrix));\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar padding = strokePadding.multiply(2),\n\t\t\t\t\t\tcenter = getCornerCenter(this, point, padding);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\thit = isOnEllipseStroke(point.subtract(center.point),\n\t\t\t\t\t\t\t\tradius, strokePadding, center.quadrant);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(padding),\n\t\t\t\t\t\t\tinner = rect.expand(padding.negate());\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thit = isOnEllipseStroke(point, radius, strokePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = new Shape(Base.getNamed(args), point);\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\treturn item;\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targuments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(arguments, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, arguments);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, arguments);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: false, handle: false },\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\t_prioritize: ['crossOrigin'],\n\n\tinitialize: function Raster(object, position) {\n\t\tif (!this._initialize(object,\n\t\t\t\tposition !== undefined && Point.read(arguments, 1))) {\n\t\t\tvar image = typeof object === 'string'\n\t\t\t\t\t? document.getElementById(object) : object;\n\t\t\tif (image) {\n\t\t\t\tthis.setImage(image);\n\t\t\t} else {\n\t\t\t\tthis.setSource(object);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar image = source._image,\n\t\t\tcanvas = source._canvas;\n\t\tif (image) {\n\t\t\tthis._setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(source._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tthis._setImage(copyCanvas);\n\t\t}\n\t\tthis._crossOrigin = source._crossOrigin;\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = this.getElement();\n\t\t\t\tthis._setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element)\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tgetLoaded: function() {\n\t\treturn this._loaded;\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tvar that = this;\n\n\t\tfunction emit(event) {\n\t\t\tvar view = that.getView(),\n\t\t\t\ttype = event && event.type || 'load';\n\t\t\tif (view && that.responds(type)) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.emit(type, new Event(event));\n\t\t\t}\n\t\t}\n\n\t\tthis._setImage(image);\n\t\tif (this._loaded) {\n\t\t\tsetTimeout(emit, 0);\n\t\t} else if (image) {\n\t\t\tDomEvent.add(image, {\n\t\t\t\tload: function(event) {\n\t\t\t\t\tthat._setImage(image);\n\t\t\t\t\temit(event);\n\t\t\t\t},\n\t\t\t\terror: emit\n\t\t\t});\n\t\t}\n\t},\n\n\t_setImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = !!(image && image.src && image.complete);\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(521);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(modify) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (modify) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(513);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar image = new self.Image(),\n\t\t\tcrossOrigin = this._crossOrigin;\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\timage.src = src;\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tvar image = this._image;\n\t\tif (image)\n\t\t\timage.crossOrigin = crossOrigin;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster._setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.prepend(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar image = this._image,\n\t\t\tsrc = image && image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (typeof object === 'object') {\n\t\t\tif ('width' in object) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if ('x' in object) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t}\n\t\tif (!bounds)\n\t\t\treturn null;\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcolor = Color.read(arguments),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tsetImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx) {\n\t\tvar element = this.getElement();\n\t\tif (element) {\n\t\t\tctx.globalAlpha = this._opacity;\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar SymbolItem = Item.extend({\n\t_class: 'SymbolItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: true },\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function SymbolItem(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setDefinition(arg0 instanceof SymbolDefinition ?\n\t\t\t\t\targ0 : new SymbolDefinition(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._definition === item._definition;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setDefinition(source._definition);\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(definition) {\n\t\tthis._definition = definition;\n\t\tthis._changed(9);\n\t},\n\n\tgetSymbol: '#getDefinition',\n\tsetSymbol: '#setDefinition',\n\n\tisEmpty: function() {\n\t\treturn this._definition._item.isEmpty();\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar item = this._definition._item;\n\t\treturn item._getCachedBounds(item._matrix.prepended(matrix), options);\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix) {\n\t\tvar res = this._definition._item._hitTest(point, options, viewMatrix);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis._definition._item.draw(ctx, param);\n\t}\n\n});\n\nvar SymbolDefinition = Base.extend({\n\t_class: 'SymbolDefinition',\n\n\tinitialize: function SymbolDefinition(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tif (item)\n\t\t\tthis.setItem(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._item],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8)\n\t\t\tItem._clearBoundsCache(this);\n\t\tif (flags & 1)\n\t\t\tthis.project._changed(flags);\n\t},\n\n\tgetItem: function() {\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item, _dontCenter) {\n\t\tif (item._symbol)\n\t\t\titem = item.clone();\n\t\tif (this._item)\n\t\t\tthis._item._symbol = null;\n\t\tthis._item = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._symbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tgetDefinition: '#getItem',\n\tsetDefinition: '#setItem',\n\n\tplace: function(position) {\n\t\treturn new SymbolItem(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new SymbolDefinition(this._item.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this._item.equals(symbol._item)\n\t\t\t\t|| false;\n\t}\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values)\n\t\t\tthis.inject(values);\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(args) {\n\t\t\tvar options = args && Base.read(args);\n\t\t\treturn Base.set({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tposition: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\t_selection: 0,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut, selection;\n\t\tif (count > 0) {\n\t\t\tif (arg0 == null || typeof arg0 === 'object') {\n\t\t\t\tif (count === 1 && arg0 && 'point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t\tselection = arg0.selection;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t\thandleIn = arg1;\n\t\t\t\t\thandleOut = arg2;\n\t\t\t\t\tselection = arg3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\tif (selection)\n\t\t\tthis.setSelection(selection);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar point = this._point,\n\t\t\tselection = this._selection,\n\t\t\tobj = selection || this.hasHandles()\n\t\t\t\t\t? [point, this._handleIn, this._handleOut]\n\t\t\t\t\t: point;\n\t\tif (selection)\n\t\t\tobj.push(selection);\n\t\treturn Base.serialize(obj, options, true, dictionary);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(25);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tthis._point.set(Point.read(arguments));\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tthis._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tthis._handleOut.set(Point.read(arguments));\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tisSmooth: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut;\n\t\treturn !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t&& handleIn.isCollinear(handleOut);\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn._set(0, 0);\n\t\tthis._handleOut._set(0, 0);\n\t},\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tvar oldSelection = this._selection,\n\t\t\tpath = this._path;\n\t\tthis._selection = selection = selection || 0;\n\t\tif (path && selection !== oldSelection) {\n\t\t\tpath._updateSelection(this, oldSelection, selection);\n\t\t\tpath._changed(129);\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._selection & 7);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._changeSelection(7, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tsmooth: function(options, _first, _last) {\n\t\tvar opts = options || {},\n\t\t\ttype = opts.type,\n\t\t\tfactor = opts.factor,\n\t\t\tprev = this.getPrevious(),\n\t\t\tnext = this.getNext(),\n\t\t\tp0 = (prev || this)._point,\n\t\t\tp1 = this._point,\n\t\t\tp2 = (next || this)._point,\n\t\t\td1 = p0.getDistance(p1),\n\t\t\td2 = p1.getDistance(p2);\n\t\tif (!type || type === 'catmull-rom') {\n\t\t\tvar a = factor === undefined ? 0.5 : factor,\n\t\t\t\td1_a = Math.pow(d1, a),\n\t\t\t\td1_2a = d1_a * d1_a,\n\t\t\t\td2_a = Math.pow(d2, a),\n\t\t\t\td2_2a = d2_a * d2_a;\n\t\t\tif (!_first && prev) {\n\t\t\t\tvar A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,\n\t\t\t\t\tN = 3 * d2_a * (d2_a + d1_a);\n\t\t\t\tthis.setHandleIn(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,\n\t\t\t\t\t\t(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t\tif (!_last && next) {\n\t\t\t\tvar A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,\n\t\t\t\t\tN = 3 * d1_a * (d1_a + d2_a);\n\t\t\t\tthis.setHandleOut(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,\n\t\t\t\t\t\t(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t} else if (type === 'geometric') {\n\t\t\tif (prev && next) {\n\t\t\t\tvar vector = p0.subtract(p2),\n\t\t\t\t\tt = factor === undefined ? 0.4 : factor,\n\t\t\t\t\tk = t * d1 / (d1 + d2);\n\t\t\t\tif (!_first)\n\t\t\t\t\tthis.setHandleIn(vector.multiply(k));\n\t\t\t\tif (!_last)\n\t\t\t\t\tthis.setHandleOut(vector.multiply(k - t));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Smoothing method \\'' + type + '\\' not supported.');\n\t\t}\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\ttmp = handleIn.clone();\n\t\thandleIn.set(handleOut);\n\t\thandleOut.set(tmp);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar u = 1 - factor,\n\t\t\tv = factor,\n\t\t\tpoint1 = from._point,\n\t\t\tpoint2 = to._point,\n\t\t\thandleIn1 = from._handleIn,\n\t\t\thandleIn2 = to._handleIn,\n\t\t\thandleOut2 = to._handleOut,\n\t\t\thandleOut1 = from._handleOut;\n\t\tthis._point._set(\n\t\t\t\tu * point1._x + v * point2._x,\n\t\t\t\tu * point1._y + v * point2._y, true);\n\t\tthis._handleIn._set(\n\t\t\t\tu * handleIn1._x + v * handleIn2._x,\n\t\t\t\tu * handleIn1._y + v * handleIn2._y, true);\n\t\tthis._handleOut._set(\n\t\t\t\tu * handleOut1._x + v * handleOut2._x,\n\t\t\t\tu * handleOut1._y + v * handleOut2._y, true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y,\n\t\t\tselected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\t_set: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this._x) && isZero(this._y);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\tvar owner = this._owner;\n\t\treturn this === owner._point ? 1\n\t\t\t: this === owner._handleIn ? 2\n\t\t\t: this === owner._handleOut ? 4\n\t\t\t: 0;\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\tbeans: true,\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (!count) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tclassify: function() {\n\t\treturn Curve.classify(this.getValues());\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tthis._segment1._point.set(Point.read(arguments));\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tthis._segment2._point.set(Point.read(arguments));\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tthis._segment1._handleOut.set(Point.read(arguments));\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tthis._segment2._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._segment1._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t}\n}, {\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tdivideAt: function(location) {\n\t\treturn this.divideAtTime(location && location.curve === this\n\t\t\t\t? location.time : this.getTimeAt(location));\n\t},\n\n\tdivideAtTime: function(time, _setHandles) {\n\t\tvar tMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (time >= tMin && time <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), time),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tseg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tseg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n\t\t\t\tseg2._handleIn._set(right[4] - right[6],right[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(seg1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tthis._changed();\n\t\t\t\tres = new Curve(segment, seg2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar path = this._path;\n\t\treturn path ? path.splitAt(location) : null;\n\t},\n\n\tsplitAtTime: function(time) {\n\t\treturn this.splitAt(this.getLocationAtTime(time));\n\t},\n\n\tdivide: function(offset, isTime) {\n\t\treturn this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\tsplit: function(offset, isTime) {\n\t\treturn this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut._set(0, 0);\n\t\tthis._segment2._handleIn._set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix, straight) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tx1 = p1.x, y1 = p1.y,\n\t\t\tx2 = p2.x, y2 = p2.y,\n\t\t\tvalues = straight\n\t\t\t\t? [ x1, y1, x1, y1, x2, y2, x2, y2 ]\n\t\t\t\t: [\n\t\t\t\t\tx1, y1,\n\t\t\t\t\tx1 + h1._x, y1 + h1._y,\n\t\t\t\t\tx2 + h2._x, y2 + h2._y,\n\t\t\t\t\tx2, y2\n\t\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tx4 = u * x0 + t * x1, y4 = u * y0 + t * y1,\n\t\t\tx5 = u * x1 + t * x2, y5 = u * y1 + t * y2,\n\t\t\tx6 = u * x2 + t * x3, y6 = u * y2 + t * y3,\n\t\t\tx7 = u * x4 + t * x5, y7 = u * y4 + t * y5,\n\t\t\tx8 = u * x5 + t * x6, y8 = u * y5 + t * y6,\n\t\t\tx9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n\t\treturn [\n\t\t\t[x0, y0, x4, y4, x7, y7, x9, y9],\n\t\t\t[x9, y9, x8, y8, x6, y6, x3, y3]\n\t\t];\n\t},\n\n\tgetMonoCurves: function(v, dir) {\n\t\tvar curves = [],\n\t\t\tio = dir ? 0 : 1,\n\t\t\to0 = v[io + 0],\n\t\t\to1 = v[io + 2],\n\t\t\to2 = v[io + 4],\n\t\t\to3 = v[io + 6];\n\t\tif ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)\n\t\t\t\t|| Curve.isStraight(v)) {\n\t\t\tcurves.push(v);\n\t\t} else {\n\t\t\tvar a = 3 * (o1 - o2) - o0 + o3,\n\t\t\t\tb = 2 * (o0 + o2) - 4 * o1,\n\t\t\t\tc = o1 - o0,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [],\n\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\tif (!n) {\n\t\t\t\tcurves.push(v);\n\t\t\t} else {\n\t\t\t\troots.sort();\n\t\t\t\tvar t = roots[0],\n\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\tcurves.push(parts[0]);\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\tcurves.push(parts[0]);\n\t\t\t\t}\n\t\t\t\tcurves.push(parts[1]);\n\t\t\t}\n\t\t}\n\t\treturn curves;\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar v0 = v[coord],\n\t\t\tv1 = v[coord + 2],\n\t\t\tv2 = v[coord + 4],\n\t\t\tv3 = v[coord + 6],\n\t\t\tres = 0;\n\t\tif (  !(v0 < val && v3 < val && v1 < val && v2 < val ||\n\t\t\t\tv0 > val && v3 > val && v1 > val && v2 > val)) {\n\t\t\tvar c = 3 * (v1 - v0),\n\t\t\t\tb = 3 * (v2 - v1) - c,\n\t\t\t\ta = v3 - v0 - c - b;\n\t\t\tres = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n\t\t}\n\t\treturn res;\n\t},\n\n\tgetTimeOf: function(v, point) {\n\t\tvar p0 = new Point(v[0], v[1]),\n\t\t\tp3 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tt = point.isClose(p0, epsilon) ? 0\n\t\t\t  : point.isClose(p3, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t === null) {\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [];\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar u = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, u), geomEpsilon))\n\t\t\t\t\t\treturn u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p0, geomEpsilon) ? 0\n\t\t\t : point.isClose(p3, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestTime: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tvx = x3 - x0, vy = y3 - y0,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getTimeOf(v,\n\t\t\t\t\tnew Point(x0 + u * vx, y0 + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 1e-8) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\tisFlatEnough: function(v, flatness) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tux = 3 * x1 - 2 * x0 - x3,\n\t\t\tuy = 3 * y1 - 2 * y0 - y3,\n\t\t\tvx = 3 * x2 - 2 * x3 - x0,\n\t\t\tvy = 3 * y2 - 2 * y3 - y0;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t<= 16 * flatness * flatness;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)\n\t\t\t\t+ y1 * (x0 - x2) - x1 * (y0 - y2)\n\t\t\t\t+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\n\t\tpadding /= 2;\n\t\tvar minPad = min[coord] - padding,\n\t\t\tmaxPad = max[coord] + padding;\n\t\tif (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||\n\t\t\t\tv0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n\t\t\tif (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n\t\t\t\tadd(v0, padding);\n\t\t\t\tadd(v3, padding);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0,\n\t\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\t\ttMin = 1e-8,\n\t\t\t\t\ttMax = 1 - tMin;\n\t\t\t\tadd(v3, 0);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar t = roots[i],\n\t\t\t\t\t\tu = 1 - t;\n\t\t\t\t\tif (tMin <= t && t <= tMax)\n\t\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\t\tpadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false, this._path);\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(p1, h1, h2, p2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar v = p2.subtract(p1);\n\t\t\tif (v.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n\t\t\t\tvar l = new Line(p1, p2),\n\t\t\t\t\tepsilon = 1e-7;\n\t\t\t\tif (l.getDistance(p1.add(h1)) < epsilon &&\n\t\t\t\t\tl.getDistance(p2.add(h2)) < epsilon) {\n\t\t\t\t\tvar div = v.dot(v),\n\t\t\t\t\t\ts1 = v.dot(h1) / div,\n\t\t\t\t\t\ts2 = v.dot(h2) / div;\n\t\t\t\t\treturn s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(p1, h1, h2, p2) {\n\t\tvar third = p2.subtract(p1).divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function(epsilon) {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,\n\t\t\t\tepsilon);\n\t};\n\n\tthis.statics[name] = function(v, epsilon) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn test(\n\t\t\t\tnew Point(x0, y0),\n\t\t\t\tnew Point(v[2] - x0, v[3] - y0),\n\t\t\t\tnew Point(v[4] - x3, v[5] - y3),\n\t\t\t\tnew Point(x3, y3), epsilon);\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\thasLength: function(epsilon) {\n\t\treturn (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())\n\t\t\t\t&& this.getLength() > (epsilon || 0);\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)\n\t\t\t\t< 1e-8;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)\n\t\t\t\t< 1e-8;\n\t}\n}), {\n\tbeans: false,\n\n\tgetLocationAt: function(offset, _isTime) {\n\t\treturn this.getLocationAtTime(\n\t\t\t\t_isTime ? offset : this.getTimeAt(offset));\n\t},\n\n\tgetLocationAtTime: function(t) {\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetTimeAt: function(offset, start) {\n\t\treturn Curve.getTimeAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterAt: '#getTimeAt',\n\n\tgetOffsetAtTime: function(t) {\n\t\treturn this.getPartLength(0, t);\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetTimeOf: function() {\n\t\treturn Curve.getTimeOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetParameterOf: '#getTimeOf',\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestTime(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(location, _isTime) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, _isTime ? location\n\t\t\t\t\t\t: Curve.getTimeAt(values, location));\n\t\t\t};\n\n\t\t\tthis[name + 'AtTime'] = function(time) {\n\t\t\t\treturn Curve[name](this.getValues(), time);\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\t_evaluateMethods: methods\n\t\t\t}\n\t\t}\n\t);\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\n\t\t\tax = 9 * (x1 - x2) + 3 * (x3 - x0),\n\t\t\tbx = 6 * (x0 + x2) - 12 * x1,\n\t\t\tcx = 3 * (x1 - x0),\n\n\t\t\tay = 9 * (y1 - y2) + 3 * (y3 - y0),\n\t\t\tby = 6 * (y0 + y2) - 12 * y1,\n\t\t\tcy = 3 * (y1 - y0);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tisZero = Numerical.isZero;\n\t\tif (isZero(x1 - x0) && isZero(y1 - y0)) {\n\t\t\tx1 = x0;\n\t\t\ty1 = y0;\n\t\t}\n\t\tif (isZero(x2 - x3) && isZero(y2 - y3)) {\n\t\t\tx2 = x3;\n\t\t\ty2 = y3;\n\t\t}\n\t\tvar cx = 3 * (x1 - x0),\n\t\t\tbx = 3 * (x2 - x1) - cx,\n\t\t\tax = x3 - x0 - cx - bx,\n\t\t\tcy = 3 * (y1 - y0),\n\t\t\tby = 3 * (y2 - y1) - cy,\n\t\t\tay = y3 - y0 - cy - by,\n\t\t\tx, y;\n\t\tif (type === 0) {\n\t\t\tx = t === 0 ? x0 : t === 1 ? x3\n\t\t\t\t\t: ((ax * t + bx) * t + cx) * t + x0;\n\t\t\ty = t === 0 ? y0 : t === 1 ? y3\n\t\t\t\t\t: ((ay * t + by) * t + cy) * t + y0;\n\t\t} else {\n\t\t\tvar tMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t < tMin) {\n\t\t\t\tx = cx;\n\t\t\t\ty = cy;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tx = 3 * (x3 - x2);\n\t\t\t\ty = 3 * (y3 - y2);\n\t\t\t} else {\n\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t}\n\t\t\tif (normalized) {\n\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\tx = x2 - x1;\n\t\t\t\t\ty = y2 - y1;\n\t\t\t\t}\n\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\tif (len) {\n\t\t\t\t\tx /= len;\n\t\t\t\t\ty /= len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type === 3) {\n\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tclassify: function(v) {\n\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\ta1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,\n\t\t\t\ta2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,\n\t\t\t\ta3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,\n\t\t\t\td3 = 3 * a3,\n\t\t\t\td2 = d3 - a2,\n\t\t\t\td1 = d2 - a2 + a1,\n\t\t\t\tl = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),\n\t\t\t\ts = l !== 0 ? 1 / l : 0,\n\t\t\t\tisZero = Numerical.isZero,\n\t\t\t\tserpentine = 'serpentine';\n\t\t\td1 *= s;\n\t\t\td2 *= s;\n\t\t\td3 *= s;\n\n\t\t\tfunction type(type, t1, t2) {\n\t\t\t\tvar hasRoots = t1 !== undefined,\n\t\t\t\t\tt1Ok = hasRoots && t1 > 0 && t1 < 1,\n\t\t\t\t\tt2Ok = hasRoots && t2 > 0 && t2 < 1;\n\t\t\t\tif (hasRoots && (!(t1Ok || t2Ok)\n\t\t\t\t\t\t|| type === 'loop' && !(t1Ok && t2Ok))) {\n\t\t\t\t\ttype = 'arch';\n\t\t\t\t\tt1Ok = t2Ok = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: type,\n\t\t\t\t\troots: t1Ok || t2Ok\n\t\t\t\t\t\t\t? t1Ok && t2Ok\n\t\t\t\t\t\t\t\t? t1 < t2 ? [t1, t2] : [t2, t1]\n\t\t\t\t\t\t\t\t: [t1Ok ? t1 : t2]\n\t\t\t\t\t\t\t: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isZero(d1)) {\n\t\t\t\treturn isZero(d2)\n\t\t\t\t\t\t? type(isZero(d3) ? 'line' : 'quadratic')\n\t\t\t\t\t\t: type(serpentine, d3 / (3 * d2));\n\t\t\t}\n\t\t\tvar d = 3 * d2 * d2 - 4 * d1 * d3;\n\t\t\tif (isZero(d)) {\n\t\t\t\treturn type('cusp', d2 / (2 * d1));\n\t\t\t}\n\t\t\tvar f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),\n\t\t\t\tf2 = 2 * d1;\n\t\t\treturn type(d > 0 ? serpentine : 'loop',\n\t\t\t\t\t(d2 + f1) / f2,\n\t\t\t\t\t(d2 - f1) / f2);\n\t\t},\n\n\t\tgetLength: function(v, a, b, ds) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar c = v;\n\t\t\t\tif (b < 1) {\n\t\t\t\t\tc = Curve.subdivide(c, b)[0];\n\t\t\t\t\ta /= b;\n\t\t\t\t}\n\t\t\t\tif (a > 0) {\n\t\t\t\t\tc = Curve.subdivide(c, a)[1];\n\t\t\t\t}\n\t\t\t\tvar dx = c[6] - c[0],\n\t\t\t\t\tdy = c[7] - c[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\treturn Numerical.integrate(ds || getLengthIntegrand(v), a, b,\n\t\t\t\t\tgetIterations(a, b));\n\t\t},\n\n\t\tgetTimeAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0;\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Curve.getLength(v, a, b, ds),\n\t\t\t\tdiff = abs(offset) - rangeLength;\n\t\t\tif (abs(diff) < epsilon) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (diff > epsilon) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t},\n\n\t\tgetPeaks: function(v) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tax =     -x0 + 3 * x1 - 3 * x2 + x3,\n\t\t\t\tbx =  3 * x0 - 6 * x1 + 3 * x2,\n\t\t\t\tcx = -3 * x0 + 3 * x1,\n\t\t\t\tay =     -y0 + 3 * y1 - 3 * y2 + y3,\n\t\t\t\tby =  3 * y0 - 6 * y1 + 3 * y2,\n\t\t\t\tcy = -3 * y0 + 3 * y1,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [];\n\t\t\tNumerical.solveCubic(\n\t\t\t\t\t9 * (ax * ax + ay * ay),\n\t\t\t\t\t9 * (ax * bx + by * ay),\n\t\t\t\t\t2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),\n\t\t\t\t\t(cx * bx + by * cy),\n\t\t\t\t\troots, tMin, tMax);\n\t\t\treturn roots.sort();\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, include, c1, t1, c2, t2, overlap) {\n\t\tvar excludeStart = !overlap && c1.getPrevious() === c2,\n\t\t\texcludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&\n\t\t\tt1 <= (excludeEnd ? tMax : 1)) {\n\t\t\tif (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&\n\t\t\t\tt2 <= (excludeStart ? tMax : 1)) {\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1, null, overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2, null, overlap);\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc1)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc1, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, include, flip,\n\t\t\trecursion, calls, tMin, tMax, uMin, uMax) {\n\t\tif (++calls >= 4096 || ++recursion >= 40)\n\t\t\treturn calls;\n\t\tvar fatLineEpsilon = 1e-9,\n\t\t\tq0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif (d1 === 0 && d2 === 0\n\t\t\t\t&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0\n\t\t\t|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null\n\t\t\t|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn calls;\n\t\tvar tMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n\t\t\tvar t = (tMinNew + tMaxNew) / 2,\n\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tflip ? c2 : c1, flip ? u : t,\n\t\t\t\t\tflip ? c1 : c2, flip ? t : u);\n\t\t} else {\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tif (tMaxClip - tMinClip > 0.8) {\n\t\t\t\tif (tMaxNew - tMinNew > uMax - uMin) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = (tMinNew + tMaxNew) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[0], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, t);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[1], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, t, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[0], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, u, tMinNew, tMaxNew);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[1], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, u, uMax, tMinNew, tMaxNew);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (uMax - uMin >= fatLineEpsilon) {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, include, flip,\n\t\t\t\t\t\t\trecursion, calls, tMinNew, tMaxNew, uMin, uMax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn calls;\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= 0.5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getCurveLineIntersections(v, px, py, vx, vy) {\n\t\tvar isZero = Numerical.isZero;\n\t\tif (isZero(vx) && isZero(vy)) {\n\t\t\tvar t = Curve.getTimeOf(v, new Point(px, py));\n\t\t\treturn t === null ? [] : [t];\n\t\t}\n\t\tvar angle = Math.atan2(-vy, vx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trv = [],\n\t\t\troots = [];\n\t\tfor (var i = 0; i < 8; i += 2) {\n\t\t\tvar x = v[i] - px,\n\t\t\t\ty = v[i + 1] - py;\n\t\t\trv.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tCurve.solveCubic(rv, 1, 0, roots, 0, 1);\n\t\treturn roots;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, include,\n\t\t\tflip) {\n\t\tvar x1 = v2[0], y1 = v2[1],\n\t\t\tx2 = v2[6], y2 = v2[7],\n\t\t\troots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n\t\tfor (var i = 0, l = roots.length; i < l; i++) {\n\t\t\tvar t1 = roots[i],\n\t\t\t\tp1 = Curve.getPoint(v1, t1),\n\t\t\t\tt2 = Curve.getTimeOf(v2, p1);\n\t\t\tif (t2 !== null) {\n\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\tflip ? c2 : c1, flip ? t2 : t1,\n\t\t\t\t\t\tflip ? c1 : c2, flip ? t1 : t2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, include) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, Curve.getTimeOf(v1, pt),\n\t\t\t\t\tc2, Curve.getTimeOf(v2, pt));\n\t\t}\n\t}\n\n\tfunction getCurveIntersections(v1, v2, c1, c2, locations, include) {\n\t\tvar epsilon = 1e-12,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max;\n\n\t\tif (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >\n\t\t\tmin(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmin(v1[0], v1[2], v1[4], v1[6]) - epsilon <\n\t\t\tmax(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmax(v1[1], v1[3], v1[5], v1[7]) + epsilon >\n\t\t\tmin(v2[1], v2[3], v2[5], v2[7]) &&\n\t\t\tmin(v1[1], v1[3], v1[5], v1[7]) - epsilon <\n\t\t\tmax(v2[1], v2[3], v2[5], v2[7])) {\n\t\t\tvar overlaps = getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\tc1, overlap[0],\n\t\t\t\t\t\t\tc2, overlap[1], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tflip = straight1 && !straight2,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tflip ? v2 : v1, flip ? v1 : v2,\n\t\t\t\t\t\t\tflip ? c2 : c1, flip ? c1 : c2,\n\t\t\t\t\t\t\tlocations, include, flip,\n\t\t\t\t\t\t\t0, 0, 0, 1, 0, 1);\n\t\t\t\tif (!straight || locations.length === before) {\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tvar t1 = i >> 1,\n\t\t\t\t\t\t\tt2 = i & 1,\n\t\t\t\t\t\t\ti1 = t1 * 6,\n\t\t\t\t\t\t\ti2 = t2 * 6,\n\t\t\t\t\t\t\tp1 = new Point(v1[i1], v1[i1 + 1]),\n\t\t\t\t\t\t\tp2 = new Point(v2[i2], v2[i2 + 1]);\n\t\t\t\t\t\tif (p1.isClose(p2, epsilon)) {\n\t\t\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\t\t\tc1, t1,\n\t\t\t\t\t\t\t\t\tc2, t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getLoopIntersection(v1, c1, locations, include) {\n\t\tvar info = Curve.classify(v1);\n\t\tif (info.type === 'loop') {\n\t\t\tvar roots = info.roots;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, roots[0],\n\t\t\t\t\tc1, roots[1]);\n\t\t}\n\t  return locations;\n\t}\n\n\tfunction getIntersections(curves1, curves2, include, matrix1, matrix2,\n\t\t\t_returnFirst) {\n\t\tvar self = !curves2;\n\t\tif (self)\n\t\t\tcurves2 = curves1;\n\t\tvar length1 = curves1.length,\n\t\t\tlength2 = curves2.length,\n\t\t\tvalues2 = [],\n\t\t\tarrays = [],\n\t\t\tlocations,\n\t\t\tcurrent;\n\t\tfor (var i = 0; i < length2; i++)\n\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvar curve1 = curves1[i],\n\t\t\t\tvalues1 = self ? values2[i] : curve1.getValues(matrix1),\n\t\t\t\tpath1 = curve1.getPath();\n\t\t\tif (path1 !== current) {\n\t\t\t\tcurrent = path1;\n\t\t\t\tlocations = [];\n\t\t\t\tarrays.push(locations);\n\t\t\t}\n\t\t\tif (self) {\n\t\t\t\tgetLoopIntersection(values1, curve1, locations, include);\n\t\t\t}\n\t\t\tfor (var j = self ? i + 1 : 0; j < length2; j++) {\n\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\treturn locations;\n\t\t\t\tgetCurveIntersections(values1, values2[j], curve1, curves2[j],\n\t\t\t\t\t\tlocations, include);\n\t\t\t}\n\t\t}\n\t\tlocations = [];\n\t\tfor (var i = 0, l = arrays.length; i < l; i++) {\n\t\t\tlocations.push.apply(locations, arrays[i]);\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getOverlaps(v1, v2) {\n\n\t\tfunction getSquaredLineLength(v) {\n\t\t\tvar x = v[6] - v[0],\n\t\t\t\ty = v[7] - v[1];\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tvar abs = Math.abs,\n\t\t\tgetDistance = Line.getDistance,\n\t\t\ttimeEpsilon = 1e-8,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\tstraightBoth = straight1 && straight2,\n\t\t\tflip = getSquaredLineLength(v1) < getSquaredLineLength(v2),\n\t\t\tl1 = flip ? v2 : v1,\n\t\t\tl2 = flip ? v1 : v2,\n\t\t\tpx = l1[0], py = l1[1],\n\t\t\tvx = l1[6] - px, vy = l1[7] - py;\n\t\tif (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&\n\t\t\tgetDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n\t\t\tif (!straightBoth &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {\n\t\t\t\tstraight1 = straight2 = straightBoth = true;\n\t\t\t}\n\t\t} else if (straightBoth) {\n\t\t\treturn null;\n\t\t}\n\t\tif (straight1 ^ straight2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar v = [v1, v2],\n\t\t\tpairs = [];\n\t\tfor (var i = 0; i < 4 && pairs.length < 2; i++) {\n\t\t\tvar i1 = i & 1,\n\t\t\t\ti2 = i1 ^ 1,\n\t\t\t\tt1 = i >> 1,\n\t\t\t\tt2 = Curve.getTimeOf(v[i1], new Point(\n\t\t\t\t\tv[i2][t1 ? 6 : 0],\n\t\t\t\t\tv[i2][t1 ? 7 : 1]));\n\t\t\tif (t2 != null) {\n\t\t\t\tvar pair = i1 ? [t1, t2] : [t2, t1];\n\t\t\t\tif (!pairs.length ||\n\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon) {\n\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && !pairs.length)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pairs.length !== 2) {\n\t\t\tpairs = null;\n\t\t} else if (!straightBoth) {\n\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\tpairs = null;\n\t\t}\n\t\treturn pairs;\n\t}\n\n\treturn {\n\t\tgetIntersections: function(curve) {\n\t\t\tvar v1 = this.getValues(),\n\t\t\t\tv2 = curve && curve !== this && curve.getValues();\n\t\t\treturn v2 ? getCurveIntersections(v1, v2, this, curve, [])\n\t\t\t\t\t  : getLoopIntersection(v1, this, []);\n\t\t},\n\n\t\tstatics: {\n\t\t\tgetOverlaps: getOverlaps,\n\t\t\tgetIntersections: getIntersections,\n\t\t\tgetCurveLineIntersections: getCurveLineIntersections\n\t\t}\n\t};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\n\tinitialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n\t\tif (time >= 0.99999999) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\ttime = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._setCurve(curve);\n\t\tthis._time = time;\n\t\tthis._point = point || curve.getPointAtTime(time);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._previous = null;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tvar path = curve._path;\n\t\tthis._path = path;\n\t\tthis._version = path ? path._version : 0;\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tthis._setCurve(segment.getCurve());\n\t\tthis._segment = segment;\n\t\tthis._time = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar segment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tif (time === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (time != null) {\n\t\t\t\tsegment = curve.getPartLength(0, time)\n\t\t\t\t\t< curve.getPartLength(time, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tthis._time = this._offset = this._curveOffset = this._curve = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn this._curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetTime: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this._time;\n\t\treturn curve && time == null\n\t\t\t? this._time = curve.getTimeOf(this._point)\n\t\t\t: time;\n\t},\n\n\tgetParameter: '#getTime',\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar offset = this._curveOffset;\n\t\tif (offset == null) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tthis._curveOffset = offset = time != null && curve\n\t\t\t\t\t&& curve.getPartLength(0, time);\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = curve && curve.divideAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tpath = curve._path,\n\t\t\tres = curve && curve.splitAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(path.getLastSegment());\n\t\t}\n\t\treturn  res;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc;\n\t\tif (!res && loc instanceof CurveLocation) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tp1 = c1._path,\n\t\t\t\tp2 = c2._path;\n\t\t\tif (p1 === p2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tepsilon = 1e-7,\n\t\t\t\t\tdiff = abs(this.getOffset() - loc.getOffset()),\n\t\t\t\t\ti1 = !_ignoreOther && this._intersection,\n\t\t\t\t\ti2 = !_ignoreOther && loc._intersection;\n\t\t\t\tres = (diff < epsilon\n\t\t\t\t\t\t|| p1 && abs(p1.getLength() - diff) < epsilon)\n\t\t\t\t\t&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar time = this.getTime();\n\t\tif (time != null)\n\t\t\tparts.push('time: ' + f.number(time));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getTime(),\n\t\t\tt2 = inter.getTime(),\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tt1Inside = t1 >= tMin && t1 <= tMax,\n\t\t\tt2Inside = t2 >= tMin && t2 <= tMax;\n\t\tif (t1Inside && t2Inside)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = t1 < tMin ? c2.getPrevious() : c2,\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = t2 < tMin ? c4.getPrevious() : c4;\n\t\tif (t1 > tMax)\n\t\t\tc2 = c2.getNext();\n\t\tif (t2 > tMax)\n\t\t\tc4 = c4.getNext();\n\t\tif (!c1 || !c2 || !c3 || !c4)\n\t\t\treturn false;\n\n\t\tvar offsets = [];\n\n\t\tfunction addOffsets(curve, end) {\n\t\t\tvar v = curve.getValues(),\n\t\t\t\troots = Curve.classify(v).roots || Curve.getPeaks(v),\n\t\t\t\tcount = roots.length,\n\t\t\t\tt = end && count > 1 ? roots[count - 1]\n\t\t\t\t\t\t: count > 0 ? roots[0]\n\t\t\t\t\t\t: 0.5;\n\t\t\toffsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);\n\t\t}\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min || angle < max;\n\t\t}\n\n\t\tif (!t1Inside) {\n\t\t\taddOffsets(c1, true);\n\t\t\taddOffsets(c2, false);\n\t\t}\n\t\tif (!t2Inside) {\n\t\t\taddOffsets(c3, true);\n\t\t\taddOffsets(c4, false);\n\t\t}\n\t\tvar pt = this.getPoint(),\n\t\t\toffset = Math.min.apply(Math, offsets),\n\t\t\tv2 = t1Inside ? c2.getTangentAtTime(t1)\n\t\t\t\t\t: c2.getPointAt(offset).subtract(pt),\n\t\t\tv1 = t1Inside ? v2.negate()\n\t\t\t\t\t: c1.getPointAt(-offset).subtract(pt),\n\t\t\tv4 = t2Inside ? c4.getTangentAtTime(t2)\n\t\t\t\t\t: c4.getPointAt(offset).subtract(pt),\n\t\t\tv3 = t2Inside ? v4.negate()\n\t\t\t\t\t: c3.getPointAt(-offset).subtract(pt),\n\t\t\ta1 = v1.getAngle(),\n\t\t\ta2 = v2.getAngle(),\n\t\t\ta3 = v3.getAngle(),\n\t\t\ta4 = v4.getAngle();\n\t\treturn !!(t1Inside\n\t\t\t\t? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&\n\t\t\t\t  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))\n\t\t\t\t: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&\n\t\t\t\t  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));\n\t},\n\n\thasOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve._evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this.getTime();\n\t\treturn time != null && curve && curve[get](time, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t1e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 !== path2\n\t\t\t\t? path1._id - path2._id\n\t\t\t\t: (loc.getIndex() + loc.getTime())\n\t\t\t\t- (loc2.getIndex() + loc2.getTime());\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\t_selectBounds: false,\n\t_canScaleStroke: true,\n\tbeans: true,\n\n\tinitialize: function PathItem() {\n\t},\n\n\tstatics: {\n\t\tcreate: function(arg) {\n\t\t\tvar data,\n\t\t\t\tsegments,\n\t\t\t\tcompound;\n\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\tsegments = arg.segments;\n\t\t\t\tdata = arg.pathData;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tsegments = arg;\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tdata = arg;\n\t\t\t}\n\t\t\tif (segments) {\n\t\t\t\tvar first = segments[0];\n\t\t\t\tcompound = first && Array.isArray(first[0]);\n\t\t\t} else if (data) {\n\t\t\t\tcompound = (data.match(/m/gi) || []).length > 1\n\t\t\t\t\t\t|| /z\\s*\\S+/i.test(data);\n\t\t\t}\n\t\t\tvar ctor = compound ? CompoundPath : Path;\n\t\t\treturn new ctor(arg);\n\t\t}\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tisClockwise: function() {\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis[move ? 'moveTo' : 'lineTo'](current = getPoint(j));\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\t\tmove = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tcurrent = current.clone();\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(1e-12);\n\t\t\t\tcurrent = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = point.isInside(\n\t\t\t\tthis.getBounds({ internal: true, handle: true }))\n\t\t\t\t\t? this._getWinding(point)\n\t\t\t\t\t: {};\n\t\treturn winding.onPath || !!(this.getFillRule() === 'evenodd'\n\t\t\t\t? winding.windingL & 1 || winding.windingR & 1\n\t\t\t\t: winding.winding);\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix._orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix)._orNullIfIdentity();\n\t\treturn self || this.getBounds(matrix1).intersects(\n\t\t\t\tpath.getBounds(matrix2), 1e-12)\n\t\t\t\t? Curve.getIntersections(\n\t\t\t\t\t\tthis.getCurves(), !self && path.getCurves(), include,\n\t\t\t\t\t\tmatrix1, matrix2, _returnFirst)\n\t\t\t\t: [];\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.hasOverlap() || inter.isCrossing();\n\t\t});\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar isPath = !this._children,\n\t\t\tname = isPath ? '_segments' : '_children',\n\t\t\titemsFrom = from[name],\n\t\t\titemsTo = to[name],\n\t\t\titems = this[name];\n\t\tif (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {\n\t\t\tthrow new Error('Invalid operands in interpolate() call: ' +\n\t\t\t\t\tfrom + ', ' + to);\n\t\t}\n\t\tvar current = items.length,\n\t\t\tlength = itemsTo.length;\n\t\tif (current < length) {\n\t\t\tvar ctor = isPath ? Segment : Path;\n\t\t\tfor (var i = current; i < length; i++) {\n\t\t\t\tthis.add(new ctor());\n\t\t\t}\n\t\t} else if (current > length) {\n\t\t\tthis[isPath ? 'removeSegments' : 'removeChildren'](length, current);\n\t\t}\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titems[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n\t\t}\n\t\tif (isPath) {\n\t\t\tthis.setClosed(from._closed);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tcompare: function(path) {\n\t\tvar ok = false;\n\t\tif (path) {\n\t\t\tvar paths1 = this._children || [this],\n\t\t\t\tpaths2 = path._children ? path._children.slice() : [path],\n\t\t\t\tlength1 = paths1.length,\n\t\t\t\tlength2 = paths2.length,\n\t\t\t\tmatched = [],\n\t\t\t\tcount = 0;\n\t\t\tok = true;\n\t\t\tfor (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {\n\t\t\t\tvar path1 = paths1[i1];\n\t\t\t\tok = false;\n\t\t\t\tfor (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {\n\t\t\t\t\tif (path1.compare(paths2[i2])) {\n\t\t\t\t\t\tif (!matched[i2]) {\n\t\t\t\t\t\t\tmatched[i2] = true;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = ok && count === length2;\n\t\t}\n\t\treturn ok;\n\t},\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar segments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: arguments\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? arguments\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._segmentSelection = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setSegments(source._segments);\n\t\tthis._closed = source._closed;\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tthis._length = this._area = undefined;\n\t\t\tif (flags & 16) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 32) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected(),\n\t\t\tlength = segments && segments.length;\n\t\tthis._segments.length = 0;\n\t\tthis._segmentSelection = 0;\n\t\tthis._curves = undefined;\n\t\tif (length) {\n\t\t\tvar last = segments[length - 1];\n\t\t\tif (typeof last === 'boolean') {\n\t\t\t\tthis.setClosed(last);\n\t\t\t\tlength--;\n\t\t\t}\n\t\t\tthis._add(Segment.readList(segments, 0, {}, length));\n\t\t}\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(25);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine) {\n\t\t\t\t\t\tvar dx = curX - prevX,\n\t\t\t\t\t\t\tdy = curY - prevY;\n\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t  dx === 0 ? 'v' + f.number(dy)\n\t\t\t\t\t\t\t: dy === 0 ? 'h' + f.number(dx)\n\t\t\t\t\t\t\t: 'l' + f.pair(dx, dy));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair( inX - prevX,  inY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (!length)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._segments.length;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar segments = this._segments,\n\t\t\tcoords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selection);\n\t\t}\n\t\tif (append) {\n\t\t\tsegments.push.apply(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tstart = index > 0 && index + amount - 1 === total ? index - 1\n\t\t\t\t\t: index,\n\t\t\t\tinsert = start,\n\t\t\t\tend = Math.min(start + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [start, 0].concat(segs._curves));\n\t\t\t\tinsert += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = insert; i < end; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(start, end);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(start, end) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && !start ? segments.length - 1\n\t\t\t\t: start - 1]) {\n\t\t\tcurve._segment2 = segments[start] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[end]) {\n\t\t\tcurve._segment1 = segments[end];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\treturn arguments.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments))\n\t\t\t: this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\treturn arguments.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(arguments, 1), index)\n\t\t\t: this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readList(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readList(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(start, end, _includeCurves) {\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(start, end - start),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, segment._selection, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = start, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = start > 0 && end === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? start - 1\n\t\t\t\t\t: start,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\t\tcurves[i]._path = null;\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(25);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tvar area = this._area;\n\t\tif (area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tclosed = this._closed;\n\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar last = i + 1 === l;\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[last ? 0 : i + 1],\n\t\t\t\t\t\tnull, last && !closed));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn area;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this.isSelected() && length > 0 && this._segmentSelection\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelection: function setSelection(selection) {\n\t\tif (!(selection & 1))\n\t\t\tthis._selectSegments(false);\n\t\tsetSelection.base.call(this, selection);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tselection = selected ? 7 : 0;\n\t\tthis._segmentSelection = selection * length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tsegments[i]._selection = selection;\n\t},\n\n\t_updateSelection: function(segment, oldSelection, newSelection) {\n\t\tsegment._selection = newSelection;\n\t\tvar selection = this._segmentSelection += newSelection - oldSelection;\n\t\tif (selection > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tdivideAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tcurve;\n\t\treturn loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))\n\t\t\t\t? curve._segment1\n\t\t\t\t: null;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tindex = loc && loc.index,\n\t\t\ttime = loc && loc.time,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (time > tMax) {\n\t\t\tindex++;\n\t\t\ttime = 0;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (time >= tMin) {\n\t\t\t\tcurves[index++].divideAtTime(time);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.copyAttributes(this);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\tsplit: function(index, time) {\n\t\tvar curve,\n\t\t\tlocation = time === undefined ? index\n\t\t\t\t: (curve = this.getCurves()[index])\n\t\t\t\t\t&& curve.getLocationAtTime(time);\n\t\treturn location != null ? this.splitAt(location) : null;\n\t},\n\n\tjoin: function(path, tolerance) {\n\t\tvar epsilon = tolerance || 0;\n\t\tif (path && path !== this) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.isClose(last2._point, epsilon))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.isClose(first2._point, epsilon)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.isClose(first2._point, epsilon))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.isClose(last2._point, epsilon)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.isClose(last._point, epsilon)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\treduce: function(options) {\n\t\tvar curves = this.getCurves(),\n\t\t\tsimplify = options && options.simplify,\n\t\t\ttolerance = simplify ? 1e-7 : 0;\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (!curve.hasLength(tolerance)\n\t\t\t\t\t|| simplify && curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tthis._changed(9);\n\t},\n\n\tflatten: function(flatness) {\n\t\tvar flattener = new PathFlattener(this, flatness || 0.25, 256, true),\n\t\t\tparts = flattener.parts,\n\t\t\tlength = parts.length,\n\t\t\tsegments = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tsegments.push(new Segment(parts[i].curve.slice(0, 2)));\n\t\t}\n\t\tif (!this._closed && length > 0) {\n\t\t\tsegments.push(new Segment(parts[length - 1].curve.slice(6)));\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tvar segments = new PathFitter(this).fit(tolerance || 2.5);\n\t\tif (segments)\n\t\t\tthis.setSegments(segments);\n\t\treturn !!segments;\n\t},\n\n\tsmooth: function(options) {\n\t\tvar that = this,\n\t\t\topts = options || {},\n\t\t\ttype = opts.type || 'asymmetric',\n\t\t\tsegments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tclosed = this._closed;\n\n\t\tfunction getIndex(value, _default) {\n\t\t\tvar index = value && value.index;\n\t\t\tif (index != null) {\n\t\t\t\tvar path = value.path;\n\t\t\t\tif (path && path !== that)\n\t\t\t\t\tthrow new Error(value._class + ' ' + index + ' of ' + path\n\t\t\t\t\t\t\t+ ' is not part of ' + that);\n\t\t\t\tif (_default && value instanceof Curve)\n\t\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tindex = typeof value === 'number' ? value : _default;\n\t\t\t}\n\t\t\treturn Math.min(index < 0 && closed\n\t\t\t\t\t? index % length\n\t\t\t\t\t: index < 0 ? index + length : index, length - 1);\n\t\t}\n\n\t\tvar loop = closed && opts.from === undefined && opts.to === undefined,\n\t\t\tfrom = getIndex(opts.from, 0),\n\t\t\tto = getIndex(opts.to, length - 1);\n\n\t\tif (from > to) {\n\t\t\tif (closed) {\n\t\t\t\tfrom -= length;\n\t\t\t} else {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t}\n\t\tif (/^(?:asymmetric|continuous)$/.test(type)) {\n\t\t\tvar asymmetric = type === 'asymmetric',\n\t\t\t\tmin = Math.min,\n\t\t\t\tamount = to - from + 1,\n\t\t\t\tn = amount - 1,\n\t\t\t\tpadding = loop ? min(amount, 4) : 1,\n\t\t\t\tpaddingLeft = padding,\n\t\t\t\tpaddingRight = padding,\n\t\t\t\tknots = [];\n\t\t\tif (!closed) {\n\t\t\t\tpaddingLeft = min(1, from);\n\t\t\t\tpaddingRight = min(1, length - to - 1);\n\t\t\t}\n\t\t\tn += paddingLeft + paddingRight;\n\t\t\tif (n <= 1)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {\n\t\t\t\tknots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n\t\t\t}\n\n\t\t\tvar x = knots[0]._x + 2 * knots[1]._x,\n\t\t\t\ty = knots[0]._y + 2 * knots[1]._y,\n\t\t\t\tf = 2,\n\t\t\t\tn_1 = n - 1,\n\t\t\t\trx = [x],\n\t\t\t\try = [y],\n\t\t\t\trf = [f],\n\t\t\t\tpx = [],\n\t\t\t\tpy = [];\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tvar internal = i < n_1,\n\t\t\t\t\ta = internal ? 1 : asymmetric ? 1 : 2,\n\t\t\t\t\tb = internal ? 4 : asymmetric ? 2 : 7,\n\t\t\t\t\tu = internal ? 4 : asymmetric ? 3 : 8,\n\t\t\t\t\tv = internal ? 2 : asymmetric ? 0 : 1,\n\t\t\t\t\tm = a / f;\n\t\t\t\tf = rf[i] = b - m;\n\t\t\t\tx = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n\t\t\t\ty = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n\t\t\t}\n\n\t\t\tpx[n_1] = rx[n_1] / rf[n_1];\n\t\t\tpy[n_1] = ry[n_1] / rf[n_1];\n\t\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\t\tpx[i] = (rx[i] - px[i + 1]) / rf[i];\n\t\t\t\tpy[i] = (ry[i] - py[i + 1]) / rf[i];\n\t\t\t}\n\t\t\tpx[n] = (3 * knots[n]._x - px[n_1]) / 2;\n\t\t\tpy[n] = (3 * knots[n]._y - py[n_1]) / 2;\n\n\t\t\tfor (var i = paddingLeft, max = n - paddingRight, j = from;\n\t\t\t\t\ti <= max; i++, j++) {\n\t\t\t\tvar segment = segments[j < 0 ? j + length : j],\n\t\t\t\t\tpt = segment._point,\n\t\t\t\t\thx = px[i] - pt._x,\n\t\t\t\t\thy = py[i] - pt._y;\n\t\t\t\tif (loop || i < max)\n\t\t\t\t\tsegment.setHandleOut(hx, hy);\n\t\t\t\tif (loop || i > paddingLeft)\n\t\t\t\t\tsegment.setHandleIn(-hx, -hy);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = from; i <= to; i++) {\n\t\t\t\tsegments[i < 0 ? i + length : i].smooth(opts,\n\t\t\t\t\t\t!loop && i === from, !loop && i === to);\n\t\t\t}\n\t\t}\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t});\n\t\t\tshape.copyAttributes(this, true);\n\t\t\tshape._matrix.prepend(this._matrix);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\tif (insert === undefined || insert)\n\t\t\t\tshape.insertAbove(this);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\ttoPath: '#clone',\n\n\tcompare: function compare(path) {\n\t\tif (!path || path instanceof CompoundPath)\n\t\t\treturn compare.base.call(this, path);\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = curves2.length;\n\t\tif (!length1 || !length2) {\n\t\t\treturn length1 == length2;\n\t\t}\n\t\tvar v1 = curves1[0].getValues(),\n\t\t\tvalues2 = [],\n\t\t\tpos1 = 0, pos2,\n\t\t\tend1 = 0, end2;\n\t\tfor (var i = 0; i < length2; i++) {\n\t\t\tvar v2 = curves2[i].getValues();\n\t\t\tvalues2.push(v2);\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tpos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n\t\t\t\tend2 = overlaps[0][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar abs = Math.abs,\n\t\t\tepsilon = 1e-8,\n\t\t\tv2 = values2[pos2],\n\t\t\tstart2;\n\t\twhile (v1 && v2) {\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tvar t1 = overlaps[0][0];\n\t\t\t\tif (abs(t1 - end1) < epsilon) {\n\t\t\t\t\tend1 = overlaps[1][0];\n\t\t\t\t\tif (end1 === 1) {\n\t\t\t\t\t\tv1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n\t\t\t\t\t\tend1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = overlaps[0][1];\n\t\t\t\t\tif (abs(t2 - end2) < epsilon) {\n\t\t\t\t\t\tif (!start2)\n\t\t\t\t\t\t\tstart2 = [pos2, t2];\n\t\t\t\t\t\tend2 = overlaps[1][1];\n\t\t\t\t\t\tif (end2 === 1) {\n\t\t\t\t\t\t\tif (++pos2 >= length2)\n\t\t\t\t\t\t\t\tpos2 = 0;\n\t\t\t\t\t\t\tv2 = values2[pos2] || curves2[pos2].getValues();\n\t\t\t\t\t\t\tend2 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v1) {\n\t\t\t\t\t\t\treturn start2[0] === pos2 && start2[1] === end2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tstrokeRadius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (strokeRadius !== null) {\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tstrokePadding = strokePadding.add(\n\t\t\t\t\tPath._getStrokePadding(strokeRadius, strokeMatrix));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tvar isJoin = closed || segment._index > 0\n\t\t\t\t\t&& segment._index < numSegments - 1;\n\t\t\tif ((isJoin ? join : cap) === 'round') {\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t} else {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (isJoin) {\n\t\t\t\t\tif (!segment.isSmooth()) {\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius,\n\t\t\t\t\t\t\t   miterLimit, null, strokeMatrix, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t} else if (cap === 'square') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, null,\n\t\t\t\t\t\t\tstrokeMatrix, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (strokeRadius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar time = loc.getTime();\n\t\t\t\tif (time === 0 || time === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point)\n\t\t\t\t\t\t\t<= miterLimit * strokeRadius\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar loc = this.getLocationAt(offset);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset) {\n\t\tif (typeof offset === 'number') {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength()) {\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\t}\n\t\t} else if (offset && offset.getPath && offset.getPath() === this) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn null;\n\t}\n\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tvar half = size / 2,\n\t\t\tcoords = new Array(6),\n\t\t\tpX, pY;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tselection = segment._selection;\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tpX = coords[0];\n\t\t\tpY = coords[1];\n\t\t\tif (selection & 2)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (selection & 4)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (!(selection & 1)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar flattener = new PathFlattener(this, 0.25, 32, false,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = flattener.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tfrom = from % length;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\tflattener.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (!segments.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tt = Base.pick(Base.read(arguments), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar abs = Math.abs,\n\t\t\t\tsqrt = Math.sqrt,\n\t\t\t\tcurrent = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(arguments),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(arguments) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(arguments);\n\t\t\t} else {\n\t\t\t\tvar radius = Size.read(arguments),\n\t\t\t\t\tisZero = Numerical.isZero;\n\t\t\t\tif (isZero(radius.width) || isZero(radius.height))\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(arguments),\n\t\t\t\t\tclockwise = !!Base.read(arguments),\n\t\t\t\t\tlarge = !!Base.read(arguments),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq = x * x,\n\t\t\t\t\tySq = y * y;\n\t\t\t\tvar factor = sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1) * sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar epsilon = 1e-7,\n\t\t\t\text = abs(extent),\n\t\t\t\tcount = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),\n\t\t\t\tinc = extent / count,\n\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\tsegments = [];\n\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\tvar pt = to,\n\t\t\t\t\tout = null;\n\t\t\t\tif (i < count) {\n\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t} else {\n\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t}\n\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t}\n\t\t\t\tvector = vector.rotate(inc);\n\t\t\t}\n\t\t\tthis._add(segments);\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar through = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tparameter = Base.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar handle1 = Point.read(arguments),\n\t\t\t\thandle2 = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar handle = Point.read(arguments),\n\t\t\t\tto = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar current = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(arguments)),\n\t\t\t\tclockwise = Base.pick(Base.peek(arguments), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(arguments)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(tolerance) {\n\t\t\tthis.setClosed(true);\n\t\t\tthis.join(this, tolerance);\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(matrix, options) {\n\t\tvar method = options.handle\n\t\t\t\t? 'getHandleBounds'\n\t\t\t\t: options.stroke\n\t\t\t\t? 'getStrokeBounds'\n\t\t\t\t: 'getBounds';\n\t\treturn Path[method](this._segments, this._closed, this, matrix, options);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, path, matrix, options, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6)),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = style.hasStroke(),\n\t\t\tstrokeWidth = style.getStrokeWidth(),\n\t\t\tstrokeMatrix = stroke && path._getStrokeMatrix(matrix, options),\n\t\t\tstrokePadding = stroke && Path._getStrokePadding(strokeWidth,\n\t\t\t\tstrokeMatrix),\n\t\t\tbounds = Path.getBounds(segments, closed, path, matrix, options,\n\t\t\t\tstrokePadding);\n\t\tif (!stroke)\n\t\t\treturn bounds;\n\t\tvar strokeRadius = strokeWidth / 2,\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = style.getMiterLimit(),\n\t\t\tjoinBounds = new Rectangle(new Size(strokePadding));\n\n\t\tfunction addPoint(point) {\n\t\t\tbounds = bounds.include(point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(\n\t\t\t\t\tjoinBounds.setCenter(segment._point.transform(matrix)));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tif (join === 'round' || segment.isSmooth()) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius, miterLimit,\n\t\t\t\t\t\tmatrix, strokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, matrix,\n\t\t\t\t\t\tstrokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tvar length = segments.length - (closed ? 0 : 1);\n\t\tfor (var i = 1; i < length; i++)\n\t\t\taddJoin(segments[i], join);\n\t\tif (closed) {\n\t\t\taddJoin(segments[0], join);\n\t\t} else if (length > 0) {\n\t\t\taddCap(segments[0], cap);\n\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getStrokePadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar hor = new Point(radius, 0).transform(matrix),\n\t\t\tver = new Point(0, radius).transform(matrix),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = Math.atan2(b * tan, a),\n\t\t\tty = Math.atan2(b, tan * a);\n\t\treturn [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, matrix,\n\t\t\tstrokeMatrix, addPoint, isArea) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPoint1().transform(matrix),\n\t\t\tnormal1 = curve1.getNormalAtTime(1).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\tnormal2 = curve2.getNormalAtTime(0).multiply(radius)\n\t\t\t\t.transform(strokeMatrix);\n\t\tif (normal1.getDirectedAngle(normal2) < 0) {\n\t\t\tnormal1 = normal1.negate();\n\t\t\tnormal2 = normal2.negate();\n\t\t}\n\t\tif (isArea)\n\t\t\taddPoint(point);\n\t\taddPoint(point.add(normal1));\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(point.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(point.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit * radius) {\n\t\t\t\taddPoint(corner);\n\t\t\t}\n\t\t}\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,\n\t\t\taddPoint, isArea) {\n\t\tvar point = segment._point.transform(matrix),\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal()\n\t\t\t\t\t.multiply(loc.getTime() === 0 ? radius : -radius)\n\t\t\t\t\t.transform(strokeMatrix);\n\t\tif (cap === 'square') {\n\t\t\tif (isArea) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tpoint = point.add(normal.rotate(-90));\n\t\t}\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = options.stroke && style.hasStroke(),\n\t\t\tstrokePadding,\n\t\t\tjoinPadding;\n\t\tif (stroke) {\n\t\t\tvar strokeMatrix = path._getStrokeMatrix(matrix, options),\n\t\t\t\tstrokeRadius = style.getStrokeWidth() / 2,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n\t\t\tstrokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n\t\t\tjoinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n\t\t}\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = !j ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && props.insert == false && Item.NO_INSERT);\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props, { insert: true });\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(arguments, 'to'))\n\t\t\t], false, arguments);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), arguments);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar rect = Rectangle.readNamed(arguments, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(arguments, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar ellipse = Shape._readEllipse(arguments);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, arguments);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar from = Point.readNamed(arguments, 'from'),\n\t\t\t\tthrough = Point.readNamed(arguments, 'through'),\n\t\t\t\tto = Point.readNamed(arguments, 'to'),\n\t\t\t\tprops = Base.getNamed(arguments),\n\t\t\t\tpath = new Path(props && props.insert == false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tsides = Base.readNamed(arguments, 'sides'),\n\t\t\t\tradius = Base.readNamed(arguments, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = sides % 3 === 0,\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar center = Point.readNamed(arguments, 'center'),\n\t\t\t\tpoints = Base.readNamed(arguments, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(arguments, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(arguments, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, arguments);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\tbeans: true,\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items) {\n\t\tvar list = items,\n\t\t\tfirst = list[0];\n\t\tif (first && typeof first[0] === 'number')\n\t\t\tlist = [list];\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = list[i];\n\t\t\tif (list === items && !(item instanceof Path))\n\t\t\t\tlist = Base.slice(list);\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tlist[i] = new Path({ segments: item, insert: false });\n\t\t\t} else if (item instanceof CompoundPath) {\n\t\t\t\tlist.splice.apply(list, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\treturn insertChildren.base.call(this, index, list);\n\t},\n\n\treduce: function reduce(options) {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce(options);\n\t\t\tif (path.isEmpty())\n\t\t\t\tpath.remove();\n\t\t}\n\t\tif (!children.length) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.copyAttributes(this);\n\t\t\tpath.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClosed: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tif (!children[i]._closed)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].setClosed(closed);\n\t\t}\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tcurves.push.apply(curves, children[i].getCurves());\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t},\n\n\tgetLength: function() {\n\t\tvar children = this._children,\n\t\t\tlength = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tlength += children[i].getLength();\n\t\treturn length;\n\t},\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.appended(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join('');\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\treturn _hitTestChildren.base.call(this, point,\n\t\t\t\toptions.class === Path || options.type === 'path' ? options\n\t\t\t\t\t: Base.set({}, options, { fill: false }),\n\t\t\t\tviewMatrix);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (!children.length)\n\t\t\treturn;\n\n\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\tctx.beginPath();\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectionItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectionItems[child._id]) {\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.appended(mx));\n\t\t\t}\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && !children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\treturn Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',\n\t\t\t'arcBy'],\n\t\tfunction(key) {\n\t\t\tthis[key] = function() {\n\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t};\n\t\t}, {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\n\t\t\tclosePath: function(tolerance) {\n\t\t\t\tgetCurrentPath(this, true).closePath(tolerance);\n\t\t\t}\n\t\t}\n\t);\n}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {\n\tthis[key] = function(param) {\n\t\tvar children = this._children,\n\t\t\tres;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tres = children[i][key](param) || res;\n\t\t}\n\t\treturn res;\n\t};\n}, {}));\n\nPathItem.inject(new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\toperators = {\n\t\t\tunite:     { '1': true, '2': true },\n\t\t\tintersect: { '2': true },\n\t\t\tsubtract:  { '1': true },\n\t\t\texclude:   { '1': true, '-1': true }\n\t\t};\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path.clone(false).reduce({ simplify: true })\n\t\t\t\t.transform(null, true, true);\n\t\treturn resolve\n\t\t\t\t? res.resolveCrossings().reorient(\n\t\t\t\t\tres.getFillRule() === 'nonzero', true)\n\t\t\t\t: res;\n\t}\n\n\tfunction createResult(paths, simplify, path1, path2, options) {\n\t\tvar result = new CompoundPath(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tresult = result.reduce({ simplify: simplify });\n\t\tif (!(options && options.insert == false)) {\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex() ? path2 : path1);\n\t\t}\n\t\tresult.copyAttributes(path1, true);\n\t\treturn result;\n\t}\n\n\tfunction traceBoolean(path1, path2, operation, options) {\n\t\tif (options && (options.trace == false || options.stroke) &&\n\t\t\t\t/^(subtract|intersect)$/.test(operation))\n\t\t\treturn splitBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true),\n\t\t\toperator = operators[operation];\n\t\toperator[operation] = true;\n\t\tif (_path2 && (operator.subtract || operator.exclude)\n\t\t\t\t^ (_path2.isClockwise() ^ _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar crossings = divideLocations(\n\t\t\t\tCurveLocation.expand(_path1.getCrossings(_path2))),\n\t\t\tpaths1 = _path1._children || [_path1],\n\t\t\tpaths2 = _path2 && (_path2._children || [_path2]),\n\t\t\tsegments = [],\n\t\t\tcurves = [],\n\t\t\tpaths;\n\n\t\tfunction collect(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tsegments.push.apply(segments, path._segments);\n\t\t\t\tcurves.push.apply(curves, path.getCurves());\n\t\t\t\tpath._overlapsOnly = true;\n\t\t\t}\n\t\t}\n\n\t\tif (crossings.length) {\n\t\t\tcollect(paths1);\n\t\t\tif (paths2)\n\t\t\t\tcollect(paths2);\n\t\t\tfor (var i = 0, l = crossings.length; i < l; i++) {\n\t\t\t\tpropagateWinding(crossings[i]._segment, _path1, _path2, curves,\n\t\t\t\t\t\toperator);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i],\n\t\t\t\t\tinter = segment._intersection;\n\t\t\t\tif (!segment._winding) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2, curves, operator);\n\t\t\t\t}\n\t\t\t\tif (!(inter && inter._overlap))\n\t\t\t\t\tsegment._path._overlapsOnly = false;\n\t\t\t}\n\t\t\tpaths = tracePaths(segments, operator);\n\t\t} else {\n\t\t\tpaths = reorientPaths(\n\t\t\t\t\tpaths2 ? paths1.concat(paths2) : paths1.slice(),\n\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\treturn !!operator[w];\n\t\t\t\t\t});\n\t\t}\n\n\t\treturn createResult(paths, true, path1, path2, options);\n\t}\n\n\tfunction splitBoolean(path1, path2, operation) {\n\t\tvar _path1 = preparePath(path1),\n\t\t\t_path2 = preparePath(path2),\n\t\t\tcrossings = _path1.getCrossings(_path2),\n\t\t\tsubtract = operation === 'subtract',\n\t\t\tdivide = operation === 'divide',\n\t\t\tadded = {},\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (!added[path._id] && (divide ||\n\t\t\t\t\t_path2.contains(path.getPointAt(path.getLength() / 2))\n\t\t\t\t\t\t^ subtract)) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn added[path._id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = crossings.length - 1; i >= 0; i--) {\n\t\t\tvar path = crossings[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn createResult(paths, false, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._previous;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._previous)\n\t\t\t\tto = to._previous;\n\t\t\tfrom._next = to;\n\t\t\tto._previous = from;\n\t\t}\n\t}\n\n\tfunction clearCurveHandles(curves) {\n\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\tcurves[i].clearHandles();\n\t}\n\n\tfunction reorientPaths(paths, isInside, clockwise) {\n\t\tvar length = paths && paths.length;\n\t\tif (length) {\n\t\t\tvar lookup = Base.each(paths, function (path, i) {\n\t\t\t\t\tthis[path._id] = {\n\t\t\t\t\t\tcontainer: null,\n\t\t\t\t\t\twinding: path.isClockwise() ? 1 : -1,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t};\n\t\t\t\t}, {}),\n\t\t\t\tsorted = paths.slice().sort(function (a, b) {\n\t\t\t\t\treturn abs(b.getArea()) - abs(a.getArea());\n\t\t\t\t}),\n\t\t\t\tfirst = sorted[0];\n\t\t\tif (clockwise == null)\n\t\t\t\tclockwise = first.isClockwise();\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar path1 = sorted[i],\n\t\t\t\t\tentry1 = lookup[path1._id],\n\t\t\t\t\tpoint = path1.getInteriorPoint(),\n\t\t\t\t\tcontainerWinding = 0;\n\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\tvar path2 = sorted[j];\n\t\t\t\t\tif (path2.contains(point)) {\n\t\t\t\t\t\tvar entry2 = lookup[path2._id];\n\t\t\t\t\t\tcontainerWinding = entry2.winding;\n\t\t\t\t\t\tentry1.winding += containerWinding;\n\t\t\t\t\t\tentry1.container = entry2.exclude ? entry2.container\n\t\t\t\t\t\t\t\t: path2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isInside(entry1.winding) === isInside(containerWinding)) {\n\t\t\t\t\tentry1.exclude = true;\n\t\t\t\t\tpaths[entry1.index] = null;\n\t\t\t\t} else {\n\t\t\t\t\tvar container = entry1.container;\n\t\t\t\t\tpath1.setClockwise(container ? !container.isClockwise()\n\t\t\t\t\t\t\t: clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\tfunction divideLocations(locations, include, clearLater) {\n\t\tvar results = include && [],\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tclearHandles = false,\n\t\t\tclearCurves = clearLater || [],\n\t\t\tclearLookup = clearLater && {},\n\t\t\trenormalizeLocs,\n\t\t\tprevCurve,\n\t\t\tprevTime;\n\n\t\tfunction getId(curve) {\n\t\t\treturn curve._path._id + '.' + curve._segment1._index;\n\t\t}\n\n\t\tfor (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {\n\t\t\tvar curve = clearLater[i];\n\t\t\tif (curve._path)\n\t\t\t\tclearLookup[getId(curve)] = true;\n\t\t}\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\ttime = loc._time,\n\t\t\t\torigTime = time,\n\t\t\t\texclude = include && !include(loc),\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tsegment;\n\t\t\tif (curve) {\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tclearHandles = !curve.hasHandles()\n\t\t\t\t\t\t\t|| clearLookup && clearLookup[getId(curve)];\n\t\t\t\t\trenormalizeLocs = [];\n\t\t\t\t\tprevTime = null;\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t} else if (prevTime >= tMin) {\n\t\t\t\t\ttime /= prevTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exclude) {\n\t\t\t\tif (renormalizeLocs)\n\t\t\t\t\trenormalizeLocs.push(loc);\n\t\t\t\tcontinue;\n\t\t\t} else if (include) {\n\t\t\t\tresults.unshift(loc);\n\t\t\t}\n\t\t\tprevTime = origTime;\n\t\t\tif (time < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tvar newCurve = curve.divideAtTime(time, true);\n\t\t\t\tif (clearHandles)\n\t\t\t\t\tclearCurves.push(curve, newCurve);\n\t\t\t\tsegment = newCurve._segment1;\n\t\t\t\tfor (var j = renormalizeLocs.length - 1; j >= 0; j--) {\n\t\t\t\t\tvar l = renormalizeLocs[j];\n\t\t\t\t\tl._time = (l._time - time) / (1 - time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t}\n\t\tif (!clearLater)\n\t\t\tclearCurveHandles(clearCurves);\n\t\treturn results || locations;\n\t}\n\n\tfunction getWinding(point, curves, dir, closed, dontFlip) {\n\t\tvar ia = dir ? 1 : 0,\n\t\t\tio = ia ^ 1,\n\t\t\tpv = [point.x, point.y],\n\t\t\tpa = pv[ia],\n\t\t\tpo = pv[io],\n\t\t\twindingEpsilon = 1e-9,\n\t\t\tqualityEpsilon = 1e-6,\n\t\t\tpaL = pa - windingEpsilon,\n\t\t\tpaR = pa + windingEpsilon,\n\t\t\twindingL = 0,\n\t\t\twindingR = 0,\n\t\t\tpathWindingL = 0,\n\t\t\tpathWindingR = 0,\n\t\t\tonPath = false,\n\t\t\tonAnyPath = false,\n\t\t\tquality = 1,\n\t\t\troots = [],\n\t\t\tvPrev,\n\t\t\tvClose;\n\n\t\tfunction addWinding(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po < min(o0, o3) || po > max(o0, o3)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar a0 = v[ia + 0],\n\t\t\t\ta1 = v[ia + 2],\n\t\t\t\ta2 = v[ia + 4],\n\t\t\t\ta3 = v[ia + 6];\n\t\t\tif (o0 === o3) {\n\t\t\t\tif (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t =   po === o0 ? 0\n\t\t\t\t\t: po === o3 ? 1\n\t\t\t\t\t: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Curve.solveCubic(v, io, po, roots, 0, 1) > 0\n\t\t\t\t\t\t? roots[0]\n\t\t\t\t\t\t: 1,\n\t\t\t\ta =   t === 0 ? a0\n\t\t\t\t\t: t === 1 ? a3\n\t\t\t\t\t: Curve.getPoint(v, t)[dir ? 'y' : 'x'],\n\t\t\t\twinding = o0 > o3 ? 1 : -1,\n\t\t\t\twindingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,\n\t\t\t\ta3Prev = vPrev[ia + 6];\n\t\t\tif (po !== o0) {\n\t\t\t\tif (a < paL) {\n\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t} else if (a > paR) {\n\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t} else {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\tif (a > pa - qualityEpsilon && a < pa + qualityEpsilon)\n\t\t\t\t\tquality /= 2;\n\t\t\t} else {\n\t\t\t\tif (winding !== windingPrev) {\n\t\t\t\t\tif (a0 < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t} else if (a0 > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t}\n\t\t\t\t} else if (a0 != a3Prev) {\n\t\t\t\t\tif (a3Prev < paR && a > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t} else if (a3Prev > paL && a < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquality = 0;\n\t\t\t}\n\t\t\tvPrev = v;\n\t\t\treturn !dontFlip && a > paL && a < paR\n\t\t\t\t\t&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0\n\t\t\t\t\t&& getWinding(point, curves, !dir, closed, true);\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to1 = v[io + 2],\n\t\t\t\to2 = v[io + 4],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n\t\t\t\tvar a0 = v[ia + 0],\n\t\t\t\t\ta1 = v[ia + 2],\n\t\t\t\t\ta2 = v[ia + 4],\n\t\t\t\t\ta3 = v[ia + 6],\n\t\t\t\t\tmonoCurves = paL > max(a0, a1, a2, a3) ||\n\t\t\t\t\t\t\t\t paR < min(a0, a1, a2, a3)\n\t\t\t\t\t\t\t? [v] : Curve.getMonoCurves(v, dir),\n\t\t\t\t\tres;\n\t\t\t\tfor (var i = 0, l = monoCurves.length; i < l; i++) {\n\t\t\t\t\tif (res = addWinding(monoCurves[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i],\n\t\t\t\tpath = curve._path,\n\t\t\t\tv = curve.getValues(),\n\t\t\t\tres;\n\t\t\tif (!i || curves[i - 1]._path !== path) {\n\t\t\t\tvPrev = null;\n\t\t\t\tif (!path._closed) {\n\t\t\t\t\tvClose = Curve.getValues(\n\t\t\t\t\t\t\tpath.getLastCurve().getSegment2(),\n\t\t\t\t\t\t\tcurve.getSegment1(),\n\t\t\t\t\t\t\tnull, !closed);\n\t\t\t\t\tif (vClose[io] !== vClose[io + 6]) {\n\t\t\t\t\t\tvPrev = vClose;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!vPrev) {\n\t\t\t\t\tvPrev = v;\n\t\t\t\t\tvar prev = path.getLastCurve();\n\t\t\t\t\twhile (prev && prev !== curve) {\n\t\t\t\t\t\tvar v2 = prev.getValues();\n\t\t\t\t\t\tif (v2[io] !== v2[io + 6]) {\n\t\t\t\t\t\t\tvPrev = v2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = prev.getPrevious();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res = handleCurve(v))\n\t\t\t\treturn res;\n\n\t\t\tif (i + 1 === l || curves[i + 1]._path !== path) {\n\t\t\t\tif (vClose && (res = handleCurve(vClose)))\n\t\t\t\t\treturn res;\n\t\t\t\tif (onPath && !pathWindingL && !pathWindingR) {\n\t\t\t\t\tpathWindingL = pathWindingR = path.isClockwise(closed) ^ dir\n\t\t\t\t\t\t\t? 1 : -1;\n\t\t\t\t}\n\t\t\t\twindingL += pathWindingL;\n\t\t\t\twindingR += pathWindingR;\n\t\t\t\tpathWindingL = pathWindingR = 0;\n\t\t\t\tif (onPath) {\n\t\t\t\t\tonAnyPath = true;\n\t\t\t\t\tonPath = false;\n\t\t\t\t}\n\t\t\t\tvClose = null;\n\t\t\t}\n\t\t}\n\t\twindingL = abs(windingL);\n\t\twindingR = abs(windingR);\n\t\treturn {\n\t\t\twinding: max(windingL, windingR),\n\t\t\twindingL: windingL,\n\t\t\twindingR: windingR,\n\t\t\tquality: quality,\n\t\t\tonPath: onAnyPath\n\t\t};\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, curves, operator) {\n\t\tvar chain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twinding;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve(),\n\t\t\t\tlength = curve.getLength();\n\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\ttotalLength += length;\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tvar offsets = [0.5, 0.25, 0.75],\n\t\t\twinding = { winding: 0, quality: -1 },\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tfor (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {\n\t\t\tvar length = totalLength * offsets[i];\n\t\t\tfor (var j = 0, l = chain.length; j < l; j++) {\n\t\t\t\tvar entry = chain[j],\n\t\t\t\t\tcurveLength = entry.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tvar curve = entry.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\toperand = parent instanceof CompoundPath ? parent : path,\n\t\t\t\t\t\tt = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),\n\t\t\t\t\t\tpt = curve.getPointAtTime(t),\n\t\t\t\t\t\tdir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n\t\t\t\t\tvar wind = !(operator.subtract && path2 && (\n\t\t\t\t\t\t\toperand === path1 &&\n\t\t\t\t\t\t\t\tpath2._getWinding(pt, dir, true).winding ||\n\t\t\t\t\t\t\toperand === path2 &&\n\t\t\t\t\t\t\t\t!path1._getWinding(pt, dir, true).winding))\n\t\t\t\t\t\t\t? getWinding(pt, curves, dir, true)\n\t\t\t\t\t\t\t: { winding: 0, quality: 1 };\n\t\t\t\t\tif (wind.quality > winding.quality)\n\t\t\t\t\t\twinding = wind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tfor (var j = chain.length - 1; j >= 0; j--) {\n\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t}\n\n\tfunction tracePaths(segments, operator) {\n\t\tvar paths = [],\n\t\t\tstarts;\n\n\t\tfunction isValid(seg) {\n\t\t\tvar winding;\n\t\t\treturn !!(seg && !seg._visited && (!operator\n\t\t\t\t\t|| operator[(winding = seg._winding || {}).winding]\n\t\t\t\t\t\t&& !(operator.unite && winding.winding === 2\n\t\t\t\t\t\t\t&& winding.windingL && winding.windingR)));\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\tif (seg) {\n\t\t\t\tfor (var i = 0, l = starts.length; i < l; i++) {\n\t\t\t\t\tif (seg === starts[i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction visitPath(path) {\n\t\t\tvar segments = path._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._visited = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCrossingSegments(segment, collectStarts) {\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tstart = inter,\n\t\t\t\tcrossings = [];\n\t\t\tif (collectStarts)\n\t\t\t\tstarts = [segment];\n\n\t\t\tfunction collect(inter, end) {\n\t\t\t\twhile (inter && inter !== end) {\n\t\t\t\t\tvar other = inter._segment,\n\t\t\t\t\t\tpath = other && other._path;\n\t\t\t\t\tif (path) {\n\t\t\t\t\t\tvar next = other.getNext() || path.getFirstSegment(),\n\t\t\t\t\t\t\tnextInter = next._intersection;\n\t\t\t\t\t\tif (other !== segment && (isStart(other)\n\t\t\t\t\t\t\t|| isStart(next)\n\t\t\t\t\t\t\t|| next && (isValid(other) && (isValid(next)\n\t\t\t\t\t\t\t\t|| nextInter && isValid(nextInter._segment))))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcrossings.push(other);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (collectStarts)\n\t\t\t\t\t\t\tstarts.push(other);\n\t\t\t\t\t}\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inter) {\n\t\t\t\tcollect(inter);\n\t\t\t\twhile (inter && inter._prev)\n\t\t\t\t\tinter = inter._prev;\n\t\t\t\tcollect(inter, start);\n\t\t\t}\n\t\t\treturn crossings;\n\t\t}\n\n\t\tsegments.sort(function(seg1, seg2) {\n\t\t\tvar inter1 = seg1._intersection,\n\t\t\t\tinter2 = seg2._intersection,\n\t\t\t\tover1 = !!(inter1 && inter1._overlap),\n\t\t\t\tover2 = !!(inter2 && inter2._overlap),\n\t\t\t\tpath1 = seg1._path,\n\t\t\t\tpath2 = seg2._path;\n\t\t\treturn over1 ^ over2\n\t\t\t\t\t? over1 ? 1 : -1\n\t\t\t\t\t: !inter1 ^ !inter2\n\t\t\t\t\t\t? inter1 ? 1 : -1\n\t\t\t\t\t\t: path1 !== path2\n\t\t\t\t\t\t\t? path1._id - path2._id\n\t\t\t\t\t\t\t: seg1._index - seg2._index;\n\t\t});\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tvalid = isValid(seg),\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false,\n\t\t\t\tclosed = true,\n\t\t\t\tbranches = [],\n\t\t\t\tbranch,\n\t\t\t\tvisited,\n\t\t\t\thandleIn;\n\t\t\tif (valid && seg._path._overlapsOnly) {\n\t\t\t\tvar path1 = seg._path,\n\t\t\t\t\tpath2 = seg._intersection._segment._path;\n\t\t\t\tif (path1.compare(path2)) {\n\t\t\t\t\tif (path1.getArea())\n\t\t\t\t\t\tpaths.push(path1.clone(false));\n\t\t\t\t\tvisitPath(path1);\n\t\t\t\t\tvisitPath(path2);\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (valid) {\n\t\t\t\tvar first = !path,\n\t\t\t\t\tcrossings = getCrossingSegments(seg, first),\n\t\t\t\t\tother = crossings.shift(),\n\t\t\t\t\tfinished = !first && (isStart(seg) || isStart(other)),\n\t\t\t\t\tcross = !finished && other;\n\t\t\t\tif (first) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tif (seg.isFirst() || seg.isLast())\n\t\t\t\t\t\tclosed = seg._path._closed;\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cross && branch) {\n\t\t\t\t\tbranches.push(branch);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (!branch) {\n\t\t\t\t\tif (cross)\n\t\t\t\t\t\tcrossings.push(seg);\n\t\t\t\t\tbranch = {\n\t\t\t\t\t\tstart: path._segments.length,\n\t\t\t\t\t\tcrossings: crossings,\n\t\t\t\t\t\tvisited: visited = [],\n\t\t\t\t\t\thandleIn: handleIn\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (cross)\n\t\t\t\t\tseg = other;\n\t\t\t\tif (!isValid(seg)) {\n\t\t\t\t\tpath.removeSegments(branch.start);\n\t\t\t\t\tfor (var j = 0, k = visited.length; j < k; j++) {\n\t\t\t\t\t\tvisited[j]._visited = false;\n\t\t\t\t\t}\n\t\t\t\t\tvisited.length = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tseg = branch && branch.crossings.shift();\n\t\t\t\t\t\tif (!seg || !seg._path) {\n\t\t\t\t\t\t\tseg = null;\n\t\t\t\t\t\t\tbranch = branches.pop();\n\t\t\t\t\t\t\tif (branch) {\n\t\t\t\t\t\t\t\tvisited = branch.visited;\n\t\t\t\t\t\t\t\thandleIn = branch.handleIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (branch && !isValid(seg));\n\t\t\t\t\tif (!seg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar next = seg.getNext();\n\t\t\t\tpath.add(new Segment(seg._point, handleIn,\n\t\t\t\t\t\tnext && seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tvisited.push(seg);\n\t\t\t\tseg = next || seg._path.getFirstSegment();\n\t\t\t\thandleIn = next && next._handleIn;\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(handleIn);\n\t\t\t\t\tpath.setClosed(closed);\n\t\t\t\t}\n\t\t\t\tif (path.getArea() !== 0) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, dir, closed) {\n\t\t\treturn getWinding(point, this.getCurves(), dir, closed);\n\t\t},\n\n\t\tunite: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'unite', options);\n\t\t},\n\n\t\tintersect: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'intersect', options);\n\t\t},\n\n\t\tsubtract: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'subtract', options);\n\t\t},\n\n\t\texclude: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'exclude', options);\n\t\t},\n\n\t\tdivide: function(path, options) {\n\t\t\treturn options && (options.trace == false || options.stroke)\n\t\t\t\t\t? splitBoolean(this, path, 'divide')\n\t\t\t\t\t: createResult([\n\t\t\t\t\t\tthis.subtract(path, options),\n\t\t\t\t\t\tthis.intersect(path, options)\n\t\t\t\t\t], true, this, path, options);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = children || [this];\n\n\t\t\tfunction hasOverlap(seg, path) {\n\t\t\t\tvar inter = seg && seg._intersection;\n\t\t\t\treturn inter && inter._overlap && inter._path === path;\n\t\t\t}\n\n\t\t\tvar hasOverlaps = false,\n\t\t\t\thasCrossings = false,\n\t\t\t\tintersections = this.getIntersections(null, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap() && (hasOverlaps = true) ||\n\t\t\t\t\t\t\tinter.isCrossing() && (hasCrossings = true);\n\t\t\t\t}),\n\t\t\t\tclearCurves = hasOverlaps && hasCrossings && [];\n\t\t\tintersections = CurveLocation.expand(intersections);\n\t\t\tif (hasOverlaps) {\n\t\t\t\tvar overlaps = divideLocations(intersections, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap();\n\t\t\t\t}, clearCurves);\n\t\t\t\tfor (var i = overlaps.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar overlap = overlaps[i],\n\t\t\t\t\t\tpath = overlap._path,\n\t\t\t\t\t\tseg = overlap._segment,\n\t\t\t\t\t\tprev = seg.getPrevious(),\n\t\t\t\t\t\tnext = seg.getNext();\n\t\t\t\t\tif (hasOverlap(prev, path) && hasOverlap(next, path)) {\n\t\t\t\t\t\tseg.remove();\n\t\t\t\t\t\tprev._handleOut._set(0, 0);\n\t\t\t\t\t\tnext._handleIn._set(0, 0);\n\t\t\t\t\t\tif (prev !== seg && !prev.getCurve().hasLength()) {\n\t\t\t\t\t\t\tnext._handleIn.set(prev._handleIn);\n\t\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCrossings) {\n\t\t\t\tdivideLocations(intersections, hasOverlaps && function(inter) {\n\t\t\t\t\tvar curve1 = inter.getCurve(),\n\t\t\t\t\t\tseg1 = inter.getSegment(),\n\t\t\t\t\t\tother = inter._intersection,\n\t\t\t\t\t\tcurve2 = other._curve,\n\t\t\t\t\t\tseg2 = other._segment;\n\t\t\t\t\tif (curve1 && curve2 && curve1._path && curve2._path)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (seg1)\n\t\t\t\t\t\tseg1._intersection = null;\n\t\t\t\t\tif (seg2)\n\t\t\t\t\t\tseg2._intersection = null;\n\t\t\t\t}, clearCurves);\n\t\t\t\tif (clearCurves)\n\t\t\t\t\tclearCurveHandles(clearCurves);\n\t\t\t\tpaths = tracePaths(Base.each(paths, function(path) {\n\t\t\t\t\tthis.push.apply(this, path._segments);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\tvar length = paths.length,\n\t\t\t\titem;\n\t\t\tif (length > 1 && children) {\n\t\t\t\tif (paths !== children)\n\t\t\t\t\tthis.setChildren(paths);\n\t\t\t\titem = this;\n\t\t\t} else if (length === 1 && !children) {\n\t\t\t\tif (paths[0] !== this)\n\t\t\t\t\tthis.setSegments(paths[0].removeSegments());\n\t\t\t\titem = this;\n\t\t\t}\n\t\t\tif (!item) {\n\t\t\t\titem = new CompoundPath(Item.NO_INSERT);\n\t\t\t\titem.addChildren(paths);\n\t\t\t\titem = item.reduce();\n\t\t\t\titem.copyAttributes(this);\n\t\t\t\tthis.replaceWith(item);\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\n\t\treorient: function(nonZero, clockwise) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && children.length) {\n\t\t\t\tthis.setChildren(reorientPaths(this.removeChildren(),\n\t\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\t\treturn !!(nonZero ? w : w & 1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclockwise));\n\t\t\t} else if (clockwise !== undefined) {\n\t\t\t\tthis.setClockwise(clockwise);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\ty = point.y,\n\t\t\t\t\tintercepts = [],\n\t\t\t\t\troots = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar v = curves[i].getValues(),\n\t\t\t\t\t\to0 = v[1],\n\t\t\t\t\t\to1 = v[3],\n\t\t\t\t\t\to2 = v[5],\n\t\t\t\t\t\to3 = v[7];\n\t\t\t\t\tif (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n\t\t\t\t\t\tvar monoCurves = Curve.getMonoCurves(v);\n\t\t\t\t\t\tfor (var j = 0, m = monoCurves.length; j < m; j++) {\n\t\t\t\t\t\t\tvar mv = monoCurves[j],\n\t\t\t\t\t\t\t\tmo0 = mv[1],\n\t\t\t\t\t\t\t\tmo3 = mv[7];\n\t\t\t\t\t\t\tif ((mo0 !== mo3) &&\n\t\t\t\t\t\t\t\t(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){\n\t\t\t\t\t\t\t\tvar x = y === mo0 ? mv[0]\n\t\t\t\t\t\t\t\t\t: y === mo3 ? mv[6]\n\t\t\t\t\t\t\t\t\t: Curve.solveCubic(mv, 1, y, roots, 0, 1)\n\t\t\t\t\t\t\t\t\t\t=== 1\n\t\t\t\t\t\t\t\t\t\t? Curve.getPoint(mv, roots[0]).x\n\t\t\t\t\t\t\t\t\t\t: (mv[0] + mv[6]) / 2;\n\t\t\t\t\t\t\t\tintercepts.push(x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (intercepts.length > 1) {\n\t\t\t\t\tintercepts.sort(function(a, b) { return a - b; });\n\t\t\t\t\tpoint.x = (intercepts[0] + intercepts[1]) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point;\n\t\t}\n\t};\n});\n\nvar PathFlattener = Base.extend({\n\t_class: 'PathFlattener',\n\n\tinitialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminSpan = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, t1, t2) {\n\t\t\tif ((t2 - t1) > minSpan\n\t\t\t\t\t&& !(ignoreStraight && Curve.isStraight(curve))\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, flatness || 0.25)) {\n\t\t\t\tvar halves = Curve.subdivide(curve, 0.5),\n\t\t\t\t\ttMid = (t1 + t2) / 2;\n\t\t\t\tcomputeParts(halves[0], index, t1, tMid);\n\t\t\t\tcomputeParts(halves[1], index, tMid, t2);\n\t\t\t} else {\n\t\t\t\tvar dx = curve[6] - curve[0],\n\t\t\t\t\tdy = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tif (dist > 0) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tcurve: curve,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttime: t2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2, segments[0]);\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\t_get: function(offset) {\n\t\tvar parts = this.parts,\n\t\t\tlength = parts.length,\n\t\t\tstart,\n\t\t\ti, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (!j || parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\tvar part = parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = parts[i - 1],\n\t\t\t\t\tprevTime = prev && prev.index === part.index ? prev.time : 0,\n\t\t\t\t\tprevOffset = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tindex: part.index,\n\t\t\t\t\ttime: prevTime + (part.time - prevTime)\n\t\t\t\t\t\t* (offset - prevOffset) / (part.offset - prevOffset)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tindex: parts[length - 1].index,\n\t\t\ttime: 1\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tvar start = this._get(from),\n\t\t\tend = this._get(to);\n\t\tfor (var i = start.index, l = end.index; i <= l; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti === start.index ? start.time : 0,\n\t\t\t\t\ti === end.index ? end.time : 1);\n\t\t\tif (i === start.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar param = this._get(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.time);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tclosed = path._closed;\n\t\tfor (var i = 0, prev, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point;\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(prev = point.clone());\n\t\t\t}\n\t\t}\n\t\tif (closed) {\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\t\tthis.closed = closed;\n\t},\n\n\tfit: function(error) {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = null;\n\t\tif (length > 0) {\n\t\t\tsegments = [new Segment(points[0])];\n\t\t\tif (length > 1) {\n\t\t\t\tthis.fitCubic(segments, error, 0, length - 1,\n\t\t\t\t\t\tpoints[1].subtract(points[0]),\n\t\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]));\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tsegments.shift();\n\t\t\t\t\tsegments.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(segments, error, first, last, tan1, tan2) {\n\t\tvar points = this.points;\n\t\tif (last - first === 1) {\n\t\t\tvar pt1 = points[first],\n\t\t\t\tpt2 = points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(error, error * error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < error && parametersInOrder) {\n\t\t\t\tthis.addCurve(segments, curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar tanCenter = points[split - 1].subtract(points[split + 1]);\n\t\tthis.fitCubic(segments, error, first, split, tan1, tanCenter);\n\t\tthis.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(segments, curve) {\n\t\tvar prev = segments[segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tsegments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tabs = Math.abs,\n\t\t\tpoints = this.points,\n\t\t\tpt1 = points[first],\n\t\t\tpt2 = points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1,\n\t\t\talpha2;\n\t\tif (abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\talpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0\n\t\t\t\t\t\t\t: abs(c1) > epsilon ? X[1] / c1\n\t\t\t\t\t\t\t: 0;\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1,\n\t\t\t\tpt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)),\n\t\t\t\tpt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\treturn Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsOptions: { stroke: false, handle: false },\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setContent(source._content);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(265);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\tvar lines = this._lines,\n\t\t\tstyle = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar rect = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(rect, rect) : rect;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tcolorCache = {},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(/^#(\\w{1,2})(\\w{1,2})(\\w{1,2})$/),\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tcomponents = [0, 0, 0];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^rgba?\\((.*)\\)$/)) {\n\t\t\tcomponents = match[1].split(',');\n\t\t\tfor (var i = 0, l = components.length; i < l; i++) {\n\t\t\t\tvar value = +components[i];\n\t\t\t\tcomponents[i] = i < 3 ? value / 255 : value;\n\t\t\t}\n\t\t} else if (window) {\n\t\t\tvar cached = colorCache[string];\n\t\t\tif (!cached) {\n\t\t\t\tif (!colorCtx) {\n\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1);\n\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t}\n\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\tcached = colorCache[string] = [\n\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\tdata[2] / 255\n\t\t\t\t];\n\t\t\t}\n\t\t\tcomponents = cached.slice();\n\t\t} else {\n\t\t\tcomponents = [0, 0, 0];\n\t\t}\n\t\treturn components;\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = name === 'gradient'\n\t\t\t\t\t? function(value) {\n\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\tvalue = Gradient.read(Array.isArray(value) ? value\n\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true });\n\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\t: type === 'gradient'\n\t\t\t\t\t\t? function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function(value) {\n\t\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : value;\n\t\t\t\t\t\t};\n\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar args = arguments,\n\t\t\t\treading = this.__read,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (reading)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = Base.slice(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (reading) {\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = Base.slice(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\ttype = 'rgb';\n\t\t\t\t\tcomponents = fromCSS(arg);\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && !i && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (reading && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (reading)\n\t\t\t\tthis.__read = read;\n\t\t\treturn this;\n\t\t},\n\n\t\tset: '#initialize',\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner)\n\t\t\t\tthis._owner._changed(65);\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this.getAlpha() === col.getAlpha()\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx, matrix) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\thighlight = components[3],\n\t\t\t\tinverse = matrix && matrix.inverted(),\n\t\t\t\tcanvasGradient;\n\t\t\tif (inverse) {\n\t\t\t\torigin = inverse._transformPoint(origin);\n\t\t\t\tdestination = inverse._transformPoint(destination);\n\t\t\t\tif (highlight)\n\t\t\t\t\thighlight = inverse._transformPoint(highlight);\n\t\t\t}\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin);\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tcanvasGradient.addColorStop(\n\t\t\t\t\t\toffset == null ? i / (l - 1) : offset,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && Base.isPlainObject(stops)) {\n\t\t\tthis.set(stops);\n\t\t\tstops = radial = null;\n\t\t}\n\t\tif (this._stops == null) {\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t}\n\t\tif (this._radial == null) {\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t\t}\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++) {\n\t\t\tthis._owners[i]._changed();\n\t\t}\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (!this._owners.length)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tstops[i] = this._stops[i].clone();\n\t\t}\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t}\n\t\tvar _stops = this._stops;\n\t\tif (_stops) {\n\t\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t\t_stops[i]._owner = undefined;\n\t\t}\n\t\t_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t_stops[i]._owner = this;\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class) {\n\t\t\tvar stops1 = this._stops,\n\t\t\t\tstops2 = gradient._stops,\n\t\t\t\tlength = stops1.length;\n\t\t\tif (length === stops2.length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (!stops1[i].equals(stops2[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tvar color = arg0,\n\t\t\toffset = arg1;\n\t\tif (typeof arg0 === 'object' && arg1 === undefined) {\n\t\t\tif (Array.isArray(arg0) && typeof arg0[0] !== 'number') {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\toffset = arg0[1];\n\t\t\t} else if ('color' in arg0 || 'offset' in arg0\n\t\t\t\t\t|| 'rampPoint' in arg0) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\toffset = arg0.offset || arg0.rampPoint || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setColor(color);\n\t\tthis.setOffset(offset);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._offset);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar color = this._color,\n\t\t\toffset = this._offset;\n\t\treturn Base.serialize(offset == null ? [color] : [color, offset],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(65);\n\t},\n\n\tgetOffset: function() {\n\t\treturn this._offset;\n\t},\n\n\tsetOffset: function(offset) {\n\t\tthis._offset = offset;\n\t\tthis._changed();\n\t},\n\n\tgetRampPoint: '#getOffset',\n\tsetRampPoint: '#setOffset',\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function() {\n\t\tvar color = Color.read(arguments, 0, { clone: true });\n\t\tif (color)\n\t\t\tcolor._owner = this;\n\t\tthis._color = color;\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._offset == stop._offset\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar itemDefaults = {\n\t\tfillColor: null,\n\t\tfillRule: 'nonzero',\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\tshadowColor: null,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: null\n\t},\n\tgroupDefaults = Base.set({}, itemDefaults, {\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tleading: null,\n\t\tjustification: 'left'\n\t}),\n\ttextDefaults = Base.set({}, groupDefaults, {\n\t\tfillColor: new Color()\n\t}),\n\tflags = {\n\t\tstrokeWidth: 97,\n\t\tstrokeCap: 97,\n\t\tstrokeJoin: 97,\n\t\tstrokeScaling: 105,\n\t\tmiterLimit: 97,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t},\n\titem = {\n\t\tbeans: true\n\t},\n\tfields = {\n\t\t_class: 'Style',\n\t\tbeans: true,\n\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project\n\t\t\t\t\t|| paper.project;\n\t\t\tthis._defaults = !_owner || _owner instanceof Group ? groupDefaults\n\t\t\t\t\t: _owner instanceof TextItem ? textDefaults\n\t\t\t\t\t: itemDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t}\n\t};\n\n\tBase.each(groupDefaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children;\n\t\t\tif (children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath)) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t} else if (key in this._defaults) {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old && old._owner !== undefined)\n\t\t\t\t\t\t\told._owner = undefined;\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tif (value._owner)\n\t\t\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 65);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tvalue;\n\t\t\tif (key in this._defaults && (!children || !children.length\n\t\t\t\t\t|| _dontMerge || owner instanceof CompoundPath)) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone)\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t\tif (value && isColor)\n\t\t\t\t\t\t\tvalue._owner = owner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (children) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tBase.each({\n\t\tFont: 'FontFamily',\n\t\tWindingRule: 'FillRule'\n\t}, function(value, key) {\n\t\tvar get = 'get' + key,\n\t\t\tset = 'set' + key;\n\t\tfields[get] = item[get] = '#get' + value;\n\t\tfields[set] = item[set] = '#set' + value;\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\tfunction compare(style1, style2, secondary) {\n\t\t\tvar values1 = style1._values,\n\t\t\t\tvalues2 = style2._values,\n\t\t\t\tdefaults2 = style2._defaults;\n\t\t\tfor (var key in values1) {\n\t\t\t\tvar value1 = values1[key],\n\t\t\t\t\tvalue2 = values2[key];\n\t\t\t\tif (!(secondary && key in values2) && !Base.equals(value1,\n\t\t\t\t\t\tvalue2 === undefined ? defaults2[key] : value2))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& compare(this, style)\n\t\t\t\t&& compare(style, this, true)\n\t\t\t\t|| false;\n\t},\n\n\thasFill: function() {\n\t\tvar color = this.getFillColor();\n\t\treturn !!color && color.alpha > 0;\n\t},\n\n\thasStroke: function() {\n\t\tvar color = this.getStrokeColor();\n\t\treturn !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\tvar color = this.getShadowColor();\n\t\treturn !!color && color.alpha > 0 && (this.getShadowBlur() > 0\n\t\t\t\t|| !this.getShadowOffset().isZero());\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tisInserted: function(el) {\n\t\t\treturn document.body.contains(el);\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn el && handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.addEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\ttimer;\n\n\tfunction handleCallbacks() {\n\t\tvar functions = callbacks;\n\t\tcallbacks = [];\n\t\tfor (var i = 0, l = functions.length; i < l; i++)\n\t\t\tfunctions[i]();\n\t\trequested = nativeRequest && callbacks.length;\n\t\tif (requested)\n\t\t\tnativeRequest(handleCallbacks);\n\t}\n\n\treturn function(callback) {\n\t\tcallbacks.push(callback);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t}\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t}\n\n\t\tvar size;\n\t\tif (window && element) {\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserDrag: none,\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsize = getCanvasSize();\n\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = new Size(element);\n\t\t\telement = null;\n\t\t}\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window && window.devicePixelRatio || 1;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize = size;\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t\tthis._itemEvents = { native: {}, virtual: {} };\n\t\tthis._autoUpdate = !paper.agent.node;\n\t\tthis._needsUpdate = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tvar project = this._project;\n\t\tif (project._view === this)\n\t\t\tproject._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(\n\t\tItem._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),\n\t\tfunction(name) {\n\t\t\tthis[name] = {};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\tgetAutoUpdate: function() {\n\t\treturn this._autoUpdate;\n\t},\n\n\tsetAutoUpdate: function(autoUpdate) {\n\t\tthis._autoUpdate = autoUpdate;\n\t\tif (autoUpdate)\n\t\t\tthis.requestUpdate();\n\t},\n\n\tupdate: function() {\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\trequestUpdate: function() {\n\t\tif (!this._requested) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (that._animate) {\n\t\t\t\t\tthat.requestUpdate();\n\t\t\t\t\tvar element = that._element;\n\t\t\t\t\tif ((!DomElement.getPrefixed(document, 'hidden')\n\t\t\t\t\t\t\t|| PaperScope.getAttribute(element, 'keepalive')\n\t\t\t\t\t\t\t\t=== 'true') && DomElement.isInView(element)) {\n\t\t\t\t\t\tthat._handleFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (that._autoUpdate)\n\t\t\t\t\tthat.update();\n\t\t\t});\n\t\t\tthis._requested = true;\n\t\t}\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tthis.requestUpdate();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._last ? now - this._last : 0;\n\t\tthis._last = now;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tthis._project._changed(2049);\n\t\tthis._bounds = this._decomposed = undefined;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize.set(size);\n\t\tthis._changed();\n\t\tthis.emit('resize', { size: size, delta: delta });\n\t\tif (this._autoUpdate) {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_setElementSize: function(width, height) {\n\t\tvar element = this._element;\n\t\tif (element) {\n\t\t\tif (element.width !== width)\n\t\t\t\telement.width = width;\n\t\t\tif (element.height !== height)\n\t\t\t\telement.height = height;\n\t\t}\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tisInserted: function() {\n\t\treturn DomElement.isInserted(this._element);\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixels;\n\t\tif (element) {\n\t\t\tvar parent = element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tpixels = parseFloat(pixels);\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\treturn 0;\n\t}\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar value = (rotate ? Base : Point).read(arguments),\n\t\t\tcenter = Point.read(arguments, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getCenter(true)));\n\t};\n}, {\n\t_decompose: function() {\n\t\treturn this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.translate(this.getCenter().subtract(center));\n\t},\n\n\tgetZoom: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling ? (scaling.x + scaling.y) / 2 : 0;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis.transform(new Matrix().scale(zoom / this.getZoom(),\n\t\t\tthis.getCenter()));\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed && decomposed.rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tthis.rotate(rotation - current);\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\tscaling = decomposed && decomposed.scaling;\n\t\treturn scaling\n\t\t\t\t? new LinkedPoint(scaling.x, scaling.y, this, 'setScaling')\n\t\t\t\t: undefined;\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling) {\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.initialize.apply(matrix, arguments);\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._matrix.append(matrix);\n\t},\n\n\tscrollBy: function() {\n\t\tthis.translate(Point.read(arguments).negate());\n\t}\n}), {\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tgetEventPoint: function(event) {\n\t\treturn this.viewToProject(DomEvent.getOffset(event, this._element));\n\t},\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (document && typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\tvar ctor = window ? CanvasView : View;\n\t\t\treturn new ctor(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tif (!window)\n\t\treturn;\n\tvar prevFocus,\n\t\ttempFocus,\n\t\tdragging = false,\n\t\tmouseDown = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[\n\t\t\t\ttarget.getAttribute('id')];\n\t}\n\n\tfunction updateFocus() {\n\t\tvar view = View._focused;\n\t\tif (!view || !view.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tif ((view = View._views[i]).isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, event, point) {\n\t\tview._handleMouseEvent('mousemove', event, point);\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {},\n\t\tdocEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML')) {\n\t\t\t\t\tvar offset = DomEvent.getOffset(event, view._element),\n\t\t\t\t\t\tx = offset.x,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\tax = abs(x),\n\t\t\t\t\t\tmax = 1 << 25,\n\t\t\t\t\t\tdiff = ax - max;\n\t\t\t\t\toffset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n\t\t\t\t\thandleMouseMove(view, event, view.viewToProject(offset));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tscroll: updateFocus\n\t\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event);\n\t\tif (!dragging) {\n\t\t\tdragging = true;\n\t\t\tview._handleMouseEvent('mousedown', event);\n\t\t}\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!mouseDown) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target) {\n\t\t\t\t\tif (view)\n\t\t\t\t\t\thandleMouseMove(view, event);\n\t\t\t\t\tif (!prevFocus)\n\t\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t}\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tif (prevFocus && !prevFocus.isInserted())\n\t\t\t\t\tprevFocus = null;\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tprevFocus = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view)\n\t\t\thandleMouseMove(view, event);\n\t};\n\n\tdocEvents[mousedown] = function() {\n\t\tmouseDown = true;\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (view && dragging)\n\t\t\tview._handleMouseEvent('mouseup', event);\n\t\tmouseDown = dragging = false;\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar called = false,\n\t\tprevented = false,\n\t\tfallbacks = {\n\t\t\tdoubleclick: 'click',\n\t\t\tmousedrag: 'mousemove'\n\t\t},\n\t\twasInView = false,\n\t\toverView,\n\t\tdownPoint,\n\t\tlastPoint,\n\t\tdownItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tclickItem,\n\t\tclickTime,\n\t\tdblClick;\n\n\tfunction emitMouseEvent(obj, target, type, event, point, prevPoint,\n\t\t\tstopItem) {\n\t\tvar stopped = false,\n\t\t\tmouseEvent;\n\n\t\tfunction emit(obj, type) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point,\n\t\t\t\t\t\t\ttarget || obj,\n\t\t\t\t\t\t\tprevPoint ? point.subtract(prevPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent)) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif (mouseEvent.prevented)\n\t\t\t\t\t\tprevented = true;\n\t\t\t\t\tif (mouseEvent.stopped)\n\t\t\t\t\t\treturn stopped = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar fallback = fallbacks[type];\n\t\t\t\tif (fallback)\n\t\t\t\t\treturn emit(obj, fallback);\n\t\t\t}\n\t\t}\n\n\t\twhile (obj && obj !== stopItem) {\n\t\t\tif (emit(obj, type))\n\t\t\t\tbreak;\n\t\t\tobj = obj._parent;\n\t\t}\n\t\treturn stopped;\n\t}\n\n\tfunction emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n\t\tview._project.removeOn(type);\n\t\tprevented = called = false;\n\t\treturn (dragItem && emitMouseEvent(dragItem, null, type, event,\n\t\t\t\t\tpoint, prevPoint)\n\t\t\t|| hitItem && hitItem !== dragItem\n\t\t\t\t&& !hitItem.isDescendant(dragItem)\n\t\t\t\t&& emitMouseEvent(hitItem, null, type, event, point, prevPoint,\n\t\t\t\t\tdragItem)\n\t\t\t|| emitMouseEvent(view, dragItem || hitItem || view, type, event,\n\t\t\t\t\tpoint, prevPoint));\n\t}\n\n\tvar itemEventsMap = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleMouseEvent: function(type, event, point) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\thitItems = itemEvents.native[type],\n\t\t\t\tnativeMove = type === 'mousemove',\n\t\t\t\ttool = this._scope.tool,\n\t\t\t\tview = this;\n\n\t\t\tfunction responds(type) {\n\t\t\t\treturn itemEvents.virtual[type] || view.responds(type)\n\t\t\t\t\t\t|| tool && tool.responds(type);\n\t\t\t}\n\n\t\t\tif (nativeMove && dragging && responds('mousedrag'))\n\t\t\t\ttype = 'mousedrag';\n\t\t\tif (!point)\n\t\t\t\tpoint = this.getEventPoint(event);\n\n\t\t\tvar inView = this.getBounds().contains(point),\n\t\t\t\thit = hitItems && inView && view._project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\thitItem = hit && hit.item || null,\n\t\t\t\thandle = false,\n\t\t\t\tmouse = {};\n\t\t\tmouse[type.substr(5)] = true;\n\n\t\t\tif (hitItems && hitItem !== overItem) {\n\t\t\t\tif (overItem) {\n\t\t\t\t\temitMouseEvent(overItem, null, 'mouseleave', event, point);\n\t\t\t\t}\n\t\t\t\tif (hitItem) {\n\t\t\t\t\temitMouseEvent(hitItem, null, 'mouseenter', event, point);\n\t\t\t\t}\n\t\t\t\toverItem = hitItem;\n\t\t\t}\n\t\t\tif (wasInView ^ inView) {\n\t\t\t\temitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',\n\t\t\t\t\t\tevent, point);\n\t\t\t\toverView = inView ? this : null;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tif ((inView || mouse.drag) && !point.equals(lastPoint)) {\n\t\t\t\temitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',\n\t\t\t\t\t\tevent, point, lastPoint);\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\twasInView = inView;\n\t\t\tif (mouse.down && inView || mouse.up && downPoint) {\n\t\t\t\temitMouseEvents(this, hitItem, type, event, point, downPoint);\n\t\t\t\tif (mouse.down) {\n\t\t\t\t\tdblClick = hitItem === clickItem\n\t\t\t\t\t\t&& (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = clickItem = hitItem;\n\t\t\t\t\tif (!prevented && hitItem) {\n\t\t\t\t\t\tvar item = hitItem;\n\t\t\t\t\t\twhile (item && !item.responds('mousedrag'))\n\t\t\t\t\t\t\titem = item._parent;\n\t\t\t\t\t\tif (item)\n\t\t\t\t\t\t\tdragItem = hitItem;\n\t\t\t\t\t}\n\t\t\t\t\tdownPoint = point;\n\t\t\t\t} else if (mouse.up) {\n\t\t\t\t\tif (!prevented && hitItem === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\temitMouseEvents(this, hitItem, dblClick ? 'doubleclick'\n\t\t\t\t\t\t\t\t: 'click', event, point, downPoint);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t}\n\t\t\t\twasInView = false;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tlastPoint = point;\n\t\t\tif (handle && tool) {\n\t\t\t\tcalled = tool._handleMouseEvent(type, event, point, mouse)\n\t\t\t\t\t|| called;\n\t\t\t}\n\n\t\t\tif (called && !mouse.move || mouse.down && responds('mouseup'))\n\t\t\t\tevent.preventDefault();\n\t\t},\n\n\t\t_handleKeyEvent: function(type, event, key, character) {\n\t\t\tvar scope = this._scope,\n\t\t\t\ttool = scope.tool,\n\t\t\t\tkeyEvent;\n\n\t\t\tfunction emit(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tpaper = scope;\n\t\t\t\t\tobj.emit(type, keyEvent = keyEvent\n\t\t\t\t\t\t\t|| new KeyEvent(type, event, key, character));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isVisible()) {\n\t\t\t\temit(this);\n\t\t\t\tif (tool && tool.responds(type))\n\t\t\t\t\temit(tool);\n\t\t\t}\n\t\t},\n\n\t\t_countItemEvent: function(type, sign) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\tnative = itemEvents.native,\n\t\t\t\tvirtual = itemEvents.virtual;\n\t\t\tfor (var key in itemEventsMap) {\n\t\t\t\tnative[key] = (native[key] || 0)\n\t\t\t\t\t\t+ (itemEventsMap[key][type] || 0) * sign;\n\t\t\t}\n\t\t\tvirtual[type] = (virtual[type] || 0) + sign;\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof window.HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ Base.slice(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tvar ctx = this._context = canvas.getContext('2d');\n\t\tctx.save();\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(ctx,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t\tthis._needsUpdate = true;\n\t},\n\n\tremove: function remove() {\n\t\tthis._context.restore();\n\t\treturn remove.base.call(this);\n\t},\n\n\t_setElementSize: function _setElementSize(width, height) {\n\t\tvar pixelRatio = this._pixelRatio;\n\t\t_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n\t\tif (pixelRatio !== 1) {\n\t\t\tvar element = this._element,\n\t\t\t\tctx = this._context;\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\tctx.save();\n\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetPixelSize: function getPixelSize(size) {\n\t\tvar agent = paper.agent,\n\t\t\tpixels;\n\t\tif (agent && agent.firefox) {\n\t\t\tpixels = getPixelSize.base.call(this, size);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function() {\n\t\tif (!this._needsUpdate)\n\t\t\treturn false;\n\t\tvar project = this._project,\n\t\t\tctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tif (project)\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tthis._needsUpdate = false;\n\t\treturn true;\n\t}\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t\tthis.type = event && event.type;\n\t},\n\n\tprevented: false,\n\tstopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.prevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.stopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetTimeStamp: function() {\n\t\treturn this.event.timeStamp;\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(type, event, key, character) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\tvar keyLookup = {\n\t\t\t'\\t': 'tab',\n\t\t\t' ': 'space',\n\t\t\t'\\b': 'backspace',\n\t\t\t'\\x7f': 'delete',\n\t\t\t'Spacebar': 'space',\n\t\t\t'Del': 'delete',\n\t\t\t'Win': 'meta',\n\t\t\t'Esc': 'escape'\n\t\t},\n\n\t\tcharLookup = {\n\t\t\t'tab': '\\t',\n\t\t\t'space': ' ',\n\t\t\t'enter': '\\r'\n\t\t},\n\n\t\tkeyMap = {},\n\t\tcharMap = {},\n\t\tmetaFixMap,\n\t\tdownKey,\n\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\talt: false,\n\t\t\tmeta: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}).inject({\n\t\t\toption: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.alt;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcommand: {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar agent = paper && paper.agent;\n\t\t\t\t\treturn agent && agent.mac ? this.meta : this.control;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tfunction getKey(event) {\n\t\tvar key = event.key || event.keyIdentifier;\n\t\tkey = /^U\\+/.test(key)\n\t\t\t\t? String.fromCharCode(parseInt(key.substr(2), 16))\n\t\t\t\t: /^Arrow[A-Z]/.test(key) ? key.substr(5)\n\t\t\t\t: key === 'Unidentified'  || key === undefined\n\t\t\t\t\t? String.fromCharCode(event.keyCode)\n\t\t\t\t\t: key;\n\t\treturn keyLookup[key] ||\n\t\t\t\t(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n\t}\n\n\tfunction handleKey(down, key, character, event) {\n\t\tvar type = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharMap[key] = character;\n\t\t} else {\n\t\t\tdelete charMap[key];\n\t\t}\n\t\tif (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar agent = paper && paper.agent;\n\t\t\tif (name === 'meta' && agent && agent.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tmetaFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var k in metaFixMap) {\n\t\t\t\t\t\tif (k in charMap)\n\t\t\t\t\t\t\thandleKey(false, k, metaFixMap[k], event);\n\t\t\t\t\t}\n\t\t\t\t\tmetaFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && metaFixMap) {\n\t\t\tmetaFixMap[key] = character;\n\t\t}\n\t\tif (view) {\n\t\t\tview._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,\n\t\t\t\t\tcharacter);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar key = getKey(event),\n\t\t\t\tagent = paper && paper.agent;\n\t\t\tif (key.length > 1 || agent && (agent.chrome && (event.altKey\n\t\t\t\t\t\t|| agent.mac && event.metaKey\n\t\t\t\t\t\t|| !agent.mac && event.ctrlKey))) {\n\t\t\t\thandleKey(true, key,\n\t\t\t\t\t\tcharLookup[key] || (key.length > 1 ? '' : key), event);\n\t\t\t} else {\n\t\t\t\tdownKey = key;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downKey) {\n\t\t\t\tvar key = getKey(event),\n\t\t\t\t\tcode = event.charCode,\n\t\t\t\t\tcharacter = code >= 32 ? String.fromCharCode(code)\n\t\t\t\t\t\t: key.length > 1 ? '' : key;\n\t\t\t\tif (key !== downKey) {\n\t\t\t\t\tkey = character.toLowerCase();\n\t\t\t\t}\n\t\t\t\thandleKey(true, key, character, event);\n\t\t\t\tdownKey = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar key = getKey(event);\n\t\t\tif (key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn this.tool[/^mouse(down|up)$/.test(this.type)\n\t\t\t\t? '_downCount' : '_moveCount'];\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',\n\t\t\t'onKeyUp'],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._moveCount = -1;\n\t\tthis._downCount = -1;\n\t\tthis.set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_handleMouseEvent: function(type, event, point, mouse) {\n\t\tpaper = this._scope;\n\t\tif (mouse.drag && !this.responds(type))\n\t\t\ttype = 'mousemove';\n\t\tvar move = mouse.move || mouse.drag,\n\t\t\tresponds = this.responds(type),\n\t\t\tminDistance = this.minDistance,\n\t\t\tmaxDistance = this.maxDistance,\n\t\t\tcalled = false,\n\t\t\ttool = this;\n\t\tfunction update(minDistance, maxDistance) {\n\t\t\tvar pt = point,\n\t\t\t\ttoolPoint = move ? tool._point : (tool._downPoint || pt);\n\t\t\tif (move) {\n\t\t\t\tif (tool._moveCount && pt.equals(toolPoint)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (toolPoint && (minDistance != null || maxDistance != null)) {\n\t\t\t\t\tvar vector = pt.subtract(toolPoint),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < (minDistance || 0))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance) {\n\t\t\t\t\t\tpt = toolPoint.add(vector.normalize(\n\t\t\t\t\t\t\t\tMath.min(distance, maxDistance)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttool._moveCount++;\n\t\t\t}\n\t\t\ttool._point = pt;\n\t\t\ttool._lastPoint = toolPoint || pt;\n\t\t\tif (mouse.down) {\n\t\t\t\ttool._moveCount = -1;\n\t\t\t\ttool._downPoint = pt;\n\t\t\t\ttool._downCount++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction emit() {\n\t\t\tif (responds) {\n\t\t\t\tcalled = tool.emit(type, new ToolEvent(tool, type, event))\n\t\t\t\t\t\t|| called;\n\t\t\t}\n\t\t}\n\n\t\tif (mouse.down) {\n\t\t\tupdate();\n\t\t\temit();\n\t\t} else if (mouse.up) {\n\t\t\tupdate(null, maxDistance);\n\t\t\temit();\n\t\t} else if (responds) {\n\t\t\twhile (update(minDistance, maxDistance))\n\t\t\t\temit();\n\t\t}\n\t\treturn called;\n\t}\n\n});\n\nvar Http = {\n\trequest: function(options) {\n\t\tvar xhr = new self.XMLHttpRequest();\n\t\txhr.open((options.method || 'get').toUpperCase(), options.url,\n\t\t\t\tBase.pick(options.async, true));\n\t\tif (options.mimeType)\n\t\t\txhr.overrideMimeType(options.mimeType);\n\t\txhr.onload = function() {\n\t\t\tvar status = xhr.status;\n\t\t\tif (status === 0 || status === 200) {\n\t\t\t\tif (options.onLoad) {\n\t\t\t\t\toptions.onLoad.call(xhr, xhr.responseText);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txhr.onerror();\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tvar status = xhr.status,\n\t\t\t\tmessage = 'Could not load \"' + options.url + '\" (Status: '\n\t\t\t\t\t\t+ status + ')';\n\t\t\tif (options.onError) {\n\t\t\t\toptions.onError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height) {\n\t\tif (!window)\n\t\t\treturn null;\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tclear = false;\n\t\t}\n\t\tvar ctx = canvas.getContext('2d');\n\t\tif (!ctx) {\n\t\t\tthrow new Error('Canvas ' + canvas +\n\t\t\t\t\t' is unable to provide a 2D context.');\n\t\t}\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height) {\n\t\tvar canvas = this.getCanvas(width, height);\n\t\treturn canvas ? canvas.getContext('2d') : null;\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj && obj.canvas ? obj.canvas : obj;\n\t\tif (canvas && canvas.getContext) {\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1);\n\tif (ctx) {\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken\n\t\t\t\t\t\t\t? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t}\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SvgElement = new function() {\n\tvar svg = 'http://www.w3.org/2000/svg',\n\t\txmlns = 'http://www.w3.org/2000/xmlns',\n\t\txlink = 'http://www.w3.org/1999/xlink',\n\t\tattributeNamespace = {\n\t\t\thref: xlink,\n\t\t\txlink: xmlns,\n\t\t\txmlns: xmlns + '/',\n\t\t\t'xmlns:xlink': xmlns + '/'\n\t\t};\n\n\tfunction create(tag, attributes, formatter) {\n\t\treturn set(document.createElementNS(svg, tag), attributes, formatter);\n\t}\n\n\tfunction get(node, name) {\n\t\tvar namespace = attributeNamespace[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\treturn value === 'null' ? null : value;\n\t}\n\n\tfunction set(node, attributes, formatter) {\n\t\tfor (var name in attributes) {\n\t\t\tvar value = attributes[name],\n\t\t\t\tnamespace = attributeNamespace[name];\n\t\t\tif (typeof value === 'number' && formatter)\n\t\t\t\tvalue = formatter.number(value);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, name, value);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\treturn {\n\t\tsvg: svg,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\n\t\tcreate: create,\n\t\tget: get,\n\t\tset: set\n\t};\n};\n\nvar SvgStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tfillRule: ['fill-rule', 'string'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'style']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nnew function() {\n\tvar formatter;\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tmatrix = matrix._shiftless();\n\t\t\tvar point = matrix._inverseTransform(trans);\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t\ttrans = null;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling,\n\t\t\t\t\tskew = decomposed.skewing;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (skew.x)\n\t\t\t\t\tparts.push('skewX(' + formatter.number(skew.x) + ')');\n\t\t\t\tif (skew.y)\n\t\t\t\t\tparts.push('skewY(' + formatter.number(skew.y) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = SvgElement.create('g', attrs, formatter);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = SvgElement.create('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tSvgElement.set(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages == false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn SvgElement.create('image', attrs, formatter);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\tlength = segments.length,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (matchShapes && length >= 2 && !item.hasHandles()) {\n\t\t\tif (length > 2) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t}\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar start = segments[0]._point,\n\t\t\t\t\tend = segments[1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: end.x,\n\t\t\t\t\ty2: end.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn SvgElement.create('path', attrs, formatter);\n\t}\n\n\tfunction exportSymbolItem(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tdefinition = item._definition,\n\t\t\tnode = getDefinition(definition, 'symbol'),\n\t\t\tdefinitionItem = definition._item,\n\t\t\tbounds = definitionItem.getBounds();\n\t\tif (!node) {\n\t\t\tnode = SvgElement.create('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tnode.appendChild(exportSVG(definitionItem, options));\n\t\t\tsetDefinition(definition, node, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + node.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = bounds.width;\n\t\tattrs.height = bounds.height;\n\t\tattrs.overflow = 'visible';\n\t\treturn SvgElement.create('use', attrs, formatter);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin(),\n\t\t\t\tdestination = color.getDestination(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = SvgElement.create((radial ? 'radial' : 'linear')\n\t\t\t\t\t+ 'Gradient', attrs, formatter);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha(),\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: offset == null ? i / (l - 1) : offset\n\t\t\t\t};\n\t\t\t\tif (stopColor)\n\t\t\t\t\tattrs['stop-color'] = stopColor.toCSS(true);\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(\n\t\t\t\t\t\tSvgElement.create('stop', attrs, formatter));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = SvgElement.create('text', getTransform(item._matrix, true),\n\t\t\t\tformatter);\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tSymbolItem: exportSymbolItem,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent(),\n\t\t\tstyle = [];\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SvgStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tif (type === 'style') {\n\t\t\t\t\tstyle.push(entry.attribute + ': ' + value);\n\t\t\t\t} else {\n\t\t\t\t\tattrs[entry.attribute] = value == null ? 'none'\n\t\t\t\t\t\t\t: type === 'color' ? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array' ? value.join(',')\n\t\t\t\t\t\t\t: type === 'lookup' ? entry.toSVG[value]\n\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (style.length)\n\t\t\tattrs.style = style.join(';');\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn SvgElement.set(node, attrs, formatter);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-'\n\t\t\t\t+ (item._id || item.__id || (item.__id = UID.get('svg')))];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + typeId;\n\t\tdefinitions.svgs[type + '-' + (item._id || item.__id)] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = SvgElement.create('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(SvgElement.create('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new self.XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar children = this._children,\n\t\t\t\tview = this.getView(),\n\t\t\t\tbounds = Base.pick(options.bounds, 'view'),\n\t\t\t\tmx = options.matrix || bounds === 'view' && view._matrix,\n\t\t\t\tmatrix = mx && Matrix.read([mx]),\n\t\t\t\trect = bounds === 'view'\n\t\t\t\t\t? new Rectangle([0, 0], view.getViewSize())\n\t\t\t\t\t: bounds === 'content'\n\t\t\t\t\t\t? Item._getBounds(children, matrix, { stroke: true })\n\t\t\t\t\t\t\t.rect\n\t\t\t\t\t\t: Rectangle.read([bounds], 0, { readNull: true }),\n\t\t\t\tattrs = {\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: SvgElement.svg,\n\t\t\t\t\t'xmlns:xlink': SvgElement.xlink,\n\t\t\t\t};\n\t\t\tif (rect) {\n\t\t\t\tattrs.width = rect.width;\n\t\t\t\tattrs.height = rect.height;\n\t\t\t\tif (rect.x || rect.y)\n\t\t\t\t\tattrs.viewBox = formatter.rectangle(rect);\n\t\t\t}\n\t\t\tvar node = SvgElement.create('svg', attrs, formatter),\n\t\t\t\tparent = node;\n\t\t\tif (matrix && !matrix.isIdentity()) {\n\t\t\t\tparent = node.appendChild(SvgElement.create('g',\n\t\t\t\t\t\tgetTransform(matrix), formatter));\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tparent.appendChild(exportSVG(children[i], options, true));\n\t\t\t}\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tvar definitions = {},\n\t\trootSize;\n\n\tfunction getValue(node, name, isString, allowNull, allowPercent) {\n\t\tvar value = SvgElement.get(node, name),\n\t\t\tres = value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString ? '' : 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t\treturn /%\\s*$/.test(value)\n\t\t\t? (res / 100) * (allowPercent ? 1\n\t\t\t\t: rootSize[/x|^width/.test(name) ? 'width' : 'height'])\n\t\t\t: res;\n\t}\n\n\tfunction getPoint(node, x, y, allowNull, allowPercent) {\n\t\tx = getValue(node, x || 'x', false, allowNull, allowPercent);\n\t\ty = getValue(node, y || 'y', false, allowNull, allowPercent);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull, allowPercent) {\n\t\tw = getValue(node, w || 'width', false, allowNull, allowPercent);\n\t\th = getValue(node, h || 'height', false, allowNull, allowPercent);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none' ? null\n\t\t\t\t: type === 'number' ? parseFloat(value)\n\t\t\t\t: type === 'array' ?\n\t\t\t\t\tvalue ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t: type === 'color' ? getDefinition(value) || value\n\t\t\t\t: type === 'lookup' ? lookup[value]\n\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\tisDefs = type === 'defs',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip && !isDefs) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportNode(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& !/^defs$/i.test(childNode.nodeName)\n\t\t\t\t\t&& (child = importNode(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof SymbolDefinition))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || isDefs) {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\treturn PathItem.create(node.getAttribute('d'));\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tradial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t\tif (gradient._radial ^ radial) {\n\t\t\t\tgradient = gradient.clone();\n\t\t\t\tgradient._radial = radial;\n\t\t\t}\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, radial);\n\t\t}\n\t\tvar origin, destination, highlight,\n\t\t\tscaleToBounds = getValue(node, 'gradientUnits', true) !==\n\t\t\t\t'userSpaceOnUse';\n\t\tif (radial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy', false, scaleToBounds);\n\t\t\tdestination = origin.add(\n\t\t\t\t\tgetValue(node, 'r', false, false, scaleToBounds), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1', false, scaleToBounds);\n\t\t\tdestination = getPoint(node, 'x2', 'y2', false, scaleToBounds);\n\t\t}\n\t\tvar color = applyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\tcolor._scaleToBounds = scaleToBounds;\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\treturn importNode(child, options, isRoot);\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node);\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = this._matrix._transformPoint(\n\t\t\t\t\t\tgetPoint(node).add(size.divide(2)));\n\t\t\t\tthis.translate(center);\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new SymbolDefinition(\n\t\t\t\t\timportGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node);\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof SymbolDefinition\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(\n\t\t\t\t\tgetPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\treturn new Shape.Rectangle(new Rectangle(\n\t\t\t\t\t\tgetPoint(node),\n\t\t\t\t\t\tgetSize(node)\n\t\t\t\t\t), getSize(node, 'rx', 'ry'));\n\t\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(\n\t\t\t\t\tgetPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node).add(\n\t\t\t\t\tgetPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t}\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tif (item.transform) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.append(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1], v[2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',\n\t\t\tcolor = item[key] && item[key]();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SvgStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\tif (item[entry.set]) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color') {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tif (color._scaleToBounds) {\n\t\t\t\t\t\t\tvar bounds = item.getBounds();\n\t\t\t\t\t\t\tcolor.transform(new Matrix()\n\t\t\t\t\t\t\t\t.translate(bounds.getPoint())\n\t\t\t\t\t\t\t\t.scale(bounds.getSize()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tif (item.setOffset) {\n\t\t\t\tvar percent = value.match(/(.*)%$/);\n\t\t\t\titem.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n\t\t\t}\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, null, null, true),\n\t\t\t\tgroup,\n\t\t\t\tmatrix;\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? size.divide(rect.getSize()) : 1,\n\t\t\t\tmatrix = new Matrix().scale(scale)\n\t\t\t\t\t\t.translate(rect.getPoint().negate());\n\t\t\t\tgroup = item;\n\t\t\t} else if (item instanceof SymbolDefinition) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tgroup = item._item;\n\t\t\t}\n\t\t\tif (group)  {\n\t\t\t\tif (getAttribute(node, 'overflow', styles) !== 'visible') {\n\t\t\t\t\tvar clip = new Shape.Rectangle(rect);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t\tif (matrix)\n\t\t\t\t\tgroup.transform(matrix);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value ? undefined\n\t\t\t\t: value === 'none' ? null\n\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tif (node.style) {\n\t\t\tvar parent = node.parentNode,\n\t\t\t\tstyles = {\n\t\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\t\tparent: !isRoot && !/^defs$/i.test(parent.tagName)\n\t\t\t\t\t\t\t&& DomElement.getStyles(parent) || {}\n\t\t\t\t};\n\t\t\tBase.each(attributes, function(apply, name) {\n\t\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\t\titem = value !== undefined\n\t\t\t\t\t\t&& apply(item, value, name, node, styles) || item;\n\t\t\t});\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/),\n\t\t\tname = match && match[1],\n\t\t\tres = name && definitions[window\n\t\t\t\t\t? name.replace(window.location.href.split('#')[0] + '#', '')\n\t\t\t\t\t: name];\n\t\tif (res && res._scaleToBounds) {\n\t\t\tres = res.clone();\n\t\t\tres._scaleToBounds = true;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction importNode(node, options, isRoot) {\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\tisElement = type !== '#document',\n\t\t\tbody = document.body,\n\t\t\tcontainer,\n\t\t\tparent,\n\t\t\tnext;\n\t\tif (isRoot && isElement) {\n\t\t\trootSize = paper.getView().getSize();\n\t\t\trootSize = getSize(node, null, null, true) || rootSize;\n\t\t\tcontainer = SvgElement.create('svg', {\n\t\t\t\tstyle: 'stroke-width: 1px; stroke-miterlimit: 10'\n\t\t\t});\n\t\t\tparent = node.parentNode;\n\t\t\tnext = node.nextSibling;\n\t\t\tcontainer.appendChild(node);\n\t\t\tbody.appendChild(container);\n\t\t}\n\t\tvar settings = paper.settings,\n\t\t\tapplyMatrix = settings.applyMatrix,\n\t\t\tinsertItems = settings.insertItems;\n\t\tsettings.applyMatrix = false;\n\t\tsettings.insertItems = false;\n\t\tvar importer = importers[type],\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.insertItems = insertItems;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (isElement && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport,\n\t\t\t\tdata = isElement && node.getAttribute('data-paper-data');\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (container) {\n\t\t\tbody.removeChild(container);\n\t\t\tif (parent) {\n\t\t\t\tif (next) {\n\t\t\t\t\tparent.insertBefore(node, next);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importSVG(source, options, owner) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\toptions = typeof options === 'function' ? { onLoad: options }\n\t\t\t\t: options || {};\n\t\tvar scope = paper,\n\t\t\titem = null;\n\n\t\tfunction onLoad(svg) {\n\t\t\ttry {\n\t\t\t\tvar node = typeof svg === 'object' ? svg : new self.DOMParser()\n\t\t\t\t\t\t.parseFromString(svg, 'image/svg+xml');\n\t\t\t\tif (!node.nodeName) {\n\t\t\t\t\tnode = null;\n\t\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\t\t}\n\t\t\t\tpaper = scope;\n\t\t\t\titem = importNode(node, options, true);\n\t\t\t\tif (!options || options.insert !== false) {\n\t\t\t\t\towner._insertItem(undefined, item);\n\t\t\t\t}\n\t\t\t\tvar onLoad = options.onLoad;\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad(item, svg);\n\t\t\t} catch (e) {\n\t\t\t\tonError(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction onError(message, status) {\n\t\t\tvar onError = options.onError;\n\t\t\tif (onError) {\n\t\t\t\tonError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string' && !/^.*</.test(source)) {\n\t\t\tvar node = document.getElementById(source);\n\t\t\tif (node) {\n\t\t\t\tonLoad(node);\n\t\t\t} else {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: source,\n\t\t\t\t\tasync: true,\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function() {\n\t\t\t\tonLoad(reader.result);\n\t\t\t};\n\t\t\treader.onerror = function() {\n\t\t\t\tonError(reader.error);\n\t\t\t};\n\t\t\treturn reader.readAsText(source);\n\t\t} else {\n\t\t\tonLoad(source);\n\t\t}\n\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = function() {\n\tvar global = this,\n\t\tacorn = global.acorn;\n\tif (!acorn && \"function\" !== 'undefined') {\n\t\ttry { acorn = __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.es.js\"); } catch(e) {}\n\t}\n\tif (!acorn) {\n\t\tvar exports, module;\n\t\tacorn = exports = module = {};\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports);\n  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.acorn || (root.acorn = {}));\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.0\";\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\treturn parseTopLevel(options.program);\n  };\n\n  var defaultOptions = exports.defaultOptions = {\n\tecmaVersion: 5,\n\tstrictSemicolons: false,\n\tallowTrailingCommas: true,\n\tforbidReserved: false,\n\tallowReturnOutsideFunction: false,\n\tlocations: false,\n\tonComment: null,\n\tranges: false,\n\tprogram: null,\n\tsourceFile: null,\n\tdirectSourceFile: null\n  };\n\n  function setOptions(opts) {\n\toptions = opts || {};\n\tfor (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n\t  options[opt] = defaultOptions[opt];\n\tsourceFile = options.sourceFile || null;\n  }\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n\tfor (var line = 1, cur = 0;;) {\n\t  lineBreak.lastIndex = cur;\n\t  var match = lineBreak.exec(input);\n\t  if (match && match.index < offset) {\n\t\t++line;\n\t\tcur = match.index + match[0].length;\n\t  } else break;\n\t}\n\treturn {line: line, column: offset - cur};\n  };\n\n  exports.tokenize = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\n\tvar t = {};\n\tfunction getToken(forceRegexp) {\n\t  lastEnd = tokEnd;\n\t  readToken(forceRegexp);\n\t  t.start = tokStart; t.end = tokEnd;\n\t  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n\t  t.type = tokType; t.value = tokVal;\n\t  return t;\n\t}\n\tgetToken.jumpTo = function(pos, reAllowed) {\n\t  tokPos = pos;\n\t  if (options.locations) {\n\t\ttokCurLine = 1;\n\t\ttokLineStart = lineBreak.lastIndex = 0;\n\t\tvar match;\n\t\twhile ((match = lineBreak.exec(input)) && match.index < pos) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = match.index + match[0].length;\n\t\t}\n\t  }\n\t  tokRegexpAllowed = reAllowed;\n\t  skipSpace();\n\t};\n\treturn getToken;\n  };\n\n  var tokPos;\n\n  var tokStart, tokEnd;\n\n  var tokStartLoc, tokEndLoc;\n\n  var tokType, tokVal;\n\n  var tokRegexpAllowed;\n\n  var tokCurLine, tokLineStart;\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  var inFunction, labels, strict;\n\n  function raise(pos, message) {\n\tvar loc = getLineInfo(input, pos);\n\tmessage += \" (\" + loc.line + \":\" + loc.column + \")\";\n\tvar err = new SyntaxError(message);\n\terr.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n\tthrow err;\n  }\n\n  var empty = [];\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n\t\t\t\t\t  \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n\t\t\t\t\t  \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n\t\t\t\t\t  \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n\t\t\t\t\t  \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n\t\t\t\t\t  \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n\t\t\t\t\t  \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n\t\t\t\t\t  \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n\t\t\t\t\t  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n\t\t\t\t\t  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n\t\t\t\t\t  num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  function makePredicate(words) {\n\twords = words.split(\" \");\n\tvar f = \"\", cats = [];\n\tout: for (var i = 0; i < words.length; ++i) {\n\t  for (var j = 0; j < cats.length; ++j)\n\t\tif (cats[j][0].length == words[i].length) {\n\t\t  cats[j].push(words[i]);\n\t\t  continue out;\n\t\t}\n\t  cats.push([words[i]]);\n\t}\n\tfunction compareTo(arr) {\n\t  if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n\t  f += \"switch(str){\";\n\t  for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n\t  f += \"return true}return false;\";\n\t}\n\n\tif (cats.length > 3) {\n\t  cats.sort(function(a, b) {return b.length - a.length;});\n\t  f += \"switch(str.length){\";\n\t  for (var i = 0; i < cats.length; ++i) {\n\t\tvar cat = cats[i];\n\t\tf += \"case \" + cat[0].length + \":\";\n\t\tcompareTo(cat);\n\t  }\n\t  f += \"}\";\n\n\t} else {\n\t  compareTo(words);\n\t}\n\treturn new Function(\"str\", f);\n  }\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n\tif (code < 65) return code === 36;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n\tif (code < 48) return code === 36;\n\tif (code < 58) return true;\n\tif (code < 65) return false;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  function line_loc_t() {\n\tthis.line = tokCurLine;\n\tthis.column = tokPos - tokLineStart;\n  }\n\n  function initTokenState() {\n\ttokCurLine = 1;\n\ttokPos = tokLineStart = 0;\n\ttokRegexpAllowed = true;\n\tskipSpace();\n  }\n\n  function finishToken(type, val) {\n\ttokEnd = tokPos;\n\tif (options.locations) tokEndLoc = new line_loc_t;\n\ttokType = type;\n\tskipSpace();\n\ttokVal = val;\n\ttokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n\tif (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n\ttokPos = end + 2;\n\tif (options.locations) {\n\t  lineBreak.lastIndex = start;\n\t  var match;\n\t  while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n\t\t++tokCurLine;\n\t\ttokLineStart = match.index + match[0].length;\n\t  }\n\t}\n\tif (options.onComment)\n\t  options.onComment(true, input.slice(start + 2, end), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n\tvar start = tokPos;\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar ch = input.charCodeAt(tokPos+=2);\n\twhile (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n\t  ++tokPos;\n\t  ch = input.charCodeAt(tokPos);\n\t}\n\tif (options.onComment)\n\t  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipSpace() {\n\twhile (tokPos < inputLen) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === 32) {\n\t\t++tokPos;\n\t  } else if (ch === 13) {\n\t\t++tokPos;\n\t\tvar next = input.charCodeAt(tokPos);\n\t\tif (next === 10) {\n\t\t  ++tokPos;\n\t\t}\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch === 10 || ch === 8232 || ch === 8233) {\n\t\t++tokPos;\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch > 8 && ch < 14) {\n\t\t++tokPos;\n\t  } else if (ch === 47) {\n\t\tvar next = input.charCodeAt(tokPos + 1);\n\t\tif (next === 42) {\n\t\t  skipBlockComment();\n\t\t} else if (next === 47) {\n\t\t  skipLineComment();\n\t\t} else break;\n\t  } else if (ch === 160) {\n\t\t++tokPos;\n\t  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t\t++tokPos;\n\t  } else {\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  function readToken_dot() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next >= 48 && next <= 57) return readNumber(true);\n\t++tokPos;\n\treturn finishToken(_dot);\n  }\n\n  function readToken_slash() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (tokRegexpAllowed) {++tokPos; return readRegexp();}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) {\n\t  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n\t\t  newline.test(input.slice(lastEnd, tokPos))) {\n\t\ttokPos += 3;\n\t\tskipLineComment();\n\t\tskipSpace();\n\t\treturn readToken();\n\t  }\n\t  return finishOp(_incDec, 2);\n\t}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tvar size = 1;\n\tif (next === code) {\n\t  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n\t  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n\t  return finishOp(_bitShift, size);\n\t}\n\tif (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n\t\tinput.charCodeAt(tokPos + 3) == 45) {\n\t  tokPos += 4;\n\t  skipLineComment();\n\t  skipSpace();\n\t  return readToken();\n\t}\n\tif (next === 61)\n\t  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n\treturn finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n\treturn finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n\tswitch(code) {\n\tcase 46:\n\t  return readToken_dot();\n\n\tcase 40: ++tokPos; return finishToken(_parenL);\n\tcase 41: ++tokPos; return finishToken(_parenR);\n\tcase 59: ++tokPos; return finishToken(_semi);\n\tcase 44: ++tokPos; return finishToken(_comma);\n\tcase 91: ++tokPos; return finishToken(_bracketL);\n\tcase 93: ++tokPos; return finishToken(_bracketR);\n\tcase 123: ++tokPos; return finishToken(_braceL);\n\tcase 125: ++tokPos; return finishToken(_braceR);\n\tcase 58: ++tokPos; return finishToken(_colon);\n\tcase 63: ++tokPos; return finishToken(_question);\n\n\tcase 48:\n\t  var next = input.charCodeAt(tokPos + 1);\n\t  if (next === 120 || next === 88) return readHexNumber();\n\tcase 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:\n\t  return readNumber(false);\n\n\tcase 34: case 39:\n\t  return readString(code);\n\n\tcase 47:\n\t  return readToken_slash(code);\n\n\tcase 37: case 42:\n\t  return readToken_mult_modulo();\n\n\tcase 124: case 38:\n\t  return readToken_pipe_amp(code);\n\n\tcase 94:\n\t  return readToken_caret();\n\n\tcase 43: case 45:\n\t  return readToken_plus_min(code);\n\n\tcase 60: case 62:\n\t  return readToken_lt_gt(code);\n\n\tcase 61: case 33:\n\t  return readToken_eq_excl(code);\n\n\tcase 126:\n\t  return finishOp(_prefix, 1);\n\t}\n\n\treturn false;\n  }\n\n  function readToken(forceRegexp) {\n\tif (!forceRegexp) tokStart = tokPos;\n\telse tokPos = tokStart + 1;\n\tif (options.locations) tokStartLoc = new line_loc_t;\n\tif (forceRegexp) return readRegexp();\n\tif (tokPos >= inputLen) return finishToken(_eof);\n\n\tvar code = input.charCodeAt(tokPos);\n\tif (isIdentifierStart(code) || code === 92 ) return readWord();\n\n\tvar tok = getTokenFromCode(code);\n\n\tif (tok === false) {\n\t  var ch = String.fromCharCode(code);\n\t  if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n\t  raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n\t}\n\treturn tok;\n  }\n\n  function finishOp(type, size) {\n\tvar str = input.slice(tokPos, tokPos + size);\n\ttokPos += size;\n\tfinishToken(type, str);\n  }\n\n  function readRegexp() {\n\tvar content = \"\", escaped, inClass, start = tokPos;\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n\t  var ch = input.charAt(tokPos);\n\t  if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n\t  if (!escaped) {\n\t\tif (ch === \"[\") inClass = true;\n\t\telse if (ch === \"]\" && inClass) inClass = false;\n\t\telse if (ch === \"/\" && !inClass) break;\n\t\tescaped = ch === \"\\\\\";\n\t  } else escaped = false;\n\t  ++tokPos;\n\t}\n\tvar content = input.slice(start, tokPos);\n\t++tokPos;\n\tvar mods = readWord1();\n\tif (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n\ttry {\n\t  var value = new RegExp(content, mods);\n\t} catch (e) {\n\t  if (e instanceof SyntaxError) raise(start, e.message);\n\t  raise(e);\n\t}\n\treturn finishToken(_regexp, value);\n  }\n\n  function readInt(radix, len) {\n\tvar start = tokPos, total = 0;\n\tfor (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t  var code = input.charCodeAt(tokPos), val;\n\t  if (code >= 97) val = code - 97 + 10;\n\t  else if (code >= 65) val = code - 65 + 10;\n\t  else if (code >= 48 && code <= 57) val = code - 48;\n\t  else val = Infinity;\n\t  if (val >= radix) break;\n\t  ++tokPos;\n\t  total = total * radix + val;\n\t}\n\tif (tokPos === start || len != null && tokPos - start !== len) return null;\n\n\treturn total;\n  }\n\n  function readHexNumber() {\n\ttokPos += 2;\n\tvar val = readInt(16);\n\tif (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\treturn finishToken(_num, val);\n  }\n\n  function readNumber(startsWithDot) {\n\tvar start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n\tif (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n\tif (input.charCodeAt(tokPos) === 46) {\n\t  ++tokPos;\n\t  readInt(10);\n\t  isFloat = true;\n\t}\n\tvar next = input.charCodeAt(tokPos);\n\tif (next === 69 || next === 101) {\n\t  next = input.charCodeAt(++tokPos);\n\t  if (next === 43 || next === 45) ++tokPos;\n\t  if (readInt(10) === null) raise(start, \"Invalid number\");\n\t  isFloat = true;\n\t}\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n\tvar str = input.slice(start, tokPos), val;\n\tif (isFloat) val = parseFloat(str);\n\telse if (!octal || str.length === 1) val = parseInt(str, 10);\n\telse if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n\telse val = parseInt(str, 8);\n\treturn finishToken(_num, val);\n  }\n\n  function readString(quote) {\n\ttokPos++;\n\tvar out = \"\";\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === quote) {\n\t\t++tokPos;\n\t\treturn finishToken(_string, out);\n\t  }\n\t  if (ch === 92) {\n\t\tch = input.charCodeAt(++tokPos);\n\t\tvar octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n\t\tif (octal) octal = octal[0];\n\t\twhile (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n\t\tif (octal === \"0\") octal = null;\n\t\t++tokPos;\n\t\tif (octal) {\n\t\t  if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n\t\t  out += String.fromCharCode(parseInt(octal, 8));\n\t\t  tokPos += octal.length - 1;\n\t\t} else {\n\t\t  switch (ch) {\n\t\t  case 110: out += \"\\n\"; break;\n\t\t  case 114: out += \"\\r\"; break;\n\t\t  case 120: out += String.fromCharCode(readHexChar(2)); break;\n\t\t  case 117: out += String.fromCharCode(readHexChar(4)); break;\n\t\t  case 85: out += String.fromCharCode(readHexChar(8)); break;\n\t\t  case 116: out += \"\\t\"; break;\n\t\t  case 98: out += \"\\b\"; break;\n\t\t  case 118: out += \"\\u000b\"; break;\n\t\t  case 102: out += \"\\f\"; break;\n\t\t  case 48: out += \"\\0\"; break;\n\t\t  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;\n\t\t  case 10:\n\t\t\tif (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n\t\t\tbreak;\n\t\t  default: out += String.fromCharCode(ch); break;\n\t\t  }\n\t\t}\n\t  } else {\n\t\tif (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n\t\tout += String.fromCharCode(ch);\n\t\t++tokPos;\n\t  }\n\t}\n  }\n\n  function readHexChar(len) {\n\tvar n = readInt(16, len);\n\tif (n === null) raise(tokStart, \"Bad character escape sequence\");\n\treturn n;\n  }\n\n  var containsEsc;\n\n  function readWord1() {\n\tcontainsEsc = false;\n\tvar word, first = true, start = tokPos;\n\tfor (;;) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (isIdentifierChar(ch)) {\n\t\tif (containsEsc) word += input.charAt(tokPos);\n\t\t++tokPos;\n\t  } else if (ch === 92) {\n\t\tif (!containsEsc) word = input.slice(start, tokPos);\n\t\tcontainsEsc = true;\n\t\tif (input.charCodeAt(++tokPos) != 117)\n\t\t  raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n\t\t++tokPos;\n\t\tvar esc = readHexChar(4);\n\t\tvar escStr = String.fromCharCode(esc);\n\t\tif (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n\t\tif (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n\t\t  raise(tokPos - 4, \"Invalid Unicode escape\");\n\t\tword += escStr;\n\t  } else {\n\t\tbreak;\n\t  }\n\t  first = false;\n\t}\n\treturn containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  function readWord() {\n\tvar word = readWord1();\n\tvar type = _name;\n\tif (!containsEsc && isKeyword(word))\n\t  type = keywordTypes[word];\n\treturn finishToken(type, word);\n  }\n\n  function next() {\n\tlastStart = tokStart;\n\tlastEnd = tokEnd;\n\tlastEndLoc = tokEndLoc;\n\treadToken();\n  }\n\n  function setStrict(strct) {\n\tstrict = strct;\n\ttokPos = tokStart;\n\tif (options.locations) {\n\t  while (tokPos < tokLineStart) {\n\t\ttokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n\t\t--tokCurLine;\n\t  }\n\t}\n\tskipSpace();\n\treadToken();\n  }\n\n  function node_t() {\n\tthis.type = null;\n\tthis.start = tokStart;\n\tthis.end = null;\n  }\n\n  function node_loc_t() {\n\tthis.start = tokStartLoc;\n\tthis.end = null;\n\tif (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n\tvar node = new node_t();\n\tif (options.locations)\n\t  node.loc = new node_loc_t();\n\tif (options.directSourceFile)\n\t  node.sourceFile = options.directSourceFile;\n\tif (options.ranges)\n\t  node.range = [tokStart, 0];\n\treturn node;\n  }\n\n  function startNodeFrom(other) {\n\tvar node = new node_t();\n\tnode.start = other.start;\n\tif (options.locations) {\n\t  node.loc = new node_loc_t();\n\t  node.loc.start = other.loc.start;\n\t}\n\tif (options.ranges)\n\t  node.range = [other.range[0], 0];\n\n\treturn node;\n  }\n\n  function finishNode(node, type) {\n\tnode.type = type;\n\tnode.end = lastEnd;\n\tif (options.locations)\n\t  node.loc.end = lastEndLoc;\n\tif (options.ranges)\n\t  node.range[1] = lastEnd;\n\treturn node;\n  }\n\n  function isUseStrict(stmt) {\n\treturn options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n\t  stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  function eat(type) {\n\tif (tokType === type) {\n\t  next();\n\t  return true;\n\t}\n  }\n\n  function canInsertSemicolon() {\n\treturn !options.strictSemicolons &&\n\t  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  function semicolon() {\n\tif (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  function expect(type) {\n\tif (tokType === type) next();\n\telse unexpected();\n  }\n\n  function unexpected() {\n\traise(tokStart, \"Unexpected token\");\n  }\n\n  function checkLVal(expr) {\n\tif (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n\t  raise(expr.start, \"Assigning to rvalue\");\n\tif (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n\t  raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  function parseTopLevel(program) {\n\tlastStart = lastEnd = tokPos;\n\tif (options.locations) lastEndLoc = new line_loc_t;\n\tinFunction = strict = null;\n\tlabels = [];\n\treadToken();\n\n\tvar node = program || startNode(), first = true;\n\tif (!program) node.body = [];\n\twhile (tokType !== _eof) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && isUseStrict(stmt)) setStrict(true);\n\t  first = false;\n\t}\n\treturn finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  function parseStatement() {\n\tif (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n\t  readToken(true);\n\n\tvar starttype = tokType, node = startNode();\n\n\tswitch (starttype) {\n\tcase _break: case _continue:\n\t  next();\n\t  var isBreak = starttype === _break;\n\t  if (eat(_semi) || canInsertSemicolon()) node.label = null;\n\t  else if (tokType !== _name) unexpected();\n\t  else {\n\t\tnode.label = parseIdent();\n\t\tsemicolon();\n\t  }\n\n\t  for (var i = 0; i < labels.length; ++i) {\n\t\tvar lab = labels[i];\n\t\tif (node.label == null || lab.name === node.label.name) {\n\t\t  if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n\t\t  if (node.label && isBreak) break;\n\t\t}\n\t  }\n\t  if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n\t  return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n\tcase _debugger:\n\t  next();\n\t  semicolon();\n\t  return finishNode(node, \"DebuggerStatement\");\n\n\tcase _do:\n\t  next();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  expect(_while);\n\t  node.test = parseParenExpression();\n\t  semicolon();\n\t  return finishNode(node, \"DoWhileStatement\");\n\n\tcase _for:\n\t  next();\n\t  labels.push(loopLabel);\n\t  expect(_parenL);\n\t  if (tokType === _semi) return parseFor(node, null);\n\t  if (tokType === _var) {\n\t\tvar init = startNode();\n\t\tnext();\n\t\tparseVar(init, true);\n\t\tfinishNode(init, \"VariableDeclaration\");\n\t\tif (init.declarations.length === 1 && eat(_in))\n\t\t  return parseForIn(node, init);\n\t\treturn parseFor(node, init);\n\t  }\n\t  var init = parseExpression(false, true);\n\t  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n\t  return parseFor(node, init);\n\n\tcase _function:\n\t  next();\n\t  return parseFunction(node, true);\n\n\tcase _if:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  node.consequent = parseStatement();\n\t  node.alternate = eat(_else) ? parseStatement() : null;\n\t  return finishNode(node, \"IfStatement\");\n\n\tcase _return:\n\t  if (!inFunction && !options.allowReturnOutsideFunction)\n\t\traise(tokStart, \"'return' outside of function\");\n\t  next();\n\n\t  if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n\t  else { node.argument = parseExpression(); semicolon(); }\n\t  return finishNode(node, \"ReturnStatement\");\n\n\tcase _switch:\n\t  next();\n\t  node.discriminant = parseParenExpression();\n\t  node.cases = [];\n\t  expect(_braceL);\n\t  labels.push(switchLabel);\n\n\t  for (var cur, sawDefault; tokType != _braceR;) {\n\t\tif (tokType === _case || tokType === _default) {\n\t\t  var isCase = tokType === _case;\n\t\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t\t  node.cases.push(cur = startNode());\n\t\t  cur.consequent = [];\n\t\t  next();\n\t\t  if (isCase) cur.test = parseExpression();\n\t\t  else {\n\t\t\tif (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n\t\t\tcur.test = null;\n\t\t  }\n\t\t  expect(_colon);\n\t\t} else {\n\t\t  if (!cur) unexpected();\n\t\t  cur.consequent.push(parseStatement());\n\t\t}\n\t  }\n\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t  next();\n\t  labels.pop();\n\t  return finishNode(node, \"SwitchStatement\");\n\n\tcase _throw:\n\t  next();\n\t  if (newline.test(input.slice(lastEnd, tokStart)))\n\t\traise(lastEnd, \"Illegal newline after throw\");\n\t  node.argument = parseExpression();\n\t  semicolon();\n\t  return finishNode(node, \"ThrowStatement\");\n\n\tcase _try:\n\t  next();\n\t  node.block = parseBlock();\n\t  node.handler = null;\n\t  if (tokType === _catch) {\n\t\tvar clause = startNode();\n\t\tnext();\n\t\texpect(_parenL);\n\t\tclause.param = parseIdent();\n\t\tif (strict && isStrictBadIdWord(clause.param.name))\n\t\t  raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n\t\texpect(_parenR);\n\t\tclause.guard = null;\n\t\tclause.body = parseBlock();\n\t\tnode.handler = finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.guardedHandlers = empty;\n\t  node.finalizer = eat(_finally) ? parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t\traise(node.start, \"Missing catch or finally clause\");\n\t  return finishNode(node, \"TryStatement\");\n\n\tcase _var:\n\t  next();\n\t  parseVar(node);\n\t  semicolon();\n\t  return finishNode(node, \"VariableDeclaration\");\n\n\tcase _while:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  return finishNode(node, \"WhileStatement\");\n\n\tcase _with:\n\t  if (strict) raise(tokStart, \"'with' in strict mode\");\n\t  next();\n\t  node.object = parseParenExpression();\n\t  node.body = parseStatement();\n\t  return finishNode(node, \"WithStatement\");\n\n\tcase _braceL:\n\t  return parseBlock();\n\n\tcase _semi:\n\t  next();\n\t  return finishNode(node, \"EmptyStatement\");\n\n\tdefault:\n\t  var maybeName = tokVal, expr = parseExpression();\n\t  if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n\t\tfor (var i = 0; i < labels.length; ++i)\n\t\t  if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t\tvar kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n\t\tlabels.push({name: maybeName, kind: kind});\n\t\tnode.body = parseStatement();\n\t\tlabels.pop();\n\t\tnode.label = expr;\n\t\treturn finishNode(node, \"LabeledStatement\");\n\t  } else {\n\t\tnode.expression = expr;\n\t\tsemicolon();\n\t\treturn finishNode(node, \"ExpressionStatement\");\n\t  }\n\t}\n  }\n\n  function parseParenExpression() {\n\texpect(_parenL);\n\tvar val = parseExpression();\n\texpect(_parenR);\n\treturn val;\n  }\n\n  function parseBlock(allowStrict) {\n\tvar node = startNode(), first = true, strict = false, oldStrict;\n\tnode.body = [];\n\texpect(_braceL);\n\twhile (!eat(_braceR)) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && allowStrict && isUseStrict(stmt)) {\n\t\toldStrict = strict;\n\t\tsetStrict(strict = true);\n\t  }\n\t  first = false;\n\t}\n\tif (strict && !oldStrict) setStrict(false);\n\treturn finishNode(node, \"BlockStatement\");\n  }\n\n  function parseFor(node, init) {\n\tnode.init = init;\n\texpect(_semi);\n\tnode.test = tokType === _semi ? null : parseExpression();\n\texpect(_semi);\n\tnode.update = tokType === _parenR ? null : parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForStatement\");\n  }\n\n  function parseForIn(node, init) {\n\tnode.left = init;\n\tnode.right = parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForInStatement\");\n  }\n\n  function parseVar(node, noIn) {\n\tnode.declarations = [];\n\tnode.kind = \"var\";\n\tfor (;;) {\n\t  var decl = startNode();\n\t  decl.id = parseIdent();\n\t  if (strict && isStrictBadIdWord(decl.id.name))\n\t\traise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n\t  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n\t  node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n\t  if (!eat(_comma)) break;\n\t}\n\treturn node;\n  }\n\n  function parseExpression(noComma, noIn) {\n\tvar expr = parseMaybeAssign(noIn);\n\tif (!noComma && tokType === _comma) {\n\t  var node = startNodeFrom(expr);\n\t  node.expressions = [expr];\n\t  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n\t  return finishNode(node, \"SequenceExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseMaybeAssign(noIn) {\n\tvar left = parseMaybeConditional(noIn);\n\tif (tokType.isAssign) {\n\t  var node = startNodeFrom(left);\n\t  node.operator = tokVal;\n\t  node.left = left;\n\t  next();\n\t  node.right = parseMaybeAssign(noIn);\n\t  checkLVal(left);\n\t  return finishNode(node, \"AssignmentExpression\");\n\t}\n\treturn left;\n  }\n\n  function parseMaybeConditional(noIn) {\n\tvar expr = parseExprOps(noIn);\n\tif (eat(_question)) {\n\t  var node = startNodeFrom(expr);\n\t  node.test = expr;\n\t  node.consequent = parseExpression(true);\n\t  expect(_colon);\n\t  node.alternate = parseExpression(true, noIn);\n\t  return finishNode(node, \"ConditionalExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprOps(noIn) {\n\treturn parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  function parseExprOp(left, minPrec, noIn) {\n\tvar prec = tokType.binop;\n\tif (prec != null && (!noIn || tokType !== _in)) {\n\t  if (prec > minPrec) {\n\t\tvar node = startNodeFrom(left);\n\t\tnode.left = left;\n\t\tnode.operator = tokVal;\n\t\tvar op = tokType;\n\t\tnext();\n\t\tnode.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n\t\tvar exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n\t\treturn parseExprOp(exprNode, minPrec, noIn);\n\t  }\n\t}\n\treturn left;\n  }\n\n  function parseMaybeUnary() {\n\tif (tokType.prefix) {\n\t  var node = startNode(), update = tokType.isUpdate;\n\t  node.operator = tokVal;\n\t  node.prefix = true;\n\t  tokRegexpAllowed = true;\n\t  next();\n\t  node.argument = parseMaybeUnary();\n\t  if (update) checkLVal(node.argument);\n\t  else if (strict && node.operator === \"delete\" &&\n\t\t\t   node.argument.type === \"Identifier\")\n\t\traise(node.start, \"Deleting local variable in strict mode\");\n\t  return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t}\n\tvar expr = parseExprSubscripts();\n\twhile (tokType.postfix && !canInsertSemicolon()) {\n\t  var node = startNodeFrom(expr);\n\t  node.operator = tokVal;\n\t  node.prefix = false;\n\t  node.argument = expr;\n\t  checkLVal(expr);\n\t  next();\n\t  expr = finishNode(node, \"UpdateExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprSubscripts() {\n\treturn parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n\tif (eat(_dot)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseIdent(true);\n\t  node.computed = false;\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (eat(_bracketL)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseExpression();\n\t  node.computed = true;\n\t  expect(_bracketR);\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (!noCalls && eat(_parenL)) {\n\t  var node = startNodeFrom(base);\n\t  node.callee = base;\n\t  node.arguments = parseExprList(_parenR, false);\n\t  return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n\t} else return base;\n  }\n\n  function parseExprAtom() {\n\tswitch (tokType) {\n\tcase _this:\n\t  var node = startNode();\n\t  next();\n\t  return finishNode(node, \"ThisExpression\");\n\tcase _name:\n\t  return parseIdent();\n\tcase _num: case _string: case _regexp:\n\t  var node = startNode();\n\t  node.value = tokVal;\n\t  node.raw = input.slice(tokStart, tokEnd);\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _null: case _true: case _false:\n\t  var node = startNode();\n\t  node.value = tokType.atomValue;\n\t  node.raw = tokType.keyword;\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _parenL:\n\t  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n\t  next();\n\t  var val = parseExpression();\n\t  val.start = tokStart1;\n\t  val.end = tokEnd;\n\t  if (options.locations) {\n\t\tval.loc.start = tokStartLoc1;\n\t\tval.loc.end = tokEndLoc;\n\t  }\n\t  if (options.ranges)\n\t\tval.range = [tokStart1, tokEnd];\n\t  expect(_parenR);\n\t  return val;\n\n\tcase _bracketL:\n\t  var node = startNode();\n\t  next();\n\t  node.elements = parseExprList(_bracketR, true, true);\n\t  return finishNode(node, \"ArrayExpression\");\n\n\tcase _braceL:\n\t  return parseObj();\n\n\tcase _function:\n\t  var node = startNode();\n\t  next();\n\t  return parseFunction(node, false);\n\n\tcase _new:\n\t  return parseNew();\n\n\tdefault:\n\t  unexpected();\n\t}\n  }\n\n  function parseNew() {\n\tvar node = startNode();\n\tnext();\n\tnode.callee = parseSubscripts(parseExprAtom(), true);\n\tif (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n\telse node.arguments = empty;\n\treturn finishNode(node, \"NewExpression\");\n  }\n\n  function parseObj() {\n\tvar node = startNode(), first = true, sawGetSet = false;\n\tnode.properties = [];\n\tnext();\n\twhile (!eat(_braceR)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (options.allowTrailingCommas && eat(_braceR)) break;\n\t  } else first = false;\n\n\t  var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n\t  if (eat(_colon)) {\n\t\tprop.value = parseExpression(true);\n\t\tkind = prop.kind = \"init\";\n\t  } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n\t\t\t\t (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n\t\tisGetSet = sawGetSet = true;\n\t\tkind = prop.kind = prop.key.name;\n\t\tprop.key = parsePropertyName();\n\t\tif (tokType !== _parenL) unexpected();\n\t\tprop.value = parseFunction(startNode(), false);\n\t  } else unexpected();\n\n\t  if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n\t\tfor (var i = 0; i < node.properties.length; ++i) {\n\t\t  var other = node.properties[i];\n\t\t  if (other.key.name === prop.key.name) {\n\t\t\tvar conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n\t\t\t  kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n\t\t\tif (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n\t\t\tif (conflict) raise(prop.key.start, \"Redefinition of property\");\n\t\t  }\n\t\t}\n\t  }\n\t  node.properties.push(prop);\n\t}\n\treturn finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n\tif (tokType === _num || tokType === _string) return parseExprAtom();\n\treturn parseIdent(true);\n  }\n\n  function parseFunction(node, isStatement) {\n\tif (tokType === _name) node.id = parseIdent();\n\telse if (isStatement) unexpected();\n\telse node.id = null;\n\tnode.params = [];\n\tvar first = true;\n\texpect(_parenL);\n\twhile (!eat(_parenR)) {\n\t  if (!first) expect(_comma); else first = false;\n\t  node.params.push(parseIdent());\n\t}\n\n\tvar oldInFunc = inFunction, oldLabels = labels;\n\tinFunction = true; labels = [];\n\tnode.body = parseBlock(true);\n\tinFunction = oldInFunc; labels = oldLabels;\n\n\tif (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n\t  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n\t\tvar id = i < 0 ? node.id : node.params[i];\n\t\tif (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n\t\t  raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n\t\tif (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n\t\t  raise(id.start, \"Argument name clash in strict mode\");\n\t  }\n\t}\n\n\treturn finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n\tvar elts = [], first = true;\n\twhile (!eat(close)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n\t  } else first = false;\n\n\t  if (allowEmpty && tokType === _comma) elts.push(null);\n\t  else elts.push(parseExpression(true));\n\t}\n\treturn elts;\n  }\n\n  function parseIdent(liberal) {\n\tvar node = startNode();\n\tif (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n\tif (tokType === _name) {\n\t  if (!liberal &&\n\t\t  (options.forbidReserved &&\n\t\t   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||\n\t\t   strict && isStrictReservedWord(tokVal)) &&\n\t\t  input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n\t\traise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n\t  node.name = tokVal;\n\t} else if (liberal && tokType.keyword) {\n\t  node.name = tokType.keyword;\n\t} else {\n\t  unexpected();\n\t}\n\ttokRegexpAllowed = false;\n\tnext();\n\treturn finishNode(node, \"Identifier\");\n  }\n\n});\n\n\t\tif (!acorn.version)\n\t\t\tacorn = null;\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn (global.acorn || acorn).parse(code, options);\n\t}\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': '__equals',\n\t\t'!=': '__equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': '__self'\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{\n\t\t\t__self: function() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction compile(code, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction walkAST(node, parent) {\n\t\t\tif (!node)\n\t\t\t\treturn;\n\t\t\tfor (var key in node) {\n\t\t\t\tif (key === 'range' || key === 'loc')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar value = node[key];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++)\n\t\t\t\t\t\twalkAST(value[i], node);\n\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\twalkAST(value, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (!node.prefix\n\t\t\t\t\t\t\t\t&& (parentType === 'AssignmentExpression'\n\t\t\t\t\t\t\t\t\t|| parentType === 'VariableDeclarator')) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\t\texp = left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')';\n\t\t\t\t\t\t\treplaceCode(node, /^\\(.*\\)$/.test(getCode(node))\n\t\t\t\t\t\t\t\t\t? '(' + exp + ')' : exp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction encodeVLQ(value) {\n\t\t\tvar res = '',\n\t\t\t\tbase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\tvalue = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n\t\t\twhile (value || !res) {\n\t\t\t\tvar next = value & (32 - 1);\n\t\t\t\tvalue >>= 5;\n\t\t\t\tif (value)\n\t\t\t\t\tnext |= 32;\n\t\t\t\tres += base64[next];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar url = options.url || '',\n\t\t\tagent = paper.agent,\n\t\t\tversion = agent.versionNumber,\n\t\t\toffsetCode = false,\n\t\t\tsourceMaps = options.sourceMaps,\n\t\t\tsource = options.source || code,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg,\n\t\t\toffset = options.offset || 0,\n\t\t\tmap;\n\t\tif (sourceMaps && (agent.chrome && version >= 30\n\t\t\t\t|| agent.webkit && version >= 537.76\n\t\t\t\t|| agent.firefox && version >= 23\n\t\t\t\t|| agent.node)) {\n\t\t\tif (agent.node) {\n\t\t\t\toffset -= 2;\n\t\t\t} else if (window && url && !window.location.href.indexOf(url)) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\toffsetCode = offset > 0 && !(\n\t\t\t\t\tagent.chrome && version >= 36 ||\n\t\t\t\t\tagent.safari && version >= 600 ||\n\t\t\t\t\tagent.firefox && version >= 40 ||\n\t\t\t\t\tagent.node);\n\t\t\tvar mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1\n\t\t\t\t\t+ (offsetCode ? offset : 0);\n\t\t\tmap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url],\n\t\t\t\tsourcesContent: [source]\n\t\t\t};\n\t\t}\n\t\twalkAST(parse(code, { ranges: true, preserveParens: true }));\n\t\tif (map) {\n\t\t\tif (offsetCode) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code;\n\t\t\t}\n\t\t\tif (/^(inline|both)$/.test(sourceMaps)) {\n\t\t\t\tcode += \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ self.btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(map))));\n\t\t\t}\n\t\t\tcode += \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn {\n\t\t\turl: url,\n\t\t\tsource: source,\n\t\t\tcode: code,\n\t\t\tmap: map\n\t\t};\n\t}\n\n\tfunction execute(code, scope, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/\n\t\t\t\t\t.test(code) && !/\\bnew\\s+Tool\\b/.test(code)\n\t\t\t\t\t\t? new Tool() : null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc,\n\t\t\tcompiled = typeof code === 'object' ? code : compile(code, options);\n\t\tcode = compiled.code;\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\thandlers = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push(key + ': ' + key);\n\t\t\t}\n\t\t}, []).join(', ');\n\t\tif (handlers)\n\t\t\tcode += '\\nreturn { ' + handlers + ' };';\n\t\tvar agent = paper.agent;\n\t\tif (document && (agent.chrome\n\t\t\t\t|| agent.firefox && agent.versionNumber < 40)) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (agent.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'paper._execute = function(' + params + ') {' + code + '\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = paper._execute;\n\t\t\tdelete paper._execute;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar res = func.apply(scope, args) || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = res[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (res.onResize)\n\t\t\t\tview.setOnResize(res.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (res.onFrame)\n\t\t\t\tview.setOnFrame(res.onFrame);\n\t\t\tview.requestUpdate();\n\t\t}\n\t\treturn compiled;\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: src,\n\t\t\t\t\tasync: async,\n\t\t\t\t\tmimeType: 'text/plain',\n\t\t\t\t\tonLoad: function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document && document.getElementsByTagName('script'),\n\t\t\t\tloadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (window) {\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse\n\t};\n\n}.call(this);\n\npaper = new (PaperScope.inject(Base.exports, {\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key,\n\tDomEvent: DomEvent,\n\tDomElement: DomElement,\n\tdocument: document,\n\twindow: window,\n\tSymbol: SymbolDefinition,\n\tPlacedSymbol: SymbolItem\n}))();\n\nif (paper.agent.node) {\n\t__webpack_require__(/*! ./node/extend.js */ 2)(paper);\n}\n\nif (true) {\n\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\nreturn paper;\n}.call(this, typeof self === 'object' ? self : null);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1mdWxsLmpzPzIyMjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6ImdHQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGtEQUFrRDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQixFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEUsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLFdBQVc7QUFDWCxnREFBZ0Q7QUFDaEQsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZ0NBQWdDO0FBQ2hDLEVBQUU7O0FBRUY7QUFDQSxnQ0FBZ0M7QUFDaEMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsR0FBRzs7QUFFSCxjQUFjO0FBQ2QsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxjQUFjO0FBQ2Q7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDBDQUEwQyw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0IsZUFBZTtBQUNuQyxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0I7QUFDdEIsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxnQkFBZ0I7QUFDM0M7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQkFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxjQUFjO0FBQzVDO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0IsZUFBZTtBQUNmOztBQUVBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBaUQ7QUFDaEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWMsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Ysa0JBQWtCLCtCQUErQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxrQ0FBa0MsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMkJBQTJCO0FBQzNCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVcsYUFBYTtBQUM5QztBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGFBQWE7QUFDYixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsVUFBVTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG1GQUEwQixFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLG9DQUFvQztBQUNwQyxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBOztBQUVBLGNBQWMsWUFBWSxhQUFhLGVBQWUsYUFBYTtBQUNuRSxlQUFlLGFBQWEsVUFBVTs7QUFFdEMsZ0JBQWdCLGlCQUFpQixXQUFXLGtDQUFrQyxZQUFZO0FBQzFGLG1CQUFtQixvQkFBb0IsZUFBZSxvQkFBb0IsY0FBYztBQUN4RixhQUFhLDRCQUE0QixXQUFXO0FBQ3BELGtCQUFrQixtQkFBbUIsVUFBVSw2QkFBNkIsZUFBZTtBQUMzRixhQUFhLGNBQWMsYUFBYSxvQ0FBb0MsYUFBYTtBQUN6RixnQkFBZ0IsbUNBQW1DLFVBQVUsZUFBZSxVQUFVO0FBQ3RGLGdCQUFnQiwrQkFBK0IsV0FBVyxnQkFBZ0IsVUFBVTtBQUNwRixlQUFlOztBQUVmLGVBQWUsaUNBQWlDLFdBQVc7QUFDM0QsZ0JBQWdCOztBQUVoQixhQUFhOztBQUViLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFrRDtBQUN4RSxrQkFBa0Isa0RBQWtEO0FBQ3BFLGdCQUFnQixnREFBZ0Q7QUFDaEUsa0JBQWtCOztBQUVsQixtQkFBbUIsNEJBQTRCLGVBQWUsVUFBVSxhQUFhLFFBQVE7QUFDN0YsaUJBQWlCLFFBQVEsRUFBRSxhQUFhLDRCQUE0QixhQUFhO0FBQ2pGLGdCQUFnQiw0QkFBNEIsV0FBVyxRQUFRO0FBQy9ELGdCQUFnQiw0QkFBNEIsVUFBVSxVQUFVLGVBQWU7O0FBRS9FLGdCQUFnQiw0QkFBNEIsU0FBUztBQUNyRCxpQkFBaUI7QUFDakIsaUJBQWlCLDRDQUE0QyxhQUFhO0FBQzFFLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkMsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixxQkFBcUI7QUFDckIsa0JBQWtCLGdCQUFnQjtBQUNsQyxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQsNEJBQTRCO0FBQzVCLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIseURBQXlEO0FBQ3pELHlEQUF5RDtBQUN6RCx3REFBd0Q7QUFDeEQsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QixjQUFjO0FBQ2hFO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhLGlCQUFpQjs7QUFFakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtQ0FBbUMsYUFBYTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQ0FBcUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUErRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsQ0FBQyxRQUVEOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWZ1bGwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFBhcGVyLmpzIHYwLjExLjUgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMTYsIEp1ZXJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tLyAmIGh0dHA6Ly9qb25hdGhhbnB1Y2tleS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGF0ZTogVGh1IE9jdCA1IDE2OjE2OjI5IDIwMTcgKzAyMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAxNiBKdWVyZyBMZWhuaVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuXG52YXIgcGFwZXIgPSBmdW5jdGlvbihzZWxmLCB1bmRlZmluZWQpIHtcblxuc2VsZiA9IHNlbGYgfHwgcmVxdWlyZSgnLi9ub2RlL3NlbGYuanMnKTtcbnZhciB3aW5kb3cgPSBzZWxmLndpbmRvdyxcblx0ZG9jdW1lbnQgPSBzZWxmLmRvY3VtZW50O1xuXG52YXIgQmFzZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcblx0XHRhcnJheSA9IFtdLFxuXHRcdHNsaWNlID0gYXJyYXkuc2xpY2UsXG5cdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcblx0XHRkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG5cdFx0ZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuXG5cdFx0Zm9yRWFjaCA9IGFycmF5LmZvckVhY2ggfHwgZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZvckluID0gZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XG5cdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihkc3QpIHtcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG5cdFx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuXHRcdFx0XHRcdFx0ZHN0W2tleV0gPSBzcmNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRzdDtcblx0XHR9LFxuXG5cdFx0ZWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlciwgYmluZCkge1xuXHRcdFx0aWYgKG9iaikge1xuXHRcdFx0XHR2YXIgZGVzYyA9IGRlc2NyaWJlKG9iaiwgJ2xlbmd0aCcpO1xuXHRcdFx0XHQoZGVzYyAmJiB0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ251bWJlcicgPyBmb3JFYWNoIDogZm9ySW4pXG5cdFx0XHRcdFx0LmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJpbmQ7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcblx0XHR2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG5cdFx0XHR2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpXG5cdFx0XHRcdFx0JiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKVxuXHRcdFx0XHR2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcblx0XHRcdHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRyZXMgPSB2YWwsXG5cdFx0XHRcdHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmMgJiYgIXZhbC5iYXNlXG5cdFx0XHRcdFx0XHQ/ICh2YWwgJiYgdmFsLmdldCA/IG5hbWUgaW4gZGVzdCA6IGRlc3RbbmFtZV0pXG5cdFx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHRcdGJlYW47XG5cdFx0XHRpZiAoIXByZXNlcnZlIHx8ICFwcmV2KSB7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgcHJldilcblx0XHRcdFx0XHR2YWwuYmFzZSA9IHByZXY7XG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgYmVhbnMgIT09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiAoYmVhbiA9IG5hbWUubWF0Y2goL14oW2dzXWV0fGlzKSgoW0EtWl0pKC4qKSkkLykpKVxuXHRcdFx0XHRcdGJlYW5zTmFtZXNbYmVhblszXS50b0xvd2VyQ2FzZSgpICsgYmVhbls0XV0gPSBiZWFuWzJdO1xuXHRcdFx0XHRpZiAoIXJlcyB8fCBpc0Z1bmMgfHwgIXJlcy5nZXQgfHwgdHlwZW9mIHJlcy5nZXQgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdHx8ICFCYXNlLmlzUGxhaW5PYmplY3QocmVzKSkge1xuXHRcdFx0XHRcdHJlcyA9IHsgdmFsdWU6IHJlcywgd3JpdGFibGU6IHRydWUgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGUgIT0gbnVsbCA/IGVudW1lcmFibGUgOiAhYmVhbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZpbmUoZGVzdCwgbmFtZSwgcmVzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcblx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhaGlkZGVuLnRlc3QobmFtZSkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGJlYW5zTmFtZXMpIHtcblx0XHRcdFx0dmFyIHBhcnQgPSBiZWFuc05hbWVzW25hbWVdLFxuXHRcdFx0XHRcdHNldCA9IGRlc3RbJ3NldCcgKyBwYXJ0XSxcblx0XHRcdFx0XHRnZXQgPSBkZXN0WydnZXQnICsgcGFydF0gfHwgc2V0ICYmIGRlc3RbJ2lzJyArIHBhcnRdO1xuXHRcdFx0XHRpZiAoZ2V0ICYmIChiZWFucyA9PT0gdHJ1ZSB8fCBnZXQubGVuZ3RoID09PSAwKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lLCB7IGdldDogZ2V0LCBzZXQ6IHNldCB9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGRlc3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBCYXNlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmIChzcmMpXG5cdFx0XHRcdHNldCh0aGlzLCBzcmMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJldHVybiBpbmplY3QoQmFzZSwge1xuXHRcdGluamVjdDogZnVuY3Rpb24oc3JjKSB7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcblx0XHRcdFx0XHRiZWFucyA9IHNyYy5iZWFucyxcblx0XHRcdFx0XHRwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcblx0XHRcdFx0aWYgKHN0YXRpY3MgIT09IHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHRcdGluamVjdCh0aGlzLCBzdGF0aWNzLCBudWxsLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYmFzZSA9IHRoaXMsXG5cdFx0XHRcdGN0b3IsXG5cdFx0XHRcdHByb3RvO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIG9iaiwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRcdFx0aSA8IGwgJiYgIShjdG9yICYmIHByb3RvKTsgaSsrKSB7XG5cdFx0XHRcdG9iaiA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Y3RvciA9IGN0b3IgfHwgb2JqLmluaXRpYWxpemU7XG5cdFx0XHRcdHByb3RvID0gcHJvdG8gfHwgb2JqLnByb3RvdHlwZTtcblx0XHRcdH1cblx0XHRcdGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvdG8gPSBjdG9yLnByb3RvdHlwZSA9IHByb3RvIHx8IGNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRkZWZpbmUocHJvdG8sICdjb25zdHJ1Y3RvcicsXG5cdFx0XHRcdFx0eyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdGluamVjdChjdG9yLCB0aGlzKTtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpO1xuXHRcdFx0Y3Rvci5iYXNlID0gYmFzZTtcblx0XHRcdHJldHVybiBjdG9yO1xuXHRcdH1cblx0fSkuaW5qZWN0KHtcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblxuXHRcdGluaXRpYWxpemU6IEJhc2UsXG5cblx0XHRzZXQ6IEJhc2UsXG5cblx0XHRpbmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHNldDogc2V0LFxuXHRcdFx0ZWFjaDogZWFjaCxcblx0XHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdFx0ZGVmaW5lOiBkZWZpbmUsXG5cdFx0XHRkZXNjcmliZTogZGVzY3JpYmUsXG5cblx0XHRcdGNsb25lOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0cmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG5cdFx0XHRcdHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZVxuXHRcdFx0XHRcdFx0fHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwaWNrOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhICE9PSB1bmRlZmluZWQgPyBhIDogYjtcblx0XHRcdH0sXG5cblx0XHRcdHNsaWNlOiBmdW5jdGlvbihsaXN0LCBiZWdpbiwgZW5kKSB7XG5cdFx0XHRcdHJldHVybiBzbGljZS5jYWxsKGxpc3QsIGJlZ2luLCBlbmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuQmFzZS5pbmplY3Qoe1xuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihwcm9wcywgZXhjbHVkZSkge1xuXHRcdGlmIChwcm9wcylcblx0XHRcdEJhc2UuZmlsdGVyKHRoaXMsIHByb3BzLCBleGNsdWRlLCB0aGlzLl9wcmlvcml0aXplKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSwge1xuXG5iZWFuczogZmFsc2UsXG5zdGF0aWNzOiB7XG5cdGV4cG9ydHM6IHt9LFxuXG5cdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0bmFtZSA9IHJlcy5wcm90b3R5cGUuX2NsYXNzO1xuXHRcdGlmIChuYW1lICYmICFCYXNlLmV4cG9ydHNbbmFtZV0pXG5cdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRpZiAob2JqMSA9PT0gb2JqMilcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0cmV0dXJuIG9iajEuZXF1YWxzKG9iajIpO1xuXHRcdGlmIChvYmoyICYmIG9iajIuZXF1YWxzKVxuXHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdGlmIChvYmoxICYmIG9iajJcblx0XHRcdFx0JiYgdHlwZW9mIG9iajEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gb2JqMS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggIT09IG9iajIubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyhvYmoxW2xlbmd0aF0sIG9iajJbbGVuZ3RoXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqMSksXG5cdFx0XHRcdFx0bGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKCEob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpXG5cdFx0XHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKG9iajFba2V5XSwgb2JqMltrZXldKSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0cmVhZDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCkge1xuXHRcdGlmICh0aGlzID09PSBCYXNlKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuXHRcdFx0bGlzdC5fX2luZGV4Kys7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuXHRcdFx0cmVhZEluZGV4ID0gcHJvdG8uX3JlYWRJbmRleCxcblx0XHRcdGJlZ2luID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwLFxuXHRcdFx0bGVuZ3RoID0gbGlzdC5sZW5ndGgsXG5cdFx0XHRvYmogPSBsaXN0W2JlZ2luXTtcblx0XHRhbW91bnQgPSBhbW91bnQgfHwgbGVuZ3RoIC0gYmVnaW47XG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIHRoaXNcblx0XHRcdHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkTnVsbCAmJiBvYmogPT0gbnVsbCAmJiBhbW91bnQgPD0gMSkge1xuXHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0bGlzdC5fX2luZGV4ID0gYmVnaW4gKyAxO1xuXHRcdFx0cmV0dXJuIG9iaiAmJiBvcHRpb25zICYmIG9wdGlvbnMuY2xvbmUgPyBvYmouY2xvbmUoKSA6IG9iajtcblx0XHR9XG5cdFx0b2JqID0gQmFzZS5jcmVhdGUocHJvdG8pO1xuXHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRvYmouX19yZWFkID0gdHJ1ZTtcblx0XHRvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGJlZ2luID4gMCB8fCBiZWdpbiArIGFtb3VudCA8IGxlbmd0aFxuXHRcdFx0XHQ/IEJhc2Uuc2xpY2UobGlzdCwgYmVnaW4sIGJlZ2luICsgYW1vdW50KVxuXHRcdFx0XHQ6IGxpc3QpIHx8IG9iajtcblx0XHRpZiAocmVhZEluZGV4KSB7XG5cdFx0XHRsaXN0Ll9faW5kZXggPSBiZWdpbiArIG9iai5fX3JlYWQ7XG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBvYmouX19maWx0ZXJlZDtcblx0XHRcdGlmIChmaWx0ZXJlZCkge1xuXHRcdFx0XHRsaXN0Ll9fZmlsdGVyZWQgPSBmaWx0ZXJlZDtcblx0XHRcdFx0b2JqLl9fZmlsdGVyZWQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIGxpc3RbbGlzdC5fX2luZGV4ID0gc3RhcnQgfHwgbGlzdC5fX2luZGV4IHx8IDBdO1xuXHR9LFxuXG5cdHJlbWFpbjogZnVuY3Rpb24obGlzdCkge1xuXHRcdHJldHVybiBsaXN0Lmxlbmd0aCAtIChsaXN0Ll9faW5kZXggfHwgMCk7XG5cdH0sXG5cblx0cmVhZExpc3Q6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcblx0XHR2YXIgcmVzID0gW10sXG5cdFx0XHRlbnRyeSxcblx0XHRcdGJlZ2luID0gc3RhcnQgfHwgMCxcblx0XHRcdGVuZCA9IGFtb3VudCA/IGJlZ2luICsgYW1vdW50IDogbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKVxuXHRcdFx0XHRcdD8gdGhpcy5yZWFkKGVudHJ5LCAwLCBvcHRpb25zKVxuXHRcdFx0XHRcdDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRyZWFkTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpLFxuXHRcdFx0aGFzT2JqZWN0ID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzT2JqZWN0KSB7XG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBsaXN0Ll9fZmlsdGVyZWQ7XG5cdFx0XHRpZiAoIWZpbHRlcmVkKSB7XG5cdFx0XHRcdGZpbHRlcmVkID0gbGlzdC5fX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUobGlzdFswXSk7XG5cdFx0XHRcdGZpbHRlcmVkLl9fdW5maWx0ZXJlZCA9IGxpc3RbMF07XG5cdFx0XHR9XG5cdFx0XHRmaWx0ZXJlZFtuYW1lXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dmFyIGwgPSBoYXNPYmplY3QgPyBbdmFsdWVdIDogbGlzdCxcblx0XHRcdHJlcyA9IHRoaXMucmVhZChsLCBzdGFydCwgb3B0aW9ucywgYW1vdW50KTtcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0dmFyIGFyZyA9IGxpc3RbMF07XG5cdFx0aWYgKGxpc3QuX2hhc09iamVjdCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGlzdC5faGFzT2JqZWN0ID0gbGlzdC5sZW5ndGggPT09IDEgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZyk7XG5cdFx0aWYgKGxpc3QuX2hhc09iamVjdClcblx0XHRcdHJldHVybiBuYW1lID8gYXJnW25hbWVdIDogbGlzdC5fX2ZpbHRlcmVkIHx8IGFyZztcblx0fSxcblxuXHRoYXNOYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG5cdH0sXG5cblx0ZmlsdGVyOiBmdW5jdGlvbihkZXN0LCBzb3VyY2UsIGV4Y2x1ZGUsIHByaW9yaXRpemUpIHtcblx0XHR2YXIgcHJvY2Vzc2VkO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlS2V5KGtleSkge1xuXHRcdFx0aWYgKCEoZXhjbHVkZSAmJiBrZXkgaW4gZXhjbHVkZSkgJiZcblx0XHRcdFx0IShwcm9jZXNzZWQgJiYga2V5IGluIHByb2Nlc3NlZCkpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGRlc3Rba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChwcmlvcml0aXplKSB7XG5cdFx0XHR2YXIga2V5cyA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGtleSwgbCA9IHByaW9yaXRpemUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICgoa2V5ID0gcHJpb3JpdGl6ZVtpXSkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0aGFuZGxlS2V5KGtleSk7XG5cdFx0XHRcdFx0a2V5c1trZXldID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJvY2Vzc2VkID0ga2V5cztcblx0XHR9XG5cblx0XHRPYmplY3Qua2V5cyhzb3VyY2UuX191bmZpbHRlcmVkIHx8IHNvdXJjZSkuZm9yRWFjaChoYW5kbGVLZXkpO1xuXHRcdHJldHVybiBkZXN0O1xuXHR9LFxuXG5cdGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24ob2JqLCBhc1N0cmluZykge1xuXHRcdHJldHVybiBCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iailcblx0XHRcdFx0fHwgYXNTdHJpbmcgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5cdH0sXG5cblx0c2VyaWFsaXplOiBmdW5jdGlvbihvYmosIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciBpc1Jvb3QgPSAhZGljdGlvbmFyeSxcblx0XHRcdHJlcztcblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRvcHRpb25zLmZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0ZGljdGlvbmFyeSA9IHtcblx0XHRcdFx0bGVuZ3RoOiAwLFxuXHRcdFx0XHRkZWZpbml0aW9uczoge30sXG5cdFx0XHRcdHJlZmVyZW5jZXM6IHt9LFxuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuXHRcdFx0XHRcdHZhciBpZCA9ICcjJyArIGl0ZW0uX2lkLFxuXHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblx0XHRcdFx0XHRpZiAoIXJlZikge1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHRcdFx0XHRcdHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX2NsYXNzO1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuXHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXSA9IFtpZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmIChvYmogJiYgb2JqLl9zZXJpYWxpemUpIHtcblx0XHRcdHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuXHRcdFx0dmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXHRcdFx0aWYgKG5hbWUgJiYgIW9iai5fY29tcGFjdFNlcmlhbGl6ZSAmJiAoaXNSb290IHx8ICFjb21wYWN0KVxuXHRcdFx0XHRcdCYmIHJlc1swXSAhPT0gbmFtZSkge1xuXHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0cmVzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSk7XG5cdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuXHRcdFx0cmVzID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRyZXNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKG9ialtrZXldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuXHRcdFx0cmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXMgPSBvYmo7XG5cdFx0fVxuXHRcdHJldHVybiBpc1Jvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG5cdFx0XHRcdD8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG5cdFx0XHRcdDogcmVzO1xuXHR9LFxuXG5cdGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhLCBfc2V0RGljdGlvbmFyeSwgX2lzUm9vdCkge1xuXHRcdHZhciByZXMgPSBqc29uLFxuXHRcdFx0aXNGaXJzdCA9ICFfZGF0YSxcblx0XHRcdGhhc0RpY3Rpb25hcnkgPSBpc0ZpcnN0ICYmIGpzb24gJiYganNvbi5sZW5ndGhcblx0XHRcdFx0JiYganNvblswXVswXSA9PT0gJ2RpY3Rpb25hcnknO1xuXHRcdF9kYXRhID0gX2RhdGEgfHwge307XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcblx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0aXNEaWN0aW9uYXJ5ID0gdHlwZSA9PT0gJ2RpY3Rpb25hcnknO1xuXHRcdFx0aWYgKGpzb24ubGVuZ3RoID09IDEgJiYgL14jLy50ZXN0KHR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiBfZGF0YS5kaWN0aW9uYXJ5W3R5cGVdO1xuXHRcdFx0fVxuXHRcdFx0dHlwZSA9IEJhc2UuZXhwb3J0c1t0eXBlXTtcblx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHR5cGUgPyAxIDogMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKEJhc2UuZGVzZXJpYWxpemUoanNvbltpXSwgY3JlYXRlLCBfZGF0YSxcblx0XHRcdFx0XHRcdGlzRGljdGlvbmFyeSwgaGFzRGljdGlvbmFyeSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGUpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSByZXM7XG5cdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRyZXMgPSBjcmVhdGUodHlwZSwgYXJncywgaXNGaXJzdCB8fCBfaXNSb290KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXMgPSBCYXNlLmNyZWF0ZSh0eXBlLnByb3RvdHlwZSk7XG5cdFx0XHRcdFx0dHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcblx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0aWYgKF9zZXREaWN0aW9uYXJ5KVxuXHRcdFx0XHRfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGpzb24pXG5cdFx0XHRcdHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gaGFzRGljdGlvbmFyeSA/IHJlc1sxXSA6IHJlcztcblx0fSxcblxuXHRleHBvcnRKU09OOiBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcblx0XHR2YXIganNvbiA9IEJhc2Uuc2VyaWFsaXplKG9iaiwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PSBmYWxzZVxuXHRcdFx0XHQ/IGpzb25cblx0XHRcdFx0OiBKU09OLnN0cmluZ2lmeShqc29uKTtcblx0fSxcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uLCB0YXJnZXQpIHtcblx0XHRyZXR1cm4gQmFzZS5kZXNlcmlhbGl6ZShcblx0XHRcdFx0dHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24sXG5cdFx0XHRcdGZ1bmN0aW9uKGN0b3IsIGFyZ3MsIGlzUm9vdCkge1xuXHRcdFx0XHRcdHZhciB1c2VUYXJnZXQgPSBpc1Jvb3QgJiYgdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdCYmIHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gY3Rvcixcblx0XHRcdFx0XHRcdG9iaiA9IHVzZVRhcmdldCA/IHRhcmdldFxuXHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKGN0b3IucHJvdG90eXBlKTtcblx0XHRcdFx0XHRpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgb2JqIGluc3RhbmNlb2YgSXRlbVxuXHRcdFx0XHRcdFx0XHQmJiAodXNlVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuXHRcdFx0XHRcdFx0dmFyIGFyZyA9IGFyZ3NbMF07XG5cdFx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpXG5cdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KHVzZVRhcmdldCA/IG9iai5zZXQgOiBjdG9yKS5hcHBseShvYmosIGFyZ3MpO1xuXHRcdFx0XHRcdGlmICh1c2VUYXJnZXQpXG5cdFx0XHRcdFx0XHR0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH0pO1xuXHR9LFxuXG5cdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHR2YXIgYW1vdW50ID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoLFxuXHRcdFx0YXBwZW5kID0gaW5kZXggPT09IHVuZGVmaW5lZDtcblx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0aWYgKGluZGV4ID4gbGlzdC5sZW5ndGgpXG5cdFx0XHRpbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRpdGVtc1tpXS5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRpZiAoaXRlbXMpXG5cdFx0XHRcdGFyZ3MucHVzaC5hcHBseShhcmdzLCBpdGVtcyk7XG5cdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSByZW1vdmVkLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0cmVtb3ZlZFtpXS5faW5kZXggPSB1bmRlZmluZWQ7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0bGlzdFtpXS5faW5kZXggPSBpO1xuXHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGNhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGNhbWVsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24obWF0Y2gsIGNocikge1xuXHRcdFx0cmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGh5cGhlbmF0ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHR9XG59fSk7XG5cbnZhciBFbWl0dGVyID0ge1xuXHRvbjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub24oa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdFx0XHRoYW5kbGVycyA9IGhhbmRsZXJzW3R5cGVdID0gaGFuZGxlcnNbdHlwZV0gfHwgW107XG5cdFx0XHRpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5Lmluc3RhbGwgJiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRcdGVudHJ5Lmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b2ZmOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5vZmYoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG5cdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0sXG5cdFx0XHRpbmRleDtcblx0XHRpZiAoaGFuZGxlcnMpIHtcblx0XHRcdGlmICghZnVuYyB8fCAoaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKGZ1bmMpKSAhPT0gLTFcblx0XHRcdFx0XHQmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5LnVuaW5zdGFsbClcblx0XHRcdFx0XHRlbnRyeS51bmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRcdH0gZWxzZSBpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRyZXR1cm4gdGhpcy5vbih0eXBlLCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMub2ZmKHR5cGUsIGZ1bmMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGVtaXQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoIWhhbmRsZXJzKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBhcmdzID0gQmFzZS5zbGljZShhcmd1bWVudHMsIDEpLFxuXHRcdFx0c2V0VGFyZ2V0ID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmICFldmVudC5jdXJyZW50VGFyZ2V0O1xuXHRcdGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoKTtcblx0XHRpZiAoc2V0VGFyZ2V0KVxuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChoYW5kbGVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKSA9PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcClcblx0XHRcdFx0XHRldmVudC5zdG9wKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdCAgIH1cblx0XHR9XG5cdFx0aWYgKHNldFRhcmdldClcblx0XHRcdGRlbGV0ZSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHJlc3BvbmRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuXHR9LFxuXG5cdGF0dGFjaDogJyNvbicsXG5cdGRldGFjaDogJyNvZmYnLFxuXHRmaXJlOiAnI2VtaXQnLFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbihpbnN0YWxsKSB7XG5cdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzLFxuXHRcdFx0a2V5ID0gaW5zdGFsbCA/ICdpbnN0YWxsJyA6ICd1bmluc3RhbGwnO1xuXHRcdGlmICh0eXBlcykge1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuXHRcdFx0XHRpZiAoaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBlbnRyeSA9IHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdFx0ZnVuYyA9IGVudHJ5ICYmIGVudHJ5W2tleV07XG5cdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRmdW5jLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGluamVjdDogZnVuY3Rpb24gaW5qZWN0KHNyYykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHNyYy5fZXZlbnRzO1xuXHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHR2YXIgdHlwZXMgPSB7fTtcblx0XHRcdFx0QmFzZS5lYWNoKGV2ZW50cywgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHRcdFx0XHRcdHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycsXG5cdFx0XHRcdFx0XHRuYW1lID0gaXNTdHJpbmcgPyBlbnRyeSA6IGtleSxcblx0XHRcdFx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdFx0XHR0eXBlID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR0eXBlc1t0eXBlXSA9IGlzU3RyaW5nID8ge30gOiBlbnRyeTtcblx0XHRcdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHRcdFx0XHRzcmNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzcmNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKGZ1bmMpIHtcblx0XHRcdFx0XHRcdHZhciBwcmV2ID0gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHRcdGlmIChwcmV2KVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBwcmV2KTtcblx0XHRcdFx0XHRcdGlmIChmdW5jKVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9uKHR5cGUsIGZ1bmMpO1xuXHRcdFx0XHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmM7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNyYy5fZXZlbnRUeXBlcyA9IHR5cGVzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluamVjdC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgUGFwZXJTY29wZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGFwZXJTY29wZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGFwZXJTY29wZSgpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IG5ldyBCYXNlKHtcblx0XHRcdGFwcGx5TWF0cml4OiB0cnVlLFxuXHRcdFx0aW5zZXJ0SXRlbXM6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMuX2lkID0gUGFwZXJTY29wZS5faWQrKztcblx0XHRQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcblx0XHR2YXIgcHJvdG8gPSBQYXBlclNjb3BlLnByb3RvdHlwZTtcblx0XHRpZiAoIXRoaXMuc3VwcG9ydCkge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSkgfHwge307XG5cdFx0XHRwcm90by5zdXBwb3J0ID0ge1xuXHRcdFx0XHRuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuXHRcdFx0XHRuYXRpdmVCbGVuZE1vZGVzOiBCbGVuZE1vZGUubmF0aXZlTW9kZXNcblx0XHRcdH07XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5hZ2VudCkge1xuXHRcdFx0dmFyIHVzZXIgPSBzZWxmLm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0b3MgPSAoLyhkYXJ3aW58d2lufG1hY3xsaW51eHxmcmVlYnNkfHN1bm9zKS8uZXhlYyh1c2VyKXx8W10pWzBdLFxuXHRcdFx0XHRwbGF0Zm9ybSA9IG9zID09PSAnZGFyd2luJyA/ICdtYWMnIDogb3MsXG5cdFx0XHRcdGFnZW50ID0gcHJvdG8uYWdlbnQgPSBwcm90by5icm93c2VyID0geyBwbGF0Zm9ybTogcGxhdGZvcm0gfTtcblx0XHRcdGlmIChwbGF0Zm9ybSlcblx0XHRcdFx0YWdlbnRbcGxhdGZvcm1dID0gdHJ1ZTtcblx0XHRcdHVzZXIucmVwbGFjZShcblx0XHRcdFx0LyhvcGVyYXxjaHJvbWV8c2FmYXJpfHdlYmtpdHxmaXJlZm94fG1zaWV8dHJpZGVudHxhdG9tfG5vZGUpXFwvP1xccyooWy5cXGRdKykoPzouKnZlcnNpb25cXC8oWy5cXGRdKykpPyg/Oi4qcnZcXDp2PyhbLlxcZF0rKSk/L2csXG5cdFx0XHRcdGZ1bmN0aW9uKG1hdGNoLCBuLCB2MSwgdjIsIHJ2KSB7XG5cdFx0XHRcdFx0aWYgKCFhZ2VudC5jaHJvbWUpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDpcblx0XHRcdFx0XHRcdFx0XHQvXihub2RlfHRyaWRlbnQpJC8udGVzdChuKSA/IHJ2IDogdjE7XG5cdFx0XHRcdFx0XHRhZ2VudC52ZXJzaW9uID0gdjtcblx0XHRcdFx0XHRcdGFnZW50LnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0XHRcdFx0biA9IG4gPT09ICd0cmlkZW50JyA/ICdtc2llJyA6IG47XG5cdFx0XHRcdFx0XHRhZ2VudC5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGFnZW50W25dID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRpZiAoYWdlbnQuY2hyb21lKVxuXHRcdFx0XHRkZWxldGUgYWdlbnQud2Via2l0O1xuXHRcdFx0aWYgKGFnZW50LmF0b20pXG5cdFx0XHRcdGRlbGV0ZSBhZ2VudC5jaHJvbWU7XG5cdFx0fVxuXHR9LFxuXG5cdHZlcnNpb246IFwiMC4xMS41XCIsXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLnByb2plY3Q7XG5cdFx0cmV0dXJuIHByb2plY3QgJiYgcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRnZXRQYXBlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhlY3V0ZTogZnVuY3Rpb24oY29kZSwgb3B0aW9ucykge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgb3B0aW9ucyk7XG5cdFx0Vmlldy51cGRhdGVGb2N1cygpO1xuXHR9LFxuXG5cdGluc3RhbGw6IGZ1bmN0aW9uKHNjb3BlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0QmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXRba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMpXG5cdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSlcblx0XHRcdFx0c2NvcGVba2V5XSA9IHRoaXNba2V5XTtcblx0fSxcblxuXHRzZXR1cDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChlbGVtZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjcmVhdGVDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRyZXR1cm4gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcm9qZWN0cyA9IHRoaXMucHJvamVjdHMsXG5cdFx0XHR0b29scyA9IHRoaXMudG9vbHM7XG5cdFx0Zm9yICh2YXIgaSA9IHByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0cHJvamVjdHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRvb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dG9vbHNbaV0ucmVtb3ZlKCk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0ZGVsZXRlIFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF07XG5cdH0sXG5cblx0c3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRuYW1lICs9ICdBdHRyaWJ1dGUnO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG5cdFx0XHRcdHJldHVybiBlbFtuYW1lXShhdHRyKSB8fCBlbFtuYW1lXSgnZGF0YS1wYXBlci0nICsgYXR0cik7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRfc2NvcGVzOiB7fSxcblx0XHRcdF9pZDogMCxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2NvcGVzW2lkXSB8fCBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2dldCcpLFxuXHRcdFx0aGFzQXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2hhcycpXG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBQYXBlclNjb3BlSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihhY3RpdmF0ZSkge1xuXHRcdHRoaXMuX3Njb3BlID0gcGFwZXI7XG5cdFx0dGhpcy5faW5kZXggPSB0aGlzLl9zY29wZVt0aGlzLl9saXN0XS5wdXNoKHRoaXMpIC0gMTtcblx0XHRpZiAoYWN0aXZhdGUgfHwgIXRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0pXG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fc2NvcGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHByZXYgPSB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdO1xuXHRcdGlmIChwcmV2ICYmIHByZXYgIT09IHRoaXMpXG5cdFx0XHRwcmV2LmVtaXQoJ2RlYWN0aXZhdGUnKTtcblx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gdGhpcztcblx0XHR0aGlzLmVtaXQoJ2FjdGl2YXRlJywgcHJldik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09PSB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2luZGV4ID09IG51bGwpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0QmFzZS5zcGxpY2UodGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRpZiAodGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PSB0aGlzKVxuXHRcdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IG51bGw7XG5cdFx0dGhpcy5fc2NvcGUgPSBudWxsO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5nZXRWaWV3KCk7XG5cdH1cbn0pO1xuXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblx0XHR0aGlzLnByZWNpc2lvbiA9IEJhc2UucGljayhwcmVjaXNpb24sIDUpO1xuXHRcdHRoaXMubXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbik7XG5cdH0sXG5cblx0bnVtYmVyOiBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmVjaXNpb24gPCAxNlxuXHRcdFx0XHQ/IE1hdGgucm91bmQodmFsICogdGhpcy5tdWx0aXBsaWVyKSAvIHRoaXMubXVsdGlwbGllciA6IHZhbDtcblx0fSxcblxuXHRwYWlyOiBmdW5jdGlvbih2YWwxLCB2YWwyLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsMSkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwyKTtcblx0fSxcblxuXHRwb2ludDogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLngpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsLnkpO1xuXHR9LFxuXG5cdHNpemU6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC53aWR0aCkgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLm51bWJlcih2YWwuaGVpZ2h0KTtcblx0fSxcblxuXHRyZWN0YW5nbGU6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMucG9pbnQodmFsLCBzZXBhcmF0b3IpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5zaXplKHZhbCwgc2VwYXJhdG9yKTtcblx0fVxufSk7XG5cbkZvcm1hdHRlci5pbnN0YW5jZSA9IG5ldyBGb3JtYXR0ZXIoKTtcblxudmFyIE51bWVyaWNhbCA9IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIgYWJzY2lzc2FzID0gW1xuXHRcdFsgIDAuNTc3MzUwMjY5MTg5NjI1NzY0NTA5MTQ4OF0sXG5cdFx0WzAsMC43NzQ1OTY2NjkyNDE0ODMzNzcwMzU4NTMxXSxcblx0XHRbICAwLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSxcblx0XHRbMCwwLjUzODQ2OTMxMDEwNTY4MzA5MTAzNjMxNDQsMC45MDYxNzk4NDU5Mzg2NjM5OTI3OTc2MjY5XSxcblx0XHRbICAwLjIzODYxOTE4NjA4MzE5NjkwODYzMDUwMTcsMC42NjEyMDkzODY0NjYyNjQ1MTM2NjEzOTk2LDAuOTMyNDY5NTE0MjAzMTUyMDI3ODEyMzAxNl0sXG5cdFx0WzAsMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLFxuXHRcdFsgIDAuMTgzNDM0NjQyNDk1NjQ5ODA0OTM5NDc2MSwwLjUyNTUzMjQwOTkxNjMyODk4NTgxNzczOTAsMC43OTY2NjY0Nzc0MTM2MjY3Mzk1OTE1NTM5LDAuOTYwMjg5ODU2NDk3NTM2MjMxNjgzNTYwOV0sXG5cdFx0WzAsMC4zMjQyNTM0MjM0MDM4MDg5MjkwMzg1MzgwLDAuNjEzMzcxNDMyNzAwNTkwMzk3MzA4NzAyMCwwLjgzNjAzMTEwNzMyNjYzNTc5NDI5OTQyOTgsMC45NjgxNjAyMzk1MDc2MjYwODk4MzU1NzYyXSxcblx0XHRbICAwLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSxcblx0XHRbMCwwLjI2OTU0MzE1NTk1MjM0NDk3MjMzMTUzMjAsMC41MTkwOTYxMjkyMDY4MTE4MTU5MjU3MjU3LDAuNzMwMTUyMDA1NTc0MDQ5MzI0MDkzNDE2MywwLjg4NzA2MjU5OTc2ODA5NTI5OTA3NTE1NzgsMC45NzgyMjg2NTgxNDYwNTY5OTI4MDM5MzgwXSxcblx0XHRbICAwLjEyNTIzMzQwODUxMTQ2ODkxNTQ3MjQ0MTQsMC4zNjc4MzE0OTg5OTgxODAxOTM3NTI2OTE1LDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNCwwLjc2OTkwMjY3NDE5NDMwNDY4NzAzNjg5MzgsMC45MDQxMTcyNTYzNzA0NzQ4NTY2Nzg0NjU5LDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MV0sXG5cdFx0WzAsMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLFxuXHRcdFsgIDAuMTA4MDU0OTQ4NzA3MzQzNjYyMDY2MjQ0NywwLjMxOTExMjM2ODkyNzg4OTc2MDQzNTY3MTgsMC41MTUyNDg2MzYzNTgxNTQwOTE5NjUyOTA3LDAuNjg3MjkyOTA0ODExNjg1NDcwMTQ4MDE5OCwwLjgyNzIwMTMxNTA2OTc2NDk5MzE4OTc5NDcsMC45Mjg0MzQ4ODM2NjM1NzM1MTczMzYzOTExLDAuOTg2MjgzODA4Njk2ODEyMzM4ODQxNTk3M10sXG5cdFx0WzAsMC4yMDExOTQwOTM5OTc0MzQ1MjIzMDA2MjgzLDAuMzk0MTUxMzQ3MDc3NTYzMzY5ODk3MjA3NCwwLjU3MDk3MjE3MjYwODUzODg0NzUzNzIyNjcsMC43MjQ0MTc3MzEzNjAxNzAwNDc0MTYxODYxLDAuODQ4MjA2NTgzNDEwNDI3MjE2MjAwNjQ4MywwLjkzNzI3MzM5MjQwMDcwNTkwNDMwNzc1ODksMC45ODc5OTI1MTgwMjA0ODU0Mjg0ODk1NjU3XSxcblx0XHRbICAwLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXVxuXHRdO1xuXG5cdHZhciB3ZWlnaHRzID0gW1xuXHRcdFsxXSxcblx0XHRbMC44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1Nl0sXG5cdFx0WzAuNjUyMTQ1MTU0ODYyNTQ2MTQyNjI2OTM2MSwwLjM0Nzg1NDg0NTEzNzQ1Mzg1NzM3MzA2MzldLFxuXHRcdFswLjU2ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC40Nzg2Mjg2NzA0OTkzNjY0NjgwNDEyOTE1LDAuMjM2OTI2ODg1MDU2MTg5MDg3NTE0MjY0MF0sXG5cdFx0WzAuNDY3OTEzOTM0NTcyNjkxMDQ3Mzg5ODcwMywwLjM2MDc2MTU3MzA0ODEzODYwNzU2OTgzMzUsMC4xNzEzMjQ0OTIzNzkxNzAzNDUwNDAyOTYxXSxcblx0XHRbMC40MTc5NTkxODM2NzM0NjkzODc3NTUxMDIwLDAuMzgxODMwMDUwNTA1MTE4OTQ0OTUwMzY5OCwwLjI3OTcwNTM5MTQ4OTI3NjY2NzkwMTQ2NzgsMC4xMjk0ODQ5NjYxNjg4Njk2OTMyNzA2MTE0XSxcblx0XHRbMC4zNjI2ODM3ODMzNzgzNjE5ODI5NjUxNTA0LDAuMzEzNzA2NjQ1ODc3ODg3Mjg3MzM3OTYyMiwwLjIyMjM4MTAzNDQ1MzM3NDQ3MDU0NDM1NjAsMC4xMDEyMjg1MzYyOTAzNzYyNTkxNTI1MzE0XSxcblx0XHRbMC4zMzAyMzkzNTUwMDEyNTk3NjMxNjQ1MjUxLDAuMzEyMzQ3MDc3MDQwMDAyODQwMDY4NjMwNCwwLjI2MDYxMDY5NjQwMjkzNTQ2MjMxODc0MjksMC4xODA2NDgxNjA2OTQ4NTc0MDQwNTg0NzIwLDAuMDgxMjc0Mzg4MzYxNTc0NDExOTcxODkyMl0sXG5cdFx0WzAuMjk1NTI0MjI0NzE0NzUyODcwMTczODkzMCwwLjI2OTI2NjcxOTMwOTk5NjM1NTA5MTIyNjksMC4yMTkwODYzNjI1MTU5ODIwNDM5OTU1MzQ5LDAuMTQ5NDUxMzQ5MTUwNTgwNTkzMTQ1Nzc2MywwLjA2NjY3MTM0NDMwODY4ODEzNzU5MzU2ODhdLFxuXHRcdFswLjI3MjkyNTA4Njc3NzkwMDYzMDcxNDQ4MzUsMC4yNjI4MDQ1NDQ1MTAyNDY2NjIxODA2ODg5LDAuMjMzMTkzNzY0NTkxOTkwNDc5OTE4NTIzNywwLjE4NjI5MDIxMDkyNzczNDI1MTQyNjA5NzYsMC4xMjU1ODAzNjk0NjQ5MDQ2MjQ2MzQ2OTQzLDAuMDU1NjY4NTY3MTE2MTczNjY2NDgyNzUzN10sXG5cdFx0WzAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNCwwLjIzMzQ5MjUzNjUzODM1NDgwODc2MDg0OTksMC4yMDMxNjc0MjY3MjMwNjU5MjE3NDkwNjQ1LDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNSwwLjEwNjkzOTMyNTk5NTMxODQzMDk2MDI1NDcsMC4wNDcxNzUzMzYzODY1MTE4MjcxOTQ2MTYwXSxcblx0XHRbMC4yMzI1NTE1NTMyMzA4NzM5MTAxOTQ1ODk1LDAuMjI2MjgzMTgwMjYyODk3MjM4NDEyMDkwMiwwLjIwNzgxNjA0NzUzNjg4ODUwMjMxMjUyMzIsMC4xNzgxNDU5ODA3NjE5NDU3MzgyODAwNDY3LDAuMTM4ODczNTEwMjE5Nzg3MjM4NDYzNjAxOCwwLjA5MjEyMTQ5OTgzNzcyODQ0NzkxNDQyMTgsMC4wNDA0ODQwMDQ3NjUzMTU4Nzk1MjAwMjE2XSxcblx0XHRbMC4yMTUyNjM4NTM0NjMxNTc3OTAxOTU4NzY0LDAuMjA1MTk4NDYzNzIxMjk1NjAzOTY1OTI0MSwwLjE4NTUzODM5NzQ3NzkzNzgxMzc0MTcxNjYsMC4xNTcyMDMxNjcxNTgxOTM1MzQ1Njk2MDE5LDAuMTIxNTE4NTcwNjg3OTAzMTg0Njg5NDE0OCwwLjA4MDE1ODA4NzE1OTc2MDIwOTgwNTYzMzMsMC4wMzUxMTk0NjAzMzE3NTE4NjMwMzE4MzI5XSxcblx0XHRbMC4yMDI1NzgyNDE5MjU1NjEyNzI4ODA2MjAyLDAuMTk4NDMxNDg1MzI3MTExNTc2NDU2MTE4MywwLjE4NjE2MTAwMDAxNTU2MjIxMTAyNjgwMDYsMC4xNjYyNjkyMDU4MTY5OTM5MzM1NTMyMDA5LDAuMTM5NTcwNjc3OTI2MTU0MzE0NDQ3ODA0OCwwLjEwNzE1OTIyMDQ2NzE3MTkzNTAxMTg2OTUsMC4wNzAzNjYwNDc0ODgxMDgxMjQ3MDkyNjc0LDAuMDMwNzUzMjQxOTk2MTE3MjY4MzU0NjI4NF0sXG5cdFx0WzAuMTg5NDUwNjEwNDU1MDY4NDk2Mjg1Mzk2NywwLjE4MjYwMzQxNTA0NDkyMzU4ODg2Njc2MzcsMC4xNjkxNTY1MTkzOTUwMDI1MzgxODkzMTIxLDAuMTQ5NTk1OTg4ODE2NTc2NzMyMDgxNTAxNywwLjEyNDYyODk3MTI1NTUzMzg3MjA1MjQ3NjMsMC4wOTUxNTg1MTE2ODI0OTI3ODQ4MDk5MjUxLDAuMDYyMjUzNTIzOTM4NjQ3ODkyODYyODQzOCwwLjAyNzE1MjQ1OTQxMTc1NDA5NDg1MTc4MDZdXG5cdF07XG5cblx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0cG93ID0gTWF0aC5wb3csXG5cdFx0bG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xuXHRcdH0sXG5cdFx0RVBTSUxPTiA9IDFlLTEyLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTiA9IDEuMTJlLTE2O1xuXG5cdGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXREaXNjcmltaW5hbnQoYSwgYiwgYykge1xuXHRcdGZ1bmN0aW9uIHNwbGl0KHYpIHtcblx0XHRcdHZhciB4ID0gdiAqIDEzNDIxNzcyOSxcblx0XHRcdFx0eSA9IHYgLSB4LFxuXHRcdFx0XHRoaSA9IHkgKyB4LFxuXHRcdFx0XHRsbyA9IHYgLSBoaTtcblx0XHRcdHJldHVybiBbaGksIGxvXTtcblx0XHR9XG5cblx0XHR2YXIgRCA9IGIgKiBiIC0gYSAqIGMsXG5cdFx0XHRFID0gYiAqIGIgKyBhICogYztcblx0XHRpZiAoYWJzKEQpICogMyA8IEUpIHtcblx0XHRcdHZhciBhZCA9IHNwbGl0KGEpLFxuXHRcdFx0XHRiZCA9IHNwbGl0KGIpLFxuXHRcdFx0XHRjZCA9IHNwbGl0KGMpLFxuXHRcdFx0XHRwID0gYiAqIGIsXG5cdFx0XHRcdGRwID0gKGJkWzBdICogYmRbMF0gLSBwICsgMiAqIGJkWzBdICogYmRbMV0pICsgYmRbMV0gKiBiZFsxXSxcblx0XHRcdFx0cSA9IGEgKiBjLFxuXHRcdFx0XHRkcSA9IChhZFswXSAqIGNkWzBdIC0gcSArIGFkWzBdICogY2RbMV0gKyBhZFsxXSAqIGNkWzBdKVxuXHRcdFx0XHRcdFx0KyBhZFsxXSAqIGNkWzFdO1xuXHRcdFx0RCA9IChwIC0gcSkgKyAoZHAgLSBkcSk7XG5cdFx0fVxuXHRcdHJldHVybiBEO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcigpIHtcblx0XHR2YXIgbm9ybSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5vcm0gJiYgKG5vcm0gPCAxZS04IHx8IG5vcm0gPiAxZTgpXG5cdFx0XHRcdD8gcG93KDIsIC1NYXRoLnJvdW5kKGxvZzIobm9ybSkpKVxuXHRcdFx0XHQ6IDA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdEVQU0lMT046IEVQU0lMT04sXG5cdFx0TUFDSElORV9FUFNJTE9OOiBNQUNISU5FX0VQU0lMT04sXG5cdFx0Q1VSVkVUSU1FX0VQU0lMT046IDFlLTgsXG5cdFx0R0VPTUVUUklDX0VQU0lMT046IDFlLTcsXG5cdFx0VFJJR09OT01FVFJJQ19FUFNJTE9OOiAxZS04LFxuXHRcdEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG5cblx0XHRpc1plcm86IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0cmV0dXJuIHZhbCA+PSAtRVBTSUxPTiAmJiB2YWwgPD0gRVBTSUxPTjtcblx0XHR9LFxuXG5cdFx0Y2xhbXA6IGNsYW1wLFxuXG5cdFx0aW50ZWdyYXRlOiBmdW5jdGlvbihmLCBhLCBiLCBuKSB7XG5cdFx0XHR2YXIgeCA9IGFic2Npc3Nhc1tuIC0gMl0sXG5cdFx0XHRcdHcgPSB3ZWlnaHRzW24gLSAyXSxcblx0XHRcdFx0QSA9IChiIC0gYSkgKiAwLjUsXG5cdFx0XHRcdEIgPSBBICsgYSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdG0gPSAobiArIDEpID4+IDEsXG5cdFx0XHRcdHN1bSA9IG4gJiAxID8gd1tpKytdICogZihCKSA6IDA7XG5cdFx0XHR3aGlsZSAoaSA8IG0pIHtcblx0XHRcdFx0dmFyIEF4ID0gQSAqIHhbaV07XG5cdFx0XHRcdHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBICogc3VtO1xuXHRcdH0sXG5cblx0XHRmaW5kUm9vdDogZnVuY3Rpb24oZiwgZGYsIHgsIGEsIGIsIG4sIHRvbGVyYW5jZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGZ4ID0gZih4KSxcblx0XHRcdFx0XHRkeCA9IGZ4IC8gZGYoeCksXG5cdFx0XHRcdFx0bnggPSB4IC0gZHg7XG5cdFx0XHRcdGlmIChhYnMoZHgpIDwgdG9sZXJhbmNlKSB7XG5cdFx0XHRcdFx0eCA9IG54O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmeCA+IDApIHtcblx0XHRcdFx0XHRiID0geDtcblx0XHRcdFx0XHR4ID0gbnggPD0gYSA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0geDtcblx0XHRcdFx0XHR4ID0gbnggPj0gYiA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNsYW1wKHgsIGEsIGIpO1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgeDEsIHgyID0gSW5maW5pdHk7XG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKGIpIDwgRVBTSUxPTilcblx0XHRcdFx0XHRyZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDtcblx0XHRcdFx0eDEgPSAtYyAvIGI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiICo9IC0wLjU7XG5cdFx0XHRcdHZhciBEID0gZ2V0RGlzY3JpbWluYW50KGEsIGIsIGMpO1xuXHRcdFx0XHRpZiAoRCAmJiBhYnMoRCkgPCBNQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHR2YXIgZiA9IGdldE5vcm1hbGl6YXRpb25GYWN0b3IoYWJzKGEpLCBhYnMoYiksIGFicyhjKSk7XG5cdFx0XHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0XHRcdGEgKj0gZjtcblx0XHRcdFx0XHRcdGIgKj0gZjtcblx0XHRcdFx0XHRcdGMgKj0gZjtcblx0XHRcdFx0XHRcdEQgPSBnZXREaXNjcmltaW5hbnQoYSwgYiwgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChEID49IC1NQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHR2YXIgUSA9IEQgPCAwID8gMCA6IHNxcnQoRCksXG5cdFx0XHRcdFx0XHRSID0gYiArIChiIDwgMCA/IC1RIDogUSk7XG5cdFx0XHRcdFx0aWYgKFIgPT09IDApIHtcblx0XHRcdFx0XHRcdHgxID0gYyAvIGE7XG5cdFx0XHRcdFx0XHR4MiA9IC14MTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eDEgPSBSIC8gYTtcblx0XHRcdFx0XHRcdHgyID0gYyAvIFI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHRib3VuZGxlc3MgPSBtaW4gPT0gbnVsbCxcblx0XHRcdFx0bWluQiA9IG1pbiAtIEVQU0lMT04sXG5cdFx0XHRcdG1heEIgPSBtYXggKyBFUFNJTE9OO1xuXHRcdFx0aWYgKGlzRmluaXRlKHgxKSAmJiAoYm91bmRsZXNzIHx8IHgxID4gbWluQiAmJiB4MSA8IG1heEIpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHgxIDogY2xhbXAoeDEsIG1pbiwgbWF4KTtcblx0XHRcdGlmICh4MiAhPT0geDFcblx0XHRcdFx0XHQmJiBpc0Zpbml0ZSh4MikgJiYgKGJvdW5kbGVzcyB8fCB4MiA+IG1pbkIgJiYgeDIgPCBtYXhCKSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBib3VuZGxlc3MgPyB4MiA6IGNsYW1wKHgyLCBtaW4sIG1heCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGYgPSBnZXROb3JtYWxpemF0aW9uRmFjdG9yKGFicyhhKSwgYWJzKGIpLCBhYnMoYyksIGFicyhkKSksXG5cdFx0XHRcdHgsIGIxLCBjMiwgcWQsIHE7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHRhICo9IGY7XG5cdFx0XHRcdGIgKj0gZjtcblx0XHRcdFx0YyAqPSBmO1xuXHRcdFx0XHRkICo9IGY7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGV2YWx1YXRlKHgwKSB7XG5cdFx0XHRcdHggPSB4MDtcblx0XHRcdFx0dmFyIHRtcCA9IGEgKiB4O1xuXHRcdFx0XHRiMSA9IHRtcCArIGI7XG5cdFx0XHRcdGMyID0gYjEgKiB4ICsgYztcblx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyO1xuXHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdGIxID0gYztcblx0XHRcdFx0YzIgPSBkO1xuXHRcdFx0XHR4ID0gSW5maW5pdHk7XG5cdFx0XHR9IGVsc2UgaWYgKGFicyhkKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0YjEgPSBiO1xuXHRcdFx0XHRjMiA9IGM7XG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXZhbHVhdGUoLShiIC8gYSkgLyAzKTtcblx0XHRcdFx0dmFyIHQgPSBxIC8gYSxcblx0XHRcdFx0XHRyID0gcG93KGFicyh0KSwgMS8zKSxcblx0XHRcdFx0XHRzID0gdCA8IDAgPyAtMSA6IDEsXG5cdFx0XHRcdFx0dGQgPSAtcWQgLyBhLFxuXHRcdFx0XHRcdHJkID0gdGQgPiAwID8gMS4zMjQ3MTc5NTcyNDQ3NDYgKiBNYXRoLm1heChyLCBzcXJ0KHRkKSkgOiByLFxuXHRcdFx0XHRcdHgwID0geCAtIHMgKiByZDtcblx0XHRcdFx0aWYgKHgwICE9PSB4KSB7XG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0ZXZhbHVhdGUoeDApO1xuXHRcdFx0XHRcdFx0eDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gKDEgKyBNQUNISU5FX0VQU0lMT04pO1xuXHRcdFx0XHRcdH0gd2hpbGUgKHMgKiB4MCA+IHMgKiB4KTtcblx0XHRcdFx0XHRpZiAoYWJzKGEpICogeCAqIHggPiBhYnMoZCAvIHgpKSB7XG5cdFx0XHRcdFx0XHRjMiA9IC1kIC8geDtcblx0XHRcdFx0XHRcdGIxID0gKGMyIC0gYykgLyB4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIxLCBjMiwgcm9vdHMsIG1pbiwgbWF4KSxcblx0XHRcdFx0Ym91bmRsZXNzID0gbWluID09IG51bGw7XG5cdFx0XHRpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwXG5cdFx0XHRcdFx0fHwgY291bnQgPiAwICYmIHggIT09IHJvb3RzWzBdICYmIHggIT09IHJvb3RzWzFdKVxuXHRcdFx0XHRcdCYmIChib3VuZGxlc3MgfHwgeCA+IG1pbiAtIEVQU0lMT04gJiYgeCA8IG1heCArIEVQU0lMT04pKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHggOiBjbGFtcCh4LCBtaW4sIG1heCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFVJRCA9IHtcblx0X2lkOiAxLFxuXHRfcG9vbHM6IHt9LFxuXG5cdGdldDogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmIChuYW1lKSB7XG5cdFx0XHR2YXIgcG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdO1xuXHRcdFx0aWYgKCFwb29sKVxuXHRcdFx0XHRwb29sID0gdGhpcy5fcG9vbHNbbmFtZV0gPSB7IF9pZDogMSB9O1xuXHRcdFx0cmV0dXJuIHBvb2wuX2lkKys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pZCsrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludCcsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkaW5nID0gdGhpcy5fX3JlYWQsXG5cdFx0XHRyZWFkID0gMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNZID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuXHRcdFx0dGhpcy5fc2V0KGFyZzAsIGhhc1kgPyBhcmcxIDogYXJnMCk7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0cmVhZCA9IGhhc1kgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgb2JqID0gdHlwZSA9PT0gJ3N0cmluZycgPyBhcmcwLnNwbGl0KC9bXFxzLF0rLykgfHwgW10gOiBhcmcwO1xuXHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHRoaXMuX3NldCgrb2JqWzBdLCArKG9iai5sZW5ndGggPiAxID8gb2JqWzFdIDogb2JqWzBdKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCd4JyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai54IHx8IDAsIG9iai55IHx8IDApO1xuXHRcdFx0fSBlbHNlIGlmICgnd2lkdGgnIGluIG9iaikge1xuXHRcdFx0XHR0aGlzLl9zZXQob2JqLndpZHRoIHx8IDAsIG9iai5oZWlnaHQgfHwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKCdhbmdsZScgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoubGVuZ3RoIHx8IDAsIDApO1xuXHRcdFx0XHR0aGlzLnNldEFuZ2xlKG9iai5hbmdsZSB8fCAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdFx0cmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gdGhpcyA9PT0gcG9pbnQgfHwgcG9pbnRcblx0XHRcdFx0JiYgKHRoaXMueCA9PT0gcG9pbnQueCAmJiB0aGlzLnkgPT09IHBvaW50Lnlcblx0XHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHBvaW50KVxuXHRcdFx0XHRcdFx0JiYgdGhpcy54ID09PSBwb2ludFswXSAmJiB0aGlzLnkgPT09IHBvaW50WzFdKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSldO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKHRoaXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBhbmdsZSA9IHRoaXMuX2FuZ2xlIHx8IDA7XG5cdFx0XHR0aGlzLl9zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKVxuXHRcdFx0XHR0aGlzLmdldEFuZ2xlKCk7XG5cdFx0XHR0aGlzLl9zZXQoXG5cdFx0XHRcdHRoaXMueCAqIHNjYWxlLFxuXHRcdFx0XHR0aGlzLnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblx0fSxcblxuXHRnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG5cdHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuXHRnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5fYW5nbGUgfHwgMFxuXHRcdFx0XHRcdDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcblx0XHRcdFx0cmV0dXJuIE1hdGguYWNvcyhhIDwgLTEgPyAtMSA6IGEgPiAxID8gMSA6IGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXHRcdGlmICghdGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLl9zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRRdWFkcmFudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCA+PSAwID8gdGhpcy55ID49IDAgPyAxIDogNCA6IHRoaXMueSA+PSAwID8gMiA6IDM7XG5cdH1cbn0sIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldERpcmVjdGVkQW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gTWF0aC5hdGFuMih0aGlzLmNyb3NzKHBvaW50KSwgdGhpcy5kb3QocG9pbnQpKSAqIDE4MCAvIE1hdGguUEk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54IC0gdGhpcy54LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLnksXG5cdFx0XHRkID0geCAqIHggKyB5ICogeSxcblx0XHRcdHNxdWFyZWQgPSBCYXNlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gc3F1YXJlZCA/IGQgOiBNYXRoLnNxcnQoZCk7XG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpXG5cdFx0XHRsZW5ndGggPSAxO1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRMZW5ndGgoKSxcblx0XHRcdHNjYWxlID0gY3VycmVudCAhPT0gMCA/IGxlbmd0aCAvIGN1cnJlbnQgOiAwLFxuXHRcdFx0cG9pbnQgPSBuZXcgUG9pbnQodGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlKTtcblx0XHRpZiAoc2NhbGUgPj0gMClcblx0XHRcdHBvaW50Ll9hbmdsZSA9IHRoaXMuX2FuZ2xlO1xuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlLCBjZW50ZXIpIHtcblx0XHRpZiAoYW5nbGUgPT09IDApXG5cdFx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHRcdGFuZ2xlID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdHZhciBwb2ludCA9IGNlbnRlciA/IHRoaXMuc3VidHJhY3QoY2VudGVyKSA6IHRoaXMsXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogY29zIC0gcG9pbnQueSAqIHNpbixcblx0XHRcdHBvaW50LnggKiBzaW4gKyBwb2ludC55ICogY29zXG5cdFx0KTtcblx0XHRyZXR1cm4gY2VudGVyID8gcG9pbnQuYWRkKGNlbnRlcikgOiBwb2ludDtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHRoaXMpIDogdGhpcztcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHBvaW50LngsIHRoaXMueSArIHBvaW50LnkpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBwb2ludC54LCB0aGlzLnkgLSBwb2ludC55KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAlIHBvaW50LngsIHRoaXMueSAlIHBvaW50LnkpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCgtdGhpcy54LCAtdGhpcy55KTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcyk7XG5cdH0sXG5cblx0aXNDbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0dG9sZXJhbmNlID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDw9IHRvbGVyYW5jZTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBQb2ludC5pc0NvbGxpbmVhcih0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNDb2xpbmVhcjogJyNpc0NvbGxpbmVhcicsXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIFBvaW50LmlzT3J0aG9nb25hbCh0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHRoaXMueCkgJiYgaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0aXNJblF1YWRyYW50OiBmdW5jdGlvbihxKSB7XG5cdFx0cmV0dXJuIHRoaXMueCAqIChxID4gMSAmJiBxIDwgNCA/IC0xIDogMSkgPj0gMFxuXHRcdFx0JiYgdGhpcy55ICogKHEgPiAyID8gLTEgOiAxKSA+PSAwO1xuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC54ICsgdGhpcy55ICogcG9pbnQueTtcblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC55IC0gdGhpcy55ICogcG9pbnQueDtcblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRzY2FsZSA9IHBvaW50LmlzWmVybygpID8gMCA6IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdHBvaW50LnggKiBzY2FsZSxcblx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fSxcblxuXHRcdGlzQ29sbGluZWFyOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHgxICogeTIgLSB5MSAqIHgyKVxuXHRcdFx0XHRcdDw9IE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcblx0XHRcdFx0XHRcdCogMWUtODtcblx0XHR9LFxuXG5cdFx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuXHRcdFx0cmV0dXJuIE1hdGguYWJzKHgxICogeDIgKyB5MSAqIHkyKVxuXHRcdFx0XHRcdDw9IE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcblx0XHRcdFx0XHRcdCogMWUtODtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgb3AgPSBNYXRoW2tleV07XG5cdHRoaXNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQob3AodGhpcy54KSwgb3AodGhpcy55KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkUG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludCh4LCB5LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24oeCwgeSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIHRoaXMuX2dldFNlbGVjdGlvbigpKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlU2VsZWN0aW9uKHRoaXMuX2dldFNlbGVjdGlvbigpLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0X2dldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldHRlciA9PT0gJ3NldFBvc2l0aW9uJyA/IDQgOiAwO1xuXHR9XG59KTtcblxudmFyIFNpemUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NpemUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkaW5nID0gdGhpcy5fX3JlYWQsXG5cdFx0XHRyZWFkID0gMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNIZWlnaHQgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLl9zZXQoYXJnMCwgaGFzSGVpZ2h0ID8gYXJnMSA6IGFyZzApO1xuXHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdHJlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgb2JqID0gdHlwZSA9PT0gJ3N0cmluZycgPyBhcmcwLnNwbGl0KC9bXFxzLF0rLykgfHwgW10gOiBhcmcwO1xuXHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHRoaXMuX3NldCgrb2JqWzBdLCArKG9iai5sZW5ndGggPiAxID8gb2JqWzFdIDogb2JqWzBdKSk7XG5cdFx0XHR9IGVsc2UgaWYgKCd3aWR0aCcgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoud2lkdGggfHwgMCwgb2JqLmhlaWdodCB8fCAwKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3gnIGluIG9iaikge1xuXHRcdFx0XHR0aGlzLl9zZXQob2JqLnggfHwgMCwgb2JqLnkgfHwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZXQoMCwgMCk7XG5cdFx0XHRcdHJlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocmVhZGluZylcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXQ6ICcjaW5pdGlhbGl6ZScsXG5cblx0X3NldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRyZXR1cm4gc2l6ZSA9PT0gdGhpcyB8fCBzaXplICYmICh0aGlzLndpZHRoID09PSBzaXplLndpZHRoXG5cdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodFxuXHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHNpemUpICYmIHRoaXMud2lkdGggPT09IHNpemVbMF1cblx0XHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZVsxXSkgfHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCArIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICsgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKiBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAqIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggJSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAlIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSgtdGhpcy53aWR0aCwgLXRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdHJldHVybiBpc1plcm8odGhpcy53aWR0aCkgJiYgaXNaZXJvKHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc05hTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGlzTmFOKHRoaXMud2lkdGgpIHx8IGlzTmFOKHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0bWluOiBmdW5jdGlvbihzaXplMSwgc2l6ZTIpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdFx0TWF0aC5taW4oc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSxcblx0XHRcdFx0TWF0aC5taW4oc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbihzaXplMSwgc2l6ZTIpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdFx0TWF0aC5tYXgoc2l6ZTEud2lkdGgsIHNpemUyLndpZHRoKSxcblx0XHRcdFx0TWF0aC5tYXgoc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgU2l6ZShNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgb3AgPSBNYXRoW2tleV07XG5cdHRoaXNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZShvcCh0aGlzLndpZHRoKSwgb3AodGhpcy5oZWlnaHQpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRTaXplID0gU2l6ZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmVjdGFuZ2xlJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRoaXMuX3NldChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcblx0XHRcdHJlYWQgPSA0O1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fc2V0KDAsIDAsIDAsIDApO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMuX3NldC5hcHBseSh0aGlzLCBhcmcwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAueCAhPT0gdW5kZWZpbmVkIHx8IGFyZzAud2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9zZXQoYXJnMC54IHx8IDAsIGFyZzAueSB8fCAwLFxuXHRcdFx0XHRcdFx0YXJnMC53aWR0aCB8fCAwLCBhcmcwLmhlaWdodCB8fCAwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAuZnJvbSA9PT0gdW5kZWZpbmVkICYmIGFyZzAudG8gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9zZXQoMCwgMCwgMCwgMCk7XG5cdFx0XHRcdEJhc2UuZmlsdGVyKHRoaXMsIGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHJlYWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIGZybSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdG5leHQgPSBCYXNlLnBlZWsoYXJndW1lbnRzKSxcblx0XHRcdFx0eCA9IGZybS54LFxuXHRcdFx0XHR5ID0gZnJtLnksXG5cdFx0XHRcdHdpZHRoLFxuXHRcdFx0XHRoZWlnaHQ7XG5cdFx0XHRpZiAobmV4dCAmJiBuZXh0LnggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdHx8IEJhc2UuaGFzTmFtZWQoYXJndW1lbnRzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcblx0XHRcdFx0d2lkdGggPSB0by54IC0geDtcblx0XHRcdFx0aGVpZ2h0ID0gdG8ueSAtIHk7XG5cdFx0XHRcdGlmICh3aWR0aCA8IDApIHtcblx0XHRcdFx0XHR4ID0gdG8ueDtcblx0XHRcdFx0XHR3aWR0aCA9IC13aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGVpZ2h0IDwgMCkge1xuXHRcdFx0XHRcdHkgPSB0by55O1xuXHRcdFx0XHRcdGhlaWdodCA9IC1oZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRyZWFkID0gYXJndW1lbnRzLl9faW5kZXg7XG5cdFx0XHR2YXIgZmlsdGVyZWQgPSBhcmd1bWVudHMuX19maWx0ZXJlZDtcblx0XHRcdGlmIChmaWx0ZXJlZClcblx0XHRcdFx0dGhpcy5fX2ZpbHRlcmVkID0gZmlsdGVyZWQ7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXQ6ICcjaW5pdGlhbGl6ZScsXG5cblx0X3NldDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHJ0ID0gQmFzZS5pc1BsYWluVmFsdWUocmVjdClcblx0XHRcdFx0PyBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdDogcmVjdDtcblx0XHRyZXR1cm4gcnQgPT09IHRoaXNcblx0XHRcdFx0fHwgcnQgJiYgdGhpcy54ID09PSBydC54ICYmIHRoaXMueSA9PT0gcnQueVxuXHRcdFx0XHRcdCYmIHRoaXMud2lkdGggPT09IHJ0LndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBydC5oZWlnaHRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KVxuXHRcdFx0XHQrICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpXG5cdFx0XHRcdCsgJywgd2lkdGg6ICcgKyBmLm51bWJlcih0aGlzLndpZHRoKVxuXHRcdFx0XHQrICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KVxuXHRcdFx0XHQrICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLnkpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLndpZHRoKSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy5oZWlnaHQpXTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBTaXplIDogTGlua2VkU2l6ZTtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0X2Z3OiAxLFxuXHRfZmg6IDEsXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHN4ID0gdGhpcy5fc3gsXG5cdFx0XHRzeSA9IHRoaXMuX3N5LFxuXHRcdFx0dyA9IHNpemUud2lkdGgsXG5cdFx0XHRoID0gc2l6ZS5oZWlnaHQ7XG5cdFx0aWYgKHN4KSB7XG5cdFx0XHR0aGlzLnggKz0gKHRoaXMud2lkdGggLSB3KSAqIHN4O1xuXHRcdH1cblx0XHRpZiAoc3kpIHtcblx0XHRcdHRoaXMueSArPSAodGhpcy5oZWlnaHQgLSBoKSAqIHN5O1xuXHRcdH1cblx0XHR0aGlzLndpZHRoID0gdztcblx0XHR0aGlzLmhlaWdodCA9IGg7XG5cdFx0dGhpcy5fZncgPSB0aGlzLl9maCA9IDE7XG5cdH0sXG5cblx0Z2V0TGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueDtcblx0fSxcblxuXHRzZXRMZWZ0OiBmdW5jdGlvbihsZWZ0KSB7XG5cdFx0aWYgKCF0aGlzLl9mdykge1xuXHRcdFx0dmFyIGFtb3VudCA9IGxlZnQgLSB0aGlzLng7XG5cdFx0XHR0aGlzLndpZHRoIC09IHRoaXMuX3N4ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuXHRcdH1cblx0XHR0aGlzLnggPSBsZWZ0O1xuXHRcdHRoaXMuX3N4ID0gdGhpcy5fZncgPSAwO1xuXHR9LFxuXG5cdGdldFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fSxcblxuXHRzZXRUb3A6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdGlmICghdGhpcy5fZmgpIHtcblx0XHRcdHZhciBhbW91bnQgPSB0b3AgLSB0aGlzLnk7XG5cdFx0XHR0aGlzLmhlaWdodCAtPSB0aGlzLl9zeSA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcblx0XHR9XG5cdFx0dGhpcy55ID0gdG9wO1xuXHRcdHRoaXMuX3N5ID0gdGhpcy5fZmggPSAwO1xuXHR9LFxuXG5cdGdldFJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcblx0fSxcblxuXHRzZXRSaWdodDogZnVuY3Rpb24ocmlnaHQpIHtcblx0XHRpZiAoIXRoaXMuX2Z3KSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gcmlnaHQgLSB0aGlzLng7XG5cdFx0XHR0aGlzLndpZHRoID0gdGhpcy5fc3ggPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG5cdFx0fVxuXHRcdHRoaXMueCA9IHJpZ2h0IC0gdGhpcy53aWR0aDtcblx0XHR0aGlzLl9zeCA9IDE7XG5cdFx0dGhpcy5fZncgPSAwO1xuXHR9LFxuXG5cdGdldEJvdHRvbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdHNldEJvdHRvbTogZnVuY3Rpb24oYm90dG9tKSB7XG5cdFx0aWYgKCF0aGlzLl9maCkge1xuXHRcdFx0dmFyIGFtb3VudCA9IGJvdHRvbSAtIHRoaXMueTtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5fc3kgPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG5cdFx0fVxuXHRcdHRoaXMueSA9IGJvdHRvbSAtIHRoaXMuaGVpZ2h0O1xuXHRcdHRoaXMuX3N5ID0gMTtcblx0XHR0aGlzLl9maCA9IDA7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggLyAyO1xuXHR9LFxuXG5cdHNldENlbnRlclg6IGZ1bmN0aW9uKHgpIHtcblx0XHRpZiAodGhpcy5fZncgfHwgdGhpcy5fc3ggPT09IDAuNSkge1xuXHRcdFx0dGhpcy54ID0geCAtIHRoaXMud2lkdGggLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5fc3gpIHtcblx0XHRcdFx0dGhpcy54ICs9ICh4IC0gdGhpcy54KSAqIDIgKiB0aGlzLl9zeDtcblx0XHRcdH1cblx0XHRcdHRoaXMud2lkdGggPSAoeCAtIHRoaXMueCkgKiAyO1xuXHRcdH1cblx0XHR0aGlzLl9zeCA9IDAuNTtcblx0XHR0aGlzLl9mdyA9IDA7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMjtcblx0fSxcblxuXHRzZXRDZW50ZXJZOiBmdW5jdGlvbih5KSB7XG5cdFx0aWYgKHRoaXMuX2ZoIHx8IHRoaXMuX3N5ID09PSAwLjUpIHtcblx0XHRcdHRoaXMueSA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLl9zeSkge1xuXHRcdFx0XHR0aGlzLnkgKz0gKHkgLSB0aGlzLnkpICogMiAqIHRoaXMuX3N5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oZWlnaHQgPSAoeSAtIHRoaXMueSkgKiAyO1xuXHRcdH1cblx0XHR0aGlzLl9zeSA9IDAuNTtcblx0XHR0aGlzLl9maCA9IDA7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0Q2VudGVyWCgpLCB0aGlzLmdldENlbnRlclkoKSwgdGhpcywgJ3NldENlbnRlcicpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWChwb2ludC54KTtcblx0XHR0aGlzLnNldENlbnRlclkocG9pbnQueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGFyZyAmJiBhcmcud2lkdGggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHR8fCAoQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKS5sZW5ndGggPT09IDRcblx0XHRcdFx0PyB0aGlzLl9jb250YWluc1JlY3RhbmdsZShSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0XHQ6IHRoaXMuX2NvbnRhaW5zUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0X2NvbnRhaW5zUmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHggPSByZWN0LngsXG5cdFx0XHR5ID0gcmVjdC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4ICsgcmVjdC53aWR0aCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHkgKyByZWN0LmhlaWdodCA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRlcHNpbG9uID0gQmFzZS5yZWFkKGFyZ3VtZW50cykgfHwgMDtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+IHRoaXMueCAtIGVwc2lsb25cblx0XHRcdFx0JiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPiB0aGlzLnkgLSBlcHNpbG9uXG5cdFx0XHRcdCYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGggKyBlcHNpbG9uXG5cdFx0XHRcdCYmIHJlY3QueSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0ICsgZXBzaWxvbjtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0dW5pdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0aW5jbHVkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciB4MSA9IE1hdGgubWluKHRoaXMueCwgcG9pbnQueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcG9pbnQueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHBvaW50LngpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcG9pbnQueSk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbW91bnQgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGhvciA9IGFtb3VudC53aWR0aCxcblx0XHRcdHZlciA9IGFtb3VudC5oZWlnaHQ7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gaG9yIC8gMiwgdGhpcy55IC0gdmVyIC8gMixcblx0XHRcdFx0dGhpcy53aWR0aCArIGhvciwgdGhpcy5oZWlnaHQgKyB2ZXIpO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbihob3IsIHZlcikge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZCh0aGlzLndpZHRoICogaG9yIC0gdGhpcy53aWR0aCxcblx0XHRcdFx0dGhpcy5oZWlnaHQgKiAodmVyID09PSB1bmRlZmluZWQgPyBob3IgOiB2ZXIpIC0gdGhpcy5oZWlnaHQpO1xuXHR9XG59LCBCYXNlLmVhY2goW1xuXHRcdFsnVG9wJywgJ0xlZnQnXSwgWydUb3AnLCAnUmlnaHQnXSxcblx0XHRbJ0JvdHRvbScsICdMZWZ0J10sIFsnQm90dG9tJywgJ1JpZ2h0J10sXG5cdFx0WydMZWZ0JywgJ0NlbnRlciddLCBbJ1RvcCcsICdDZW50ZXInXSxcblx0XHRbJ1JpZ2h0JywgJ0NlbnRlciddLCBbJ0JvdHRvbScsICdDZW50ZXInXVxuXHRdLFxuXHRmdW5jdGlvbihwYXJ0cywgaW5kZXgpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzLmpvaW4oJycpLFxuXHRcdFx0eEZpcnN0ID0gL15bUkxdLy50ZXN0KHBhcnQpO1xuXHRcdGlmIChpbmRleCA+PSA0KVxuXHRcdFx0cGFydHNbMV0gKz0geEZpcnN0ID8gJ1knIDogJ1gnO1xuXHRcdHZhciB4ID0gcGFydHNbeEZpcnN0ID8gMCA6IDFdLFxuXHRcdFx0eSA9IHBhcnRzW3hGaXJzdCA/IDEgOiAwXSxcblx0XHRcdGdldFggPSAnZ2V0JyArIHgsXG5cdFx0XHRnZXRZID0gJ2dldCcgKyB5LFxuXHRcdFx0c2V0WCA9ICdzZXQnICsgeCxcblx0XHRcdHNldFkgPSAnc2V0JyArIHksXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQsXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQ7XG5cdFx0dGhpc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0XHRyZXR1cm4gbmV3IGN0b3IodGhpc1tnZXRYXSgpLCB0aGlzW2dldFldKCksIHRoaXMsIHNldCk7XG5cdFx0fTtcblx0XHR0aGlzW3NldF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHRoaXNbc2V0WF0ocG9pbnQueCk7XG5cdFx0XHR0aGlzW3NldFldKHBvaW50LnkpO1xuXHRcdH07XG5cdH0sIHtcblx0XHRiZWFuczogdHJ1ZVxuXHR9XG4pKTtcblxudmFyIExpbmtlZFJlY3RhbmdsZSA9IFJlY3RhbmdsZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3NldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgcHJvdG8gPSBSZWN0YW5nbGUucHJvdG90eXBlO1xuXG5cdHJldHVybiBCYXNlLmVhY2goWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiAyKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLl9jaGFuZ2VTZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRvd25lci5fY2hhbmdlU2VsZWN0aW9uKDIsIHNlbGVjdGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cdCk7XG59KTtcblxudmFyIE1hdHJpeCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTWF0cml4JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNYXRyaXgoYXJnLCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID49IDYpIHtcblx0XHRcdHRoaXMuX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEgfHwgY291bnQgPT09IDIpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZy5fYSwgYXJnLl9iLCBhcmcuX2MsIGFyZy5fZCwgYXJnLl90eCwgYXJnLl90eSxcblx0XHRcdFx0XHRcdF9kb250Tm90aWZ5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuX3NldC5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0X2RvbnROb3RpZnkgPyBhcmcuY29uY2F0KFtfZG9udE5vdGlmeV0pIDogYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9rID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghY291bnQpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBtYXRyaXggcGFyYW1ldGVycycpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXQ6ICcjaW5pdGlhbGl6ZScsXG5cblx0X3NldDogZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSBhO1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHRoaXMuX2MgPSBjO1xuXHRcdHRoaXMuX2QgPSBkO1xuXHRcdHRoaXMuX3R4ID0gdHg7XG5cdFx0dGhpcy5fdHkgPSB0eTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5nZXRWYWx1ZXMoKSwgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0aWYgKG93bmVyLl9hcHBseU1hdHJpeCkge1xuXHRcdFx0XHRvd25lci50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvd25lci5fY2hhbmdlZCg5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsXG5cdFx0XHRcdHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiBteCA9PT0gdGhpcyB8fCBteCAmJiB0aGlzLl9hID09PSBteC5fYSAmJiB0aGlzLl9iID09PSBteC5fYlxuXHRcdFx0XHQmJiB0aGlzLl9jID09PSBteC5fYyAmJiB0aGlzLl9kID09PSBteC5fZFxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gbXguX3R4ICYmIHRoaXMuX3R5ID09PSBteC5fdHk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAnW1snICsgW2YubnVtYmVyKHRoaXMuX2EpLCBmLm51bWJlcih0aGlzLl9jKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eCldLmpvaW4oJywgJykgKyAnXSwgWydcblx0XHRcdFx0KyBbZi5udW1iZXIodGhpcy5fYiksIGYubnVtYmVyKHRoaXMuX2QpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R5KV0uam9pbignLCAnKSArICddXSc7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IHRoaXMuX2QgPSAxO1xuXHRcdHRoaXMuX2IgPSB0aGlzLl9jID0gdGhpcy5fdHggPSB0aGlzLl90eSA9IDA7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBseTogZnVuY3Rpb24ocmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUsIEJhc2UucGljayhyZWN1cnNpdmVseSwgdHJ1ZSksXG5cdFx0XHRcdFx0X3NldEFwcGx5TWF0cml4KTtcblx0XHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHR0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jO1xuXHRcdHRoaXMuX3R5ICs9IHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR0aGlzLl9hICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYiAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueTtcblx0XHR0aGlzLl9kICo9IHNjYWxlLnk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0YW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuXHRcdFx0eCA9IGNlbnRlci54LFxuXHRcdFx0eSA9IGNlbnRlci55LFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0dHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG5cdFx0XHR0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcblx0XHRcdGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYztcblx0XHR0aGlzLl9iID0gY29zICogYiArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fYyA9IC1zaW4gKiBhICsgY29zICogYztcblx0XHR0aGlzLl9kID0gLXNpbiAqIGIgKyBjb3MgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYztcblx0XHR0aGlzLl90eSArPSB0eCAqIGIgKyB0eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNoZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2hlYXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYjtcblx0XHR0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9jO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fYyArPSBzaGVhci54ICogYTtcblx0XHR0aGlzLl9kICs9IHNoZWFyLnggKiBiO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRza2V3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2tldyA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0dG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksXG5cdFx0XHRcdE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuXHRcdHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24obXgsIF9kb250Tm90aWZ5KSB7XG5cdFx0aWYgKG14KSB7XG5cdFx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0XHRiMiA9IG14Ll9jLFxuXHRcdFx0XHRjMiA9IG14Ll9iLFxuXHRcdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYzIgKiBjMTtcblx0XHRcdHRoaXMuX2MgPSBiMiAqIGExICsgZDIgKiBjMTtcblx0XHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYzIgKiBkMTtcblx0XHRcdHRoaXMuX2QgPSBiMiAqIGIxICsgZDIgKiBkMTtcblx0XHRcdHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYzE7XG5cdFx0XHR0aGlzLl90eSArPSB0eDIgKiBiMSArIHR5MiAqIGQxO1xuXHRcdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbihteCwgX2RvbnROb3RpZnkpIHtcblx0XHRpZiAobXgpIHtcblx0XHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdFx0YjIgPSBteC5fYyxcblx0XHRcdFx0YzIgPSBteC5fYixcblx0XHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGIyICogYjE7XG5cdFx0XHR0aGlzLl9jID0gYTIgKiBjMSArIGIyICogZDE7XG5cdFx0XHR0aGlzLl9iID0gYzIgKiBhMSArIGQyICogYjE7XG5cdFx0XHR0aGlzLl9kID0gYzIgKiBjMSArIGQyICogZDE7XG5cdFx0XHR0aGlzLl90eCA9IGEyICogdHgxICsgYjIgKiB0eTEgKyB0eDI7XG5cdFx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGVuZGVkOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuYXBwZW5kKG14KTtcblx0fSxcblxuXHRwcmVwZW5kZWQ6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5wcmVwZW5kKG14KTtcblx0fSxcblxuXHRpbnZlcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZCxcblx0XHRcdHR4ID0gdGhpcy5fdHgsXG5cdFx0XHR0eSA9IHRoaXMuX3R5LFxuXHRcdFx0ZGV0ID0gYSAqIGQgLSBiICogYyxcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0eCkgJiYgaXNGaW5pdGUodHkpKSB7XG5cdFx0XHR0aGlzLl9hID0gZCAvIGRldDtcblx0XHRcdHRoaXMuX2IgPSAtYiAvIGRldDtcblx0XHRcdHRoaXMuX2MgPSAtYyAvIGRldDtcblx0XHRcdHRoaXMuX2QgPSBhIC8gZGV0O1xuXHRcdFx0dGhpcy5fdHggPSAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldDtcblx0XHRcdHRoaXMuX3R5ID0gKGIgKiB0eCAtIGEgKiB0eSkgLyBkZXQ7XG5cdFx0XHRyZXMgPSB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGludmVydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLmludmVydCgpO1xuXHR9LFxuXG5cdGNvbmNhdGVuYXRlOiAnI2FwcGVuZCcsXG5cdHByZUNvbmNhdGVuYXRlOiAnI3ByZXBlbmQnLFxuXHRjaGFpbjogJyNhcHBlbmRlZCcsXG5cblx0X3NoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0X29yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYyAqIHRoaXMuX2I7XG5cdFx0cmV0dXJuIGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpO1xuXHR9LFxuXG5cdGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc0ludmVydGlibGUoKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKCBzcmMsIGRzdCwgY291bnQpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDNcblx0XHRcdD8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0Ll9zZXQoXG5cdFx0XHRcdHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eCxcblx0XHRcdFx0eCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbWF4ID0gMiAqIGNvdW50OyBpIDwgbWF4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gc3JjW2ldLFxuXHRcdFx0XHR5ID0gc3JjW2kgKyAxXTtcblx0XHRcdGRzdFtpXSA9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eDtcblx0XHRcdGRzdFtpICsgMV0gPSB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG5cdFx0fVxuXHRcdHJldHVybiBkc3Q7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsXG5cdFx0XHR5MSA9IHJlY3QueSxcblx0XHRcdHgyID0geDEgKyByZWN0LndpZHRoLFxuXHRcdFx0eTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0Y29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIDQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuXHRcdFx0bWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcblx0XHRcdHZhciB2YWwgPSBjb29yZHNbaV0sXG5cdFx0XHRcdGogPSBpICYgMTtcblx0XHRcdGlmICh2YWwgPCBtaW5bal0pIHtcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgPiBtYXhbal0pIHtcblx0XHRcdFx0bWF4W2pdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHJldHVybiBkZXN0Ll9zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0aW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kLFxuXHRcdFx0dHggPSB0aGlzLl90eCxcblx0XHRcdHR5ID0gdGhpcy5fdHksXG5cdFx0XHRkZXQgPSBhICogZCAtIGIgKiBjLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAoZGV0ICYmICFpc05hTihkZXQpICYmIGlzRmluaXRlKHR4KSAmJiBpc0Zpbml0ZSh0eSkpIHtcblx0XHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuXHRcdFx0aWYgKCFkZXN0KVxuXHRcdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0XHRyZXMgPSBkZXN0Ll9zZXQoXG5cdFx0XHRcdFx0KHggKiBkIC0geSAqIGMpIC8gZGV0LFxuXHRcdFx0XHRcdCh5ICogYSAtIHggKiBiKSAvIGRldCxcblx0XHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0ZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2QsXG5cdFx0XHRkZXQgPSBhICogZCAtIGIgKiBjLFxuXHRcdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRcdGF0YW4yID0gTWF0aC5hdGFuMixcblx0XHRcdGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0cm90YXRlLFxuXHRcdFx0c2NhbGUsXG5cdFx0XHRza2V3O1xuXHRcdGlmIChhICE9PSAwIHx8IGIgIT09IDApIHtcblx0XHRcdHZhciByID0gc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdHJvdGF0ZSA9IE1hdGguYWNvcyhhIC8gcikgKiAoYiA+IDAgPyAxIDogLTEpO1xuXHRcdFx0c2NhbGUgPSBbciwgZGV0IC8gcl07XG5cdFx0XHRza2V3ID0gW2F0YW4yKGEgKiBjICsgYiAqIGQsIHIgKiByKSwgMF07XG5cdFx0fSBlbHNlIGlmIChjICE9PSAwIHx8IGQgIT09IDApIHtcblx0XHRcdHZhciBzID0gc3FydChjICogYyArIGQgKiBkKTtcblx0XHRcdHJvdGF0ZSA9IE1hdGguYXNpbihjIC8gcykgICogKGQgPiAwID8gMSA6IC0xKTtcblx0XHRcdHNjYWxlID0gW2RldCAvIHMsIHNdO1xuXHRcdFx0c2tldyA9IFswLCBhdGFuMihhICogYyArIGIgKiBkLCBzICogcyldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyb3RhdGUgPSAwO1xuXHRcdFx0c2tldyA9IHNjYWxlID0gWzAsIDBdO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHJhbnNsYXRpb246IHRoaXMuZ2V0VHJhbnNsYXRpb24oKSxcblx0XHRcdHJvdGF0aW9uOiByb3RhdGUgKiBkZWdyZWVzLFxuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlKSxcblx0XHRcdHNrZXdpbmc6IG5ldyBQb2ludChza2V3WzBdICogZGVncmVlcywgc2tld1sxXSAqIGRlZ3JlZXMpXG5cdFx0fTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSBdO1xuXHR9LFxuXG5cdGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5zY2FsaW5nO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnJvdGF0aW9uO1xuXHR9LFxuXG5cdGFwcGx5VG9Db250ZXh0OiBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuaXNJZGVudGl0eSgpKSB7XG5cdFx0XHRjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsXG5cdFx0XHRcdFx0dGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2EnLCAnYicsICdjJywgJ2QnLCAndHgnLCAndHknXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0cHJvcCA9ICdfJyArIGtleTtcblx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXNbcHJvcF07XG5cdH07XG5cdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5lID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdMaW5lJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMaW5lKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcblx0XHR2YXIgYXNWZWN0b3IgPSBmYWxzZTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzE7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzI7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzM7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMC54O1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcwLnk7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzEueDtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMS55O1xuXHRcdFx0YXNWZWN0b3IgPSBhcmcyO1xuXHRcdH1cblx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHR0aGlzLl92eCAtPSB0aGlzLl9weDtcblx0XHRcdHRoaXMuX3Z5IC09IHRoaXMuX3B5O1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl9weCwgdGhpcy5fcHkpO1xuXHR9LFxuXG5cdGdldFZlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmVjdG9yKCkuZ2V0TGVuZ3RoKCk7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbihsaW5lLCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0bGluZS5fcHgsIGxpbmUuX3B5LCBsaW5lLl92eCwgbGluZS5fdnksXG5cdFx0XHRcdHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldFNpZGU6IGZ1bmN0aW9uKHBvaW50LCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lkZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLmdldFNpZ25lZERpc3RhbmNlKHBvaW50KSk7XG5cdH0sXG5cblx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UodGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihsaW5lKSB7XG5cdFx0cmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRyZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbihwMXgsIHAxeSwgdjF4LCB2MXksIHAyeCwgcDJ5LCB2MngsIHYyeSwgYXNWZWN0b3IsXG5cdFx0XHRcdGlzSW5maW5pdGUpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0djF4IC09IHAxeDtcblx0XHRcdFx0djF5IC09IHAxeTtcblx0XHRcdFx0djJ4IC09IHAyeDtcblx0XHRcdFx0djJ5IC09IHAyeTtcblx0XHRcdH1cblx0XHRcdHZhciBjcm9zcyA9IHYxeCAqIHYyeSAtIHYxeSAqIHYyeDtcblx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhjcm9zcykpIHtcblx0XHRcdFx0dmFyIGR4ID0gcDF4IC0gcDJ4LFxuXHRcdFx0XHRcdGR5ID0gcDF5IC0gcDJ5LFxuXHRcdFx0XHRcdHUxID0gKHYyeCAqIGR5IC0gdjJ5ICogZHgpIC8gY3Jvc3MsXG5cdFx0XHRcdFx0dTIgPSAodjF4ICogZHkgLSB2MXkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRcdFx0dU1pbiA9IC1lcHNpbG9uLFxuXHRcdFx0XHRcdHVNYXggPSAxICsgZXBzaWxvbjtcblx0XHRcdFx0aWYgKGlzSW5maW5pdGVcblx0XHRcdFx0XHRcdHx8IHVNaW4gPCB1MSAmJiB1MSA8IHVNYXggJiYgdU1pbiA8IHUyICYmIHUyIDwgdU1heCkge1xuXHRcdFx0XHRcdGlmICghaXNJbmZpbml0ZSkge1xuXHRcdFx0XHRcdFx0dTEgPSB1MSA8PSAwID8gMCA6IHUxID49IDEgPyAxIDogdTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdHAxeCArIHUxICogdjF4LFxuXHRcdFx0XHRcdFx0XHRwMXkgKyB1MSAqIHYxeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0U2lkZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yLCBpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHZhciB2MnggPSB4IC0gcHgsXG5cdFx0XHRcdHYyeSA9IHkgLSBweSxcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnkgLSB2MnkgKiB2eDtcblx0XHRcdGlmICghaXNJbmZpbml0ZSAmJiBOdW1lcmljYWwuaXNaZXJvKGNjdykpIHtcblx0XHRcdFx0Y2N3ID0gKHYyeCAqIHZ4ICsgdjJ4ICogdngpIC8gKHZ4ICogdnggKyB2eSAqIHZ5KTtcblx0XHRcdFx0aWYgKGNjdyA+PSAwICYmIGNjdyA8PSAxKVxuXHRcdFx0XHRcdGNjdyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2N3IDwgMCA/IC0xIDogY2N3ID4gMCA/IDEgOiAwO1xuXHRcdH0sXG5cblx0XHRnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2eCA9PT0gMCA/IHZ5ID4gMCA/IHggLSBweCA6IHB4IC0geFxuXHRcdFx0XHQgOiB2eSA9PT0gMCA/IHZ4IDwgMCA/IHkgLSBweSA6IHB5IC0geVxuXHRcdFx0XHQgOiAoKHgtcHgpICogdnkgLSAoeS1weSkgKiB2eCkgLyBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXHRcdH0sXG5cblx0XHRnZXREaXN0YW5jZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoXG5cdFx0XHRcdFx0TGluZS5nZXRTaWduZWREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgUHJvamVjdCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Byb2plY3QnLFxuXHRfbGlzdDogJ3Byb2plY3RzJyxcblx0X3JlZmVyZW5jZTogJ3Byb2plY3QnLFxuXHRfY29tcGFjdFNlcmlhbGl6ZTogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gbnVsbDtcblx0XHR0aGlzLl9jdXJyZW50U3R5bGUgPSBuZXcgU3R5bGUobnVsbCwgbnVsbCwgdGhpcyk7XG5cdFx0dGhpcy5fdmlldyA9IFZpZXcuY3JlYXRlKHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgfHwgQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKDEsIDEpKTtcblx0XHR0aGlzLl9zZWxlY3Rpb25JdGVtcyA9IHt9O1xuXHRcdHRoaXMuX3NlbGVjdGlvbkNvdW50ID0gMDtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uID0gMDtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuX2NoaWxkcmVuLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MsIGl0ZW0pIHtcblx0XHRpZiAoZmxhZ3MgJiAxKSB7XG5cdFx0XHR2YXIgdmlldyA9IHRoaXMuX3ZpZXc7XG5cdFx0XHRpZiAodmlldykge1xuXHRcdFx0XHR2aWV3Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGlmICghdmlldy5fcmVxdWVzdGVkICYmIHZpZXcuX2F1dG9VcGRhdGUpXG5cdFx0XHRcdFx0dmlldy5yZXF1ZXN0VXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlcztcblx0XHRpZiAoY2hhbmdlcyAmJiBpdGVtKSB7XG5cdFx0XHR2YXIgY2hhbmdlc0J5SWQgPSB0aGlzLl9jaGFuZ2VzQnlJZCxcblx0XHRcdFx0aWQgPSBpdGVtLl9pZCxcblx0XHRcdFx0ZW50cnkgPSBjaGFuZ2VzQnlJZFtpZF07XG5cdFx0XHRpZiAoZW50cnkpIHtcblx0XHRcdFx0ZW50cnkuZmxhZ3MgfD0gZmxhZ3M7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGFuZ2VzLnB1c2goY2hhbmdlc0J5SWRbaWRdID0geyBpdGVtOiBpdGVtLCBmbGFnczogZmxhZ3MgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHRjaGlsZHJlbltpXS5yZW1vdmUoKTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRpZiAoIXJlbW92ZS5iYXNlLmNhbGwodGhpcykpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3ZpZXcpXG5cdFx0XHR0aGlzLl92aWV3LnJlbW92ZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9LFxuXG5cdGdldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRTdHlsZTtcblx0fSxcblxuXHRzZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlLnNldChzdHlsZSk7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRnZXRPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGUuc2V0dGluZ3M7XG5cdH0sXG5cblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdH0sXG5cblx0Z2V0QWN0aXZlTGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoeyBwcm9qZWN0OiB0aGlzLCBpbnNlcnQ6IHRydWUgfSk7XG5cdH0sXG5cblx0Z2V0U3ltYm9sRGVmaW5pdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWZpbml0aW9ucyA9IFtdLFxuXHRcdFx0aWRzID0ge307XG5cdFx0dGhpcy5nZXRJdGVtcyh7XG5cdFx0XHRjbGFzczogU3ltYm9sSXRlbSxcblx0XHRcdG1hdGNoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHZhciBkZWZpbml0aW9uID0gaXRlbS5fZGVmaW5pdGlvbixcblx0XHRcdFx0XHRpZCA9IGRlZmluaXRpb24uX2lkO1xuXHRcdFx0XHRpZiAoIWlkc1tpZF0pIHtcblx0XHRcdFx0XHRpZHNbaWRdID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWZpbml0aW9ucy5wdXNoKGRlZmluaXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gZGVmaW5pdGlvbnM7XG5cdH0sXG5cblx0Z2V0U3ltYm9sczogJ2dldFN5bWJvbERlZmluaXRpb25zJyxcblxuXHRnZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcyxcblx0XHRcdGl0ZW1zID0gW107XG5cdFx0Zm9yICh2YXIgaWQgaW4gc2VsZWN0aW9uSXRlbXMpIHtcblx0XHRcdHZhciBpdGVtID0gc2VsZWN0aW9uSXRlbXNbaWRdLFxuXHRcdFx0XHRzZWxlY3Rpb24gPSBpdGVtLl9zZWxlY3Rpb247XG5cdFx0XHRpZiAoKHNlbGVjdGlvbiAmIDEpICYmIGl0ZW0uaXNJbnNlcnRlZCgpKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goaXRlbSk7XG5cdFx0XHR9IGVsc2UgaWYgKCFzZWxlY3Rpb24pIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBpZCA9IGl0ZW0uX2lkLFxuXHRcdFx0c2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcztcblx0XHRpZiAoaXRlbS5fc2VsZWN0aW9uKSB7XG5cdFx0XHRpZiAoc2VsZWN0aW9uSXRlbXNbaWRdICE9PSBpdGVtKSB7XG5cdFx0XHRcdHRoaXMuX3NlbGVjdGlvbkNvdW50Kys7XG5cdFx0XHRcdHNlbGVjdGlvbkl0ZW1zW2lkXSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3Rpb25JdGVtc1tpZF0gPT09IGl0ZW0pIHtcblx0XHRcdHRoaXMuX3NlbGVjdGlvbkNvdW50LS07XG5cdFx0XHRkZWxldGUgc2VsZWN0aW9uSXRlbXNbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRkZXNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdGlvbkl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXM7XG5cdFx0Zm9yICh2YXIgaSBpbiBzZWxlY3Rpb25JdGVtcylcblx0XHRcdHNlbGVjdGlvbkl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuXHR9LFxuXG5cdGFkZExheWVyOiBmdW5jdGlvbihsYXllcikge1xuXHRcdHJldHVybiB0aGlzLmluc2VydExheWVyKHVuZGVmaW5lZCwgbGF5ZXIpO1xuXHR9LFxuXG5cdGluc2VydExheWVyOiBmdW5jdGlvbihpbmRleCwgbGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikge1xuXHRcdFx0bGF5ZXIuX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgW2xheWVyXSwgaW5kZXgsIDApO1xuXHRcdFx0bGF5ZXIuX3NldFByb2plY3QodGhpcywgdHJ1ZSk7XG5cdFx0XHR2YXIgbmFtZSA9IGxheWVyLl9uYW1lO1xuXHRcdFx0aWYgKG5hbWUpXG5cdFx0XHRcdGxheWVyLnNldE5hbWUobmFtZSk7XG5cdFx0XHRpZiAodGhpcy5fY2hhbmdlcylcblx0XHRcdFx0bGF5ZXIuX2NoYW5nZWQoNSk7XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZUxheWVyKVxuXHRcdFx0XHR0aGlzLl9hY3RpdmVMYXllciA9IGxheWVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXllciA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBsYXllcjtcblx0fSxcblxuXHRfaW5zZXJ0SXRlbTogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9jcmVhdGVkKSB7XG5cdFx0aXRlbSA9IHRoaXMuaW5zZXJ0TGF5ZXIoaW5kZXgsIGl0ZW0pXG5cdFx0XHRcdHx8ICh0aGlzLl9hY3RpdmVMYXllciB8fCB0aGlzLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdG5ldyBMYXllcihJdGVtLk5PX0lOU0VSVCksIHRydWUpKVxuXHRcdFx0XHRcdFx0Lmluc2VydENoaWxkKGluZGV4LCBpdGVtKTtcblx0XHRpZiAoX2NyZWF0ZWQgJiYgaXRlbS5hY3RpdmF0ZSlcblx0XHRcdGl0ZW0uYWN0aXZhdGUoKTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIG51bGwsIG51bGwsIHRydWUpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9hY3RpdmVMYXllcjtcblx0XHRyZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIGxheWVyICYmIGxheWVyLmlzRW1wdHkoKSAmJiBsYXllcik7XG5cdH0sXG5cblx0cmVtb3ZlT246IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR2YXIgc2V0cyA9IHRoaXMuX3JlbW92ZVNldHM7XG5cdFx0aWYgKHNldHMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V1cCcpXG5cdFx0XHRcdHNldHMubW91c2VkcmFnID0gbnVsbDtcblx0XHRcdHZhciBzZXQgPSBzZXRzW3R5cGVdO1xuXHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRmb3IgKHZhciBpZCBpbiBzZXQpIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHNldFtpZF07XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHNldHMpIHtcblx0XHRcdFx0XHRcdHZhciBvdGhlciA9IHNldHNba2V5XTtcblx0XHRcdFx0XHRcdGlmIChvdGhlciAmJiBvdGhlciAhPSBzZXQpXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBvdGhlcltpdGVtLl9pZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0c1t0eXBlXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRwYXJhbSA9IG5ldyBCYXNlKHtcblx0XHRcdFx0b2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG5cdFx0XHRcdHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG5cdFx0XHRcdHZpZXdNYXRyaXg6IG1hdHJpeC5pc0lkZW50aXR5KCkgPyBudWxsIDogbWF0cml4LFxuXHRcdFx0XHRtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG5cdFx0XHRcdHVwZGF0ZU1hdHJpeDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0fVxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRpZiAodGhpcy5fc2VsZWN0aW9uQ291bnQgPiAwKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnN0cm9rZVdpZHRoID0gMTtcblx0XHRcdHZhciBpdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zLFxuXHRcdFx0XHRzaXplID0gdGhpcy5fc2NvcGUuc2V0dGluZ3MuaGFuZGxlU2l6ZSxcblx0XHRcdFx0dmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb247XG5cdFx0XHRmb3IgKHZhciBpZCBpbiBpdGVtcykge1xuXHRcdFx0XHRpdGVtc1tpZF0uX2RyYXdTZWxlY3Rpb24oY3R4LCBtYXRyaXgsIHNpemUsIGl0ZW1zLCB2ZXJzaW9uKTtcblx0XHRcdH1cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIEl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdHN0YXRpY3M6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcblx0XHRcdGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcylcblx0XHRcdFx0c3JjLl9zZXJpYWxpemVGaWVsZHMgPSBCYXNlLnNldCh7fSxcblx0XHRcdFx0XHR0aGlzLnByb3RvdHlwZS5fc2VyaWFsaXplRmllbGRzLCBzcmMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Tk9fSU5TRVJUOiB7IGluc2VydDogZmFsc2UgfVxuXHR9LFxuXG5cdF9jbGFzczogJ0l0ZW0nLFxuXHRfbmFtZTogbnVsbCxcblx0X2FwcGx5TWF0cml4OiB0cnVlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IHRydWUsXG5cdF9jYW5TY2FsZVN0cm9rZTogZmFsc2UsXG5cdF9waXZvdDogbnVsbCxcblx0X3Zpc2libGU6IHRydWUsXG5cdF9ibGVuZE1vZGU6ICdub3JtYWwnLFxuXHRfb3BhY2l0eTogMSxcblx0X2xvY2tlZDogZmFsc2UsXG5cdF9ndWlkZTogZmFsc2UsXG5cdF9jbGlwTWFzazogZmFsc2UsXG5cdF9zZWxlY3Rpb246IDAsXG5cdF9zZWxlY3RCb3VuZHM6IHRydWUsXG5cdF9zZWxlY3RDaGlsZHJlbjogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRuYW1lOiBudWxsLFxuXHRcdGFwcGx5TWF0cml4OiBudWxsLFxuXHRcdG1hdHJpeDogbmV3IE1hdHJpeCgpLFxuXHRcdHBpdm90OiBudWxsLFxuXHRcdHZpc2libGU6IHRydWUsXG5cdFx0YmxlbmRNb2RlOiAnbm9ybWFsJyxcblx0XHRvcGFjaXR5OiAxLFxuXHRcdGxvY2tlZDogZmFsc2UsXG5cdFx0Z3VpZGU6IGZhbHNlLFxuXHRcdGNsaXBNYXNrOiBmYWxzZSxcblx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0ZGF0YToge31cblx0fSxcblx0X3ByaW9yaXRpemU6IFsnYXBwbHlNYXRyaXgnXVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhhbmRsZXJzID0gWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25DbGljaycsXG5cdFx0XHQnb25Eb3VibGVDbGljaycsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJ107XG5cdHJldHVybiBCYXNlLmVhY2goaGFuZGxlcnMsXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW25hbWVdID0ge1xuXHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2NvdW50SXRlbUV2ZW50KHR5cGUsIDEpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9jb3VudEl0ZW1FdmVudCh0eXBlLCAtMSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0X2V2ZW50czoge1xuXHRcdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRvbkxvYWQ6IHt9LFxuXHRcdFx0XHRvbkVycm9yOiB7fVxuXHRcdFx0fSxcblx0XHRcdHN0YXRpY3M6IHtcblx0XHRcdFx0X2l0ZW1IYW5kbGVyczogaGFuZGxlcnNcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59LCB7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEl0ZW0oKSB7XG5cdH0sXG5cblx0X2luaXRpYWxpemU6IGZ1bmN0aW9uKHByb3BzLCBwb2ludCkge1xuXHRcdHZhciBoYXNQcm9wcyA9IHByb3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcyksXG5cdFx0XHRpbnRlcm5hbCA9IGhhc1Byb3BzICYmIHByb3BzLmludGVybmFsID09PSB0cnVlLFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0cHJvamVjdCA9IGhhc1Byb3BzICYmIHByb3BzLnByb2plY3QgfHwgcGFwZXIucHJvamVjdCxcblx0XHRcdHNldHRpbmdzID0gcGFwZXIuc2V0dGluZ3M7XG5cdFx0dGhpcy5faWQgPSBpbnRlcm5hbCA/IG51bGwgOiBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5fcGFyZW50ID0gdGhpcy5faW5kZXggPSBudWxsO1xuXHRcdHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0bWF0cml4LnRyYW5zbGF0ZShwb2ludCk7XG5cdFx0bWF0cml4Ll9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fc3R5bGUgPSBuZXcgU3R5bGUocHJvamVjdC5fY3VycmVudFN0eWxlLCB0aGlzLCBwcm9qZWN0KTtcblx0XHRpZiAoaW50ZXJuYWwgfHwgaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09IGZhbHNlXG5cdFx0XHR8fCAhc2V0dGluZ3MuaW5zZXJ0SXRlbXMgJiYgIShoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IHRydWUpKSB7XG5cdFx0XHR0aGlzLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQoaGFzUHJvcHMgJiYgcHJvcHMucGFyZW50IHx8IHByb2plY3QpXG5cdFx0XHRcdFx0Ll9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcywgdHJ1ZSk7XG5cdFx0fVxuXHRcdGlmIChoYXNQcm9wcyAmJiBwcm9wcyAhPT0gSXRlbS5OT19JTlNFUlQpIHtcblx0XHRcdHRoaXMuc2V0KHByb3BzLCB7XG5cdFx0XHRcdGludGVybmFsOiB0cnVlLCBpbnNlcnQ6IHRydWUsIHByb2plY3Q6IHRydWUsIHBhcmVudDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNQcm9wcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHByb3BzID0ge30sXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBmaWVsZHMpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhhdFtrZXldO1xuXHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJ1xuXHRcdFx0XHRcdFx0PyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcblx0XHRcdFx0XHRwcm9wc1trZXldID0gQmFzZS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRcdGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmlhbGl6ZSh0aGlzLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRzZXJpYWxpemUodGhpcy5fc3R5bGUuX2RlZmF1bHRzKTtcblx0XHRyZXR1cm4gWyB0aGlzLl9jbGFzcywgcHJvcHMgXTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHR2YXIgc3ltYm9sID0gdGhpcy5fc3ltYm9sLFxuXHRcdFx0Y2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgc3ltYm9sLFxuXHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID1cblx0XHRcdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjYWNoZVBhcmVudFxuXHRcdFx0XHQmJiAoZmxhZ3MgJiA0MCkpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUoY2FjaGVQYXJlbnQpO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAyKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdH1cblx0XHRpZiAocHJvamVjdClcblx0XHRcdHByb2plY3QuX2NoYW5nZWQoZmxhZ3MsIHRoaXMpO1xuXHRcdGlmIChzeW1ib2wpXG5cdFx0XHRzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdGdldElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH0sXG5cblx0Z2V0TmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdH0sXG5cblx0c2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0aWYgKG5hbWUgJiYgb3duZXIpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IG93bmVyLl9uYW1lZENoaWxkcmVuO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0aWYgKCEobmFtZSBpbiBjaGlsZHJlbikpXG5cdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMTI4KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRrZXkgPSAnXycgKyBuYW1lLFxuXHRcdFx0ZmxhZ3MgPSB7XG5cdFx0XHRcdGxvY2tlZDogMTI4LFxuXHRcdFx0XHR2aXNpYmxlOiAxMzdcblx0XHRcdH07XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1trZXldO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW2tleV0pIHtcblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoZmxhZ3NbbmFtZV0gfHwgMTI5KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXHRcdGlmIChzZWxlY3Rpb24gIT09IHRoaXMuX3NlbGVjdGlvbikge1xuXHRcdFx0dGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdFx0cHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VTZWxlY3Rpb246IGZ1bmN0aW9uKGZsYWcsIHNlbGVjdGVkKSB7XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbjtcblx0XHR0aGlzLnNldFNlbGVjdGlvbihzZWxlY3RlZCA/IHNlbGVjdGlvbiB8IGZsYWcgOiBzZWxlY3Rpb24gJiB+ZmxhZyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHNlbGVjdGVkID0gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cdFx0aWYgKGNoaWxkcmVuICYmIHNlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0aXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuXHR9LFxuXG5cdHNldENsaXBNYXNrOiBmdW5jdGlvbihjbGlwTWFzaykge1xuXHRcdGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuXHRcdFx0dGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblx0XHRcdGlmIChjbGlwTWFzaykge1xuXHRcdFx0XHR0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTI5KTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2hhbmdlZCgxMDI0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRpZiAoIXBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gPSBwaXZvdFxuXHRcdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdHJldHVybiBwaXZvdFxuXHRcdFx0XHQ/IG5ldyBMaW5rZWRQb2ludChwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUsIHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9XG59LCBCYXNlLmVhY2goe1xuXHRcdGdldFN0cm9rZUJvdW5kczogeyBzdHJva2U6IHRydWUgfSxcblx0XHRnZXRIYW5kbGVCb3VuZHM6IHsgaGFuZGxlOiB0cnVlIH0sXG5cdFx0Z2V0SW50ZXJuYWxCb3VuZHM6IHsgaW50ZXJuYWw6IHRydWUgfVxuXHR9LFxuXHRmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcblx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGhhc01hdHJpeCA9IG9wdGlvbnMgfHwgbWF0cml4IGluc3RhbmNlb2YgTWF0cml4LFxuXHRcdFx0b3B0cyA9IEJhc2Uuc2V0KHt9LCBoYXNNYXRyaXggPyBvcHRpb25zIDogbWF0cml4LFxuXHRcdFx0XHRcdHRoaXMuX2JvdW5kc09wdGlvbnMpO1xuXHRcdGlmICghb3B0cy5zdHJva2UgfHwgdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkpXG5cdFx0XHRvcHRzLmNhY2hlSXRlbSA9IHRoaXM7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHMoaGFzTWF0cml4ICYmIG1hdHJpeCwgb3B0cykucmVjdDtcblx0XHRyZXR1cm4gIWFyZ3VtZW50cy5sZW5ndGhcblx0XHRcdFx0PyBuZXcgTGlua2VkUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCxcblx0XHRcdFx0XHR0aGlzLCAnc2V0Qm91bmRzJylcblx0XHRcdFx0OiByZWN0O1xuXHR9LFxuXG5cdHNldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuXHRcdFx0aWYgKCFfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG5cdFx0XHRcdF9tYXRyaXguc2V0KF9tYXRyaXguX2JhY2t1cFxuXHRcdFx0XHRcdFx0fHwgbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShfbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHRcdH1cblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT09IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMCxcblx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0ICE9PSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMCk7XG5cdFx0fVxuXHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcblx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcywgb3B0aW9ucy5jYWNoZUl0ZW0pO1xuXHRcdHJldHVybiBJdGVtLl9nZXRCb3VuZHMoY2hpbGRyZW4sIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0X2dldEJvdW5kc0NhY2hlS2V5OiBmdW5jdGlvbihvcHRpb25zLCBpbnRlcm5hbCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRvcHRpb25zLnN0cm9rZSA/IDEgOiAwLFxuXHRcdFx0b3B0aW9ucy5oYW5kbGUgPyAxIDogMCxcblx0XHRcdGludGVybmFsID8gMSA6IDBcblx0XHRdLmpvaW4oJycpO1xuXHR9LFxuXG5cdF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucywgbm9JbnRlcm5hbCkge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKTtcblx0XHR2YXIgaW50ZXJuYWwgPSBvcHRpb25zLmludGVybmFsICYmICFub0ludGVybmFsLFxuXHRcdFx0Y2FjaGVJdGVtID0gb3B0aW9ucy5jYWNoZUl0ZW0sXG5cdFx0XHRfbWF0cml4ID0gaW50ZXJuYWwgPyBudWxsIDogdGhpcy5fbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRjYWNoZUtleSA9IGNhY2hlSXRlbSAmJiAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKVxuXHRcdFx0XHQmJiB0aGlzLl9nZXRCb3VuZHNDYWNoZUtleShvcHRpb25zLCBpbnRlcm5hbCksXG5cdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3N5bWJvbCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGVLZXkgJiYgYm91bmRzICYmIGNhY2hlS2V5IGluIGJvdW5kcykge1xuXHRcdFx0dmFyIGNhY2hlZCA9IGJvdW5kc1tjYWNoZUtleV07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZWN0OiBjYWNoZWQucmVjdC5jbG9uZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBjYWNoZWQubm9uc2NhbGluZ1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIHJlcyA9IHRoaXMuX2dldEJvdW5kcyhtYXRyaXggfHwgX21hdHJpeCwgb3B0aW9ucyksXG5cdFx0XHRyZWN0ID0gcmVzLnJlY3QgfHwgcmVzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdG5vbnNjYWxpbmcgPSByZXMubm9uc2NhbGluZyB8fCBzdHlsZS5oYXNTdHJva2UoKVxuXHRcdFx0XHQmJiAhc3R5bGUuZ2V0U3Ryb2tlU2NhbGluZygpO1xuXHRcdGlmIChjYWNoZUtleSkge1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzID0ge307XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW2NhY2hlS2V5XSA9IHtcblx0XHRcdFx0cmVjdDogcmVjdC5jbG9uZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBub25zY2FsaW5nLFxuXHRcdFx0XHRpbnRlcm5hbDogaW50ZXJuYWxcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0bm9uc2NhbGluZzogbm9uc2NhbGluZ1xuXHRcdH07XG5cdH0sXG5cblx0X2dldFN0cm9rZU1hdHJpeDogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbFxuXHRcdFx0XHQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcm5hbCA/IHRoaXNcblx0XHRcdFx0XHQ6IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9zeW1ib2wgJiYgdGhpcy5fc3ltYm9sLl9pdGVtLFxuXHRcdFx0bXggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Vmlld01hdHJpeCgpLmludmVydCgpIDogbWF0cml4O1xuXHRcdHJldHVybiBteCAmJiBteC5fc2hpZnRsZXNzKCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF91cGRhdGVCb3VuZHNDYWNoZTogZnVuY3Rpb24ocGFyZW50LCBpdGVtKSB7XG5cdFx0XHRpZiAocGFyZW50ICYmIGl0ZW0pIHtcblx0XHRcdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdFx0cmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRcdHJlZi5saXN0LnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0cmVmLmlkc1tpZF0gPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob3RoZXIgIT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2dldEJvdW5kczogZnVuY3Rpb24oaXRlbXMsIG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHgxID0gSW5maW5pdHksXG5cdFx0XHRcdHgyID0gLXgxLFxuXHRcdFx0XHR5MSA9IHgxLFxuXHRcdFx0XHR5MiA9IHgyLFxuXHRcdFx0XHRub25zY2FsaW5nID0gZmFsc2U7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGlmIChpdGVtLl92aXNpYmxlICYmICFpdGVtLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBpdGVtLl9nZXRDYWNoZWRCb3VuZHMoXG5cdFx0XHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmFwcGVuZGVkKGl0ZW0uX21hdHJpeCksIG9wdGlvbnMsIHRydWUpLFxuXHRcdFx0XHRcdFx0cmVjdCA9IGJvdW5kcy5yZWN0O1xuXHRcdFx0XHRcdHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG5cdFx0XHRcdFx0eTEgPSBNYXRoLm1pbihyZWN0LnksIHkxKTtcblx0XHRcdFx0XHR4MiA9IE1hdGgubWF4KHJlY3QueCArIHJlY3Qud2lkdGgsIHgyKTtcblx0XHRcdFx0XHR5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG5cdFx0XHRcdFx0aWYgKGJvdW5kcy5ub25zY2FsaW5nKVxuXHRcdFx0XHRcdFx0bm9uc2NhbGluZyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlY3Q6IGlzRmluaXRlKHgxKVxuXHRcdFx0XHRcdD8gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpXG5cdFx0XHRcdFx0OiBuZXcgUmVjdGFuZ2xlKCksXG5cdFx0XHRcdG5vbnNjYWxpbmc6IG5vbnNjYWxpbmdcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cbn0pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeFxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHRoaXMuX2RlY29tcG9zZWQgfHwgKHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCkpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZSgpO1xuXHRcdHJldHVybiBkZWNvbXBvc2VkID8gZGVjb21wb3NlZC5yb3RhdGlvbiA6IDA7XG5cdH0sXG5cblx0c2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQpIHtcblx0XHRcdFx0ZGVjb21wb3NlZC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKSxcblx0XHRcdHMgPSBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZztcblx0XHRyZXR1cm4gbmV3IExpbmtlZFBvaW50KHMgPyBzLnggOiAxLCBzID8gcy55IDogMSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuXHRcdFx0c2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY3VycmVudCAmJiBzY2FsaW5nICYmICFjdXJyZW50LmVxdWFscyhzY2FsaW5nKSkge1xuXHRcdFx0dmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpLFxuXHRcdFx0XHRkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCxcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0XHRjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpO1xuXHRcdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0aWYgKHJvdGF0aW9uKVxuXHRcdFx0XHRtYXRyaXgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdG1hdHJpeC5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG5cdFx0XHRpZiAocm90YXRpb24pXG5cdFx0XHRcdG1hdHJpeC5yb3RhdGUoLXJvdGF0aW9uKTtcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG5cdFx0XHRpZiAoZGVjb21wb3NlZCkge1xuXHRcdFx0XHRkZWNvbXBvc2VkLnNjYWxpbmcgPSBzY2FsaW5nO1xuXHRcdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRtYXRyaXguaW5pdGlhbGl6ZS5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Z2V0R2xvYmFsTWF0cml4OiBmdW5jdGlvbihfZG9udENsb25lKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCxcblx0XHRcdHVwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4Ll91cGRhdGVWZXJzaW9uICE9PSB1cGRhdGVWZXJzaW9uKVxuXHRcdFx0bWF0cml4ID0gbnVsbDtcblx0XHRpZiAoIW1hdHJpeCkge1xuXHRcdFx0bWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0bWF0cml4LnByZXBlbmQocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldFZpZXdNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZXBlbmQodGhpcy5nZXRWaWV3KCkuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeDtcblx0fSxcblxuXHRzZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oYXBwbHkpIHtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIWFwcGx5KVxuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG5cdHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnLFxufSwge1xuXHRnZXRQcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdClcblx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0aW5zdGFsbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0YWxsRXZlbnRzKVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gX2luc3RhbGxFdmVudHMoaW5zdGFsbCkge1xuXHRcdF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLl9pbnN0YWxsRXZlbnRzKGluc3RhbGwpO1xuXHR9LFxuXG5cdGdldExheWVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMYXllcilcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHR9LFxuXG5cdHNldFBhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdF9nZXRPd25lcjogJyNnZXRQYXJlbnQnLFxuXG5cdGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdH0sXG5cblx0c2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuXHR9LFxuXG5cdGdldEZpcnN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldExhc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuW3RoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDFdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0cmV0dXJuIG93bmVyICYmIG93bmVyLl9jaGlsZHJlblt0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdHJldHVybiBvd25lciAmJiBvd25lci5fY2hpbGRyZW5bdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPT09IHRoaXMgfHwgaXRlbSAmJiB0aGlzLl9jbGFzcyA9PT0gaXRlbS5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3R5bGUuZXF1YWxzKGl0ZW0uX3N0eWxlKVxuXHRcdFx0XHQmJiB0aGlzLl9tYXRyaXguZXF1YWxzKGl0ZW0uX21hdHJpeClcblx0XHRcdFx0JiYgdGhpcy5fbG9ja2VkID09PSBpdGVtLl9sb2NrZWRcblx0XHRcdFx0JiYgdGhpcy5fdmlzaWJsZSA9PT0gaXRlbS5fdmlzaWJsZVxuXHRcdFx0XHQmJiB0aGlzLl9ibGVuZE1vZGUgPT09IGl0ZW0uX2JsZW5kTW9kZVxuXHRcdFx0XHQmJiB0aGlzLl9vcGFjaXR5ID09PSBpdGVtLl9vcGFjaXR5XG5cdFx0XHRcdCYmIHRoaXMuX2NsaXBNYXNrID09PSBpdGVtLl9jbGlwTWFza1xuXHRcdFx0XHQmJiB0aGlzLl9ndWlkZSA9PT0gaXRlbS5fZ3VpZGVcblx0XHRcdFx0JiYgdGhpcy5fZXF1YWxzKGl0ZW0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fY2hpbGRyZW4sIGl0ZW0uX2NoaWxkcmVuKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBjb3B5ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0Y2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGluc2VydCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5pbnNlcnQgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0b3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IHRydWUpLFxuXHRcdFx0ZGVlcCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5kZWVwIDogdW5kZWZpbmVkLCB0cnVlKTtcblx0XHRpZiAoY2hpbGRyZW4pXG5cdFx0XHRjb3B5LmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgZGVlcClcblx0XHRcdGNvcHkuY29weUNvbnRlbnQodGhpcyk7XG5cdFx0aWYgKCFjaGlsZHJlbilcblx0XHRcdGNvcHkuY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0aWYgKGluc2VydClcblx0XHRcdGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0dmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0aWYgKG5hbWUgIT09IG9yaWcpXG5cdFx0XHRcdGNvcHkuc2V0TmFtZShuYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHNvdXJjZS5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0uY2xvbmUoZmFsc2UpLCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Y29weUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZXhjbHVkZU1hdHJpeCkge1xuXHRcdHRoaXMuc2V0U3R5bGUoc291cmNlLl9zdHlsZSk7XG5cdFx0dmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsXG5cdFx0XHRcdCdfY2xpcE1hc2snLCAnX2d1aWRlJ107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdHRoaXNba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdH1cblx0XHRpZiAoIWV4Y2x1ZGVNYXRyaXgpXG5cdFx0XHR0aGlzLl9tYXRyaXguc2V0KHNvdXJjZS5fbWF0cml4LCB0cnVlKTtcblx0XHR0aGlzLnNldEFwcGx5TWF0cml4KHNvdXJjZS5fYXBwbHlNYXRyaXgpO1xuXHRcdHRoaXMuc2V0UGl2b3Qoc291cmNlLl9waXZvdCk7XG5cdFx0dGhpcy5zZXRTZWxlY3Rpb24oc291cmNlLl9zZWxlY3Rpb24pO1xuXHRcdHZhciBkYXRhID0gc291cmNlLl9kYXRhLFxuXHRcdFx0bmFtZSA9IHNvdXJjZS5fbmFtZTtcblx0XHR0aGlzLl9kYXRhID0gZGF0YSA/IEJhc2UuY2xvbmUoZGF0YSkgOiBudWxsO1xuXHRcdGlmIChuYW1lKVxuXHRcdFx0dGhpcy5zZXROYW1lKG5hbWUpO1xuXHR9LFxuXG5cdHJhc3Rlcml6ZTogZnVuY3Rpb24ocmVzb2x1dGlvbiwgaW5zZXJ0KSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKCksXG5cdFx0XHRzY2FsZSA9IChyZXNvbHV0aW9uIHx8IHRoaXMuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSkgLyA3Mixcblx0XHRcdHRvcExlZnQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCksXG5cdFx0XHRib3R0b21SaWdodCA9IGJvdW5kcy5nZXRCb3R0b21SaWdodCgpLmNlaWwoKSxcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KSksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRpZiAoIXNpemUuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZS5tdWx0aXBseShzY2FsZSkpLFxuXHRcdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUodG9wTGVmdC5uZWdhdGUoKSk7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0XHR0aGlzLmRyYXcoY3R4LCBuZXcgQmFzZSh7IG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0cmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuXHRcdH1cblx0XHRyYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKVxuXHRcdFx0XHQuc2NhbGUoMSAvIHNjYWxlKSk7XG5cdFx0aWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydClcblx0XHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9jb250YWlucyhcblx0XHRcdFx0dGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcy5nZXRCb3VuZHMoKSk7XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0cmVjdGFuZ2xlOiB0aGlzLmdldEludGVybmFsQm91bmRzKCksXG5cdFx0XHRtYXRyaXg6IHRoaXMuX21hdHJpeCxcblx0XHRcdGluc2VydDogZmFsc2UsXG5cdFx0fSk7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oaXRlbSwgX21hdHJpeCkge1xuXHRcdGlmICghKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcy5fYXNQYXRoSXRlbSgpLmdldEludGVyc2VjdGlvbnMoaXRlbS5fYXNQYXRoSXRlbSgpLCBudWxsLFxuXHRcdFx0XHRfbWF0cml4LCB0cnVlKS5sZW5ndGggPiAwO1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBoaXRUZXN0KCkge1xuXHRcdHJldHVybiB0aGlzLl9oaXRUZXN0KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdEhpdFJlc3VsdC5nZXRPcHRpb25zKGFyZ3VtZW50cykpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGl0VGVzdEFsbCgpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRvcHRpb25zID0gSGl0UmVzdWx0LmdldE9wdGlvbnMoYXJndW1lbnRzKSxcblx0XHRcdGFsbCA9IFtdO1xuXHRcdHRoaXMuX2hpdFRlc3QocG9pbnQsIEJhc2Uuc2V0KHsgYWxsOiBhbGwgfSwgb3B0aW9ucykpO1xuXHRcdHJldHVybiBhbGw7XG5cdH1cblxuXHRmdW5jdGlvbiBoaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgsIF9leGNsdWRlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdHZhciByZXMgPSBjaGlsZCAhPT0gX2V4Y2x1ZGUgJiYgY2hpbGQuX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMsXG5cdFx0XHRcdFx0XHR2aWV3TWF0cml4KTtcblx0XHRcdFx0aWYgKHJlcyAmJiAhb3B0aW9ucy5hbGwpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0aGl0VGVzdDogaGl0VGVzdCxcblx0XHRoaXRUZXN0QWxsOiBoaXRUZXN0QWxsLFxuXHRcdF9oaXRUZXN0OiBoaXRUZXN0Q2hpbGRyZW5cblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRoaXRUZXN0OiBoaXRUZXN0LFxuXHRcdGhpdFRlc3RBbGw6IGhpdFRlc3RBbGwsXG5cdFx0X2hpdFRlc3RDaGlsZHJlbjogaGl0VGVzdENoaWxkcmVuLFxuXHR9O1xufSwge1xuXG5cdF9oaXRUZXN0OiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucywgcGFyZW50Vmlld01hdHJpeCkge1xuXHRcdGlmICh0aGlzLl9sb2NrZWQgfHwgIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fZ3VpZGUgJiYgIW9wdGlvbnMuZ3VpZGVzXG5cdFx0XHRcdHx8IHRoaXMuaXNFbXB0eSgpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0dmlld01hdHJpeCA9IHBhcmVudFZpZXdNYXRyaXhcblx0XHRcdFx0XHQ/IHBhcmVudFZpZXdNYXRyaXguYXBwZW5kZWQobWF0cml4KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5wcmVwZW5kKHRoaXMuZ2V0VmlldygpLl9tYXRyaXgpLFxuXHRcdFx0dG9sZXJhbmNlID0gTWF0aC5tYXgob3B0aW9ucy50b2xlcmFuY2UsIDFlLTEyKSxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nID0gbmV3IFNpemUoXG5cdFx0XHRcdFx0UGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyh0b2xlcmFuY2UsXG5cdFx0XHRcdFx0XHRtYXRyaXguX3NoaWZ0bGVzcygpLmludmVydCgpKSk7XG5cdFx0cG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0ocG9pbnQpO1xuXHRcdGlmICghcG9pbnQgfHwgIXRoaXMuX2NoaWxkcmVuICYmXG5cdFx0XHQhdGhpcy5nZXRCb3VuZHMoeyBpbnRlcm5hbDogdHJ1ZSwgc3Ryb2tlOiB0cnVlLCBoYW5kbGU6IHRydWUgfSlcblx0XHRcdFx0LmV4cGFuZCh0b2xlcmFuY2VQYWRkaW5nLm11bHRpcGx5KDIpKS5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZVxuXHRcdFx0XHR8fCBvcHRpb25zLnNlbGVjdGVkICYmICF0aGlzLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHR8fCBvcHRpb25zLnR5cGUgJiYgb3B0aW9ucy50eXBlICE9PSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0fHwgb3B0aW9ucy5jbGFzcyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvcHRpb25zLmNsYXNzKSksXG5cdFx0XHRtYXRjaCA9IG9wdGlvbnMubWF0Y2gsXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGJvdW5kcyxcblx0XHRcdHJlcztcblxuXHRcdGZ1bmN0aW9uIGZpbHRlcihoaXQpIHtcblx0XHRcdGlmIChoaXQgJiYgbWF0Y2ggJiYgIW1hdGNoKGhpdCkpXG5cdFx0XHRcdGhpdCA9IG51bGw7XG5cdFx0XHRpZiAoaGl0ICYmIG9wdGlvbnMuYWxsKVxuXHRcdFx0XHRvcHRpb25zLmFsbC5wdXNoKGhpdCk7XG5cdFx0XHRyZXR1cm4gaGl0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrUG9pbnQodHlwZSwgcGFydCkge1xuXHRcdFx0dmFyIHB0ID0gcGFydCA/IGJvdW5kc1snZ2V0JyArIHBhcnRdKCkgOiB0aGF0LmdldFBvc2l0aW9uKCk7XG5cdFx0XHRpZiAocG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZSh0b2xlcmFuY2VQYWRkaW5nKS5sZW5ndGggPD0gMSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LCB7XG5cdFx0XHRcdFx0bmFtZTogcGFydCA/IEJhc2UuaHlwaGVuYXRlKHBhcnQpIDogdHlwZSxcblx0XHRcdFx0XHRwb2ludDogcHRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoZWNrUG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uLFxuXHRcdFx0Y2hlY2tDZW50ZXIgPSBvcHRpb25zLmNlbnRlcixcblx0XHRcdGNoZWNrQm91bmRzID0gb3B0aW9ucy5ib3VuZHM7XG5cdFx0aWYgKGNoZWNrU2VsZiAmJiB0aGlzLl9wYXJlbnRcblx0XHRcdFx0JiYgKGNoZWNrUG9zaXRpb24gfHwgY2hlY2tDZW50ZXIgfHwgY2hlY2tCb3VuZHMpKSB7XG5cdFx0XHRpZiAoY2hlY2tDZW50ZXIgfHwgY2hlY2tCb3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdFx0cmVzID0gY2hlY2tQb3NpdGlvbiAmJiBjaGVja1BvaW50KCdwb3NpdGlvbicpIHx8XG5cdFx0XHRcdFx0Y2hlY2tDZW50ZXIgJiYgY2hlY2tQb2ludCgnY2VudGVyJywgJ0NlbnRlcicpO1xuXHRcdFx0aWYgKCFyZXMgJiYgY2hlY2tCb3VuZHMpIHtcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKSB7XG5cdFx0XHRcdFx0cmVzID0gY2hlY2tQb2ludCgnYm91bmRzJywgcG9pbnRzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVzID0gZmlsdGVyKHJlcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFyZXMpIHtcblx0XHRcdHJlcyA9IHRoaXMuX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeClcblx0XHRcdFx0fHwgY2hlY2tTZWxmXG5cdFx0XHRcdFx0JiYgZmlsdGVyKHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LFxuXHRcdFx0XHRcdFx0dGhpcy5nZXRTdHJva2VTY2FsaW5nKCkgPyBudWxsXG5cdFx0XHRcdFx0XHRcdDogdmlld01hdHJpeC5fc2hpZnRsZXNzKCkuaW52ZXJ0KCkpKVxuXHRcdFx0XHR8fCBudWxsO1xuXHRcdH1cblx0XHRpZiAocmVzICYmIHJlcy5wb2ludCkge1xuXHRcdFx0cmVzLnBvaW50ID0gbWF0cml4LnRyYW5zZm9ybShyZXMucG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucy5maWxsICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KSlcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcyk7XG5cdH0sXG5cblx0bWF0Y2hlczogZnVuY3Rpb24obmFtZSwgY29tcGFyZSkge1xuXHRcdGZ1bmN0aW9uIG1hdGNoT2JqZWN0KG9iajEsIG9iajIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gb2JqMSkge1xuXHRcdFx0XHRpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHZhciB2YWwxID0gb2JqMVtpXSxcblx0XHRcdFx0XHRcdHZhbDIgPSBvYmoyW2ldO1xuXHRcdFx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QodmFsMSkgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoT2JqZWN0KHZhbDEsIHZhbDIpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsMSwgdmFsMikpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBuYW1lO1xuXHRcdGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpIHtcblx0XHRcdFx0aWYgKG5hbWUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdGhpcy5tYXRjaGVzKGtleSwgbmFtZVtrZXldKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBuYW1lKHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ21hdGNoJykge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmUodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB2YWx1ZSA9IC9eKGVtcHR5fGVkaXRhYmxlKSQvLnRlc3QobmFtZSlcblx0XHRcdFx0XHQ/IHRoaXNbJ2lzJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0oKVxuXHRcdFx0XHRcdDogbmFtZSA9PT0gJ3R5cGUnXG5cdFx0XHRcdFx0XHQ/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHRcdFx0OiB0aGlzW25hbWVdO1xuXHRcdFx0aWYgKG5hbWUgPT09ICdjbGFzcycpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzIGluc3RhbmNlb2YgY29tcGFyZTtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9jbGFzcztcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gISFjb21wYXJlKHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcGFyZSkge1xuXHRcdFx0XHRpZiAoY29tcGFyZS50ZXN0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBhcmUudGVzdCh2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoT2JqZWN0KGNvbXBhcmUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgdGhpcy5fbWF0cml4KTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIHRoaXMuX21hdHJpeCwgbnVsbCwgdHJ1ZSlbMF1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X2dldEl0ZW1zOiBmdW5jdGlvbiBfZ2V0SXRlbXMoaXRlbSwgb3B0aW9ucywgbWF0cml4LCBwYXJhbSwgZmlyc3RPbmx5KSB7XG5cdFx0XHRpZiAoIXBhcmFtKSB7XG5cdFx0XHRcdHZhciBvYmogPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyxcblx0XHRcdFx0XHRvdmVybGFwcGluZyA9IG9iaiAmJiBvYmoub3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0aW5zaWRlID0gb2JqICYmIG9iai5pbnNpZGUsXG5cdFx0XHRcdFx0Ym91bmRzID0gb3ZlcmxhcHBpbmcgfHwgaW5zaWRlLFxuXHRcdFx0XHRcdHJlY3QgPSBib3VuZHMgJiYgUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10pO1xuXHRcdFx0XHRwYXJhbSA9IHtcblx0XHRcdFx0XHRpdGVtczogW10sXG5cdFx0XHRcdFx0cmVjdXJzaXZlOiBvYmogJiYgb2JqLnJlY3Vyc2l2ZSAhPT0gZmFsc2UsXG5cdFx0XHRcdFx0aW5zaWRlOiAhIWluc2lkZSxcblx0XHRcdFx0XHRvdmVybGFwcGluZzogISFvdmVybGFwcGluZyxcblx0XHRcdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0XHRcdHBhdGg6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRcdFx0XHRyZWN0YW5nbGU6IHJlY3QsXG5cdFx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKG9iaikge1xuXHRcdFx0XHRcdG9wdGlvbnMgPSBCYXNlLmZpbHRlcih7fSwgb3B0aW9ucywge1xuXHRcdFx0XHRcdFx0cmVjdXJzaXZlOiB0cnVlLCBpbnNpZGU6IHRydWUsIG92ZXJsYXBwaW5nOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuLFxuXHRcdFx0XHRpdGVtcyA9IHBhcmFtLml0ZW1zLFxuXHRcdFx0XHRyZWN0ID0gcGFyYW0ucmVjdDtcblx0XHRcdG1hdHJpeCA9IHJlY3QgJiYgKG1hdHJpeCB8fCBuZXcgTWF0cml4KCkpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdFx0Y2hpbGRNYXRyaXggPSBtYXRyaXggJiYgbWF0cml4LmFwcGVuZGVkKGNoaWxkLl9tYXRyaXgpLFxuXHRcdFx0XHRcdGFkZCA9IHRydWU7XG5cdFx0XHRcdGlmIChyZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGNoaWxkLmdldEJvdW5kcyhjaGlsZE1hdHJpeCk7XG5cdFx0XHRcdFx0aWYgKCFyZWN0LmludGVyc2VjdHMoYm91bmRzKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmICghKHJlY3QuY29udGFpbnMoYm91bmRzKVxuXHRcdFx0XHRcdFx0XHR8fCBwYXJhbS5vdmVybGFwcGluZyAmJiAoYm91bmRzLmNvbnRhaW5zKHJlY3QpXG5cdFx0XHRcdFx0XHRcdFx0fHwgcGFyYW0ucGF0aC5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKSlcblx0XHRcdFx0XHRcdGFkZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhZGQgJiYgY2hpbGQubWF0Y2hlcyhvcHRpb25zKSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdGlmIChmaXJzdE9ubHkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFyYW0ucmVjdXJzaXZlICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdF9nZXRJdGVtcyhjaGlsZCwgb3B0aW9ucywgY2hpbGRNYXRyaXgsIHBhcmFtLCBmaXJzdE9ubHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaXJzdE9ubHkgJiYgaXRlbXMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn0sIHtcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dmFyIHJlcyA9IEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcblx0XHRyZXR1cm4gcmVzICE9PSB0aGlzID8gdGhpcy5hZGRDaGlsZChyZXMpIDogcmVzO1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZDogZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcblx0XHR2YXIgcmVzID0gaXRlbSA/IHRoaXMuaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIFtpdGVtXSkgOiBudWxsO1xuXHRcdHJldHVybiByZXMgJiYgcmVzWzBdO1xuXHR9LFxuXG5cdGFkZENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcykge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkcmVuKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCwgaXRlbXMpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbihpbmRleCwgaXRlbXMpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0aXRlbXMgPSBCYXNlLnNsaWNlKGl0ZW1zKTtcblx0XHRcdHZhciBpbnNlcnRlZCA9IHt9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV0sXG5cdFx0XHRcdFx0aWQgPSBpdGVtICYmIGl0ZW0uX2lkO1xuXHRcdFx0XHRpZiAoIWl0ZW0gfHwgaW5zZXJ0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGl0ZW0uX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aW5zZXJ0ZWRbaWRdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdG5vdGlmeVNlbGYgPSBwcm9qZWN0Ll9jaGFuZ2VzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXSxcblx0XHRcdFx0XHRuYW1lID0gaXRlbS5fbmFtZTtcblx0XHRcdFx0aXRlbS5fcGFyZW50ID0gdGhpcztcblx0XHRcdFx0aXRlbS5fc2V0UHJvamVjdChwcm9qZWN0LCB0cnVlKTtcblx0XHRcdFx0aWYgKG5hbWUpXG5cdFx0XHRcdFx0aXRlbS5zZXROYW1lKG5hbWUpO1xuXHRcdFx0XHRpZiAobm90aWZ5U2VsZilcblx0XHRcdFx0XHRpdGVtLl9jaGFuZ2VkKDUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW1zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdF9pbnNlcnRJdGVtOiAnI2luc2VydENoaWxkJyxcblxuXHRfaW5zZXJ0QXQ6IGZ1bmN0aW9uKGl0ZW0sIG9mZnNldCkge1xuXHRcdHZhciBvd25lciA9IGl0ZW0gJiYgaXRlbS5fZ2V0T3duZXIoKSxcblx0XHRcdHJlcyA9IGl0ZW0gIT09IHRoaXMgJiYgb3duZXIgPyB0aGlzIDogbnVsbDtcblx0XHRpZiAocmVzKSB7XG5cdFx0XHRyZXMuX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRvd25lci5faW5zZXJ0SXRlbShpdGVtLl9pbmRleCArIG9mZnNldCwgcmVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRpbnNlcnRBYm92ZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnNlcnRBdChpdGVtLCAxKTtcblx0fSxcblxuXHRpbnNlcnRCZWxvdzogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnNlcnRBdChpdGVtLCAwKTtcblx0fSxcblxuXHRzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdHJldHVybiBvd25lciA/IG93bmVyLl9pbnNlcnRJdGVtKDAsIHRoaXMpIDogbnVsbDtcblx0fSxcblxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0cmV0dXJuIG93bmVyID8gb3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzKSA6IG51bGw7XG5cdH0sXG5cblx0YXBwZW5kVG9wOiAnI2FkZENoaWxkJyxcblxuXHRhcHBlbmRCb3R0b206IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCgwLCBpdGVtKTtcblx0fSxcblxuXHRtb3ZlQWJvdmU6ICcjaW5zZXJ0QWJvdmUnLFxuXG5cdG1vdmVCZWxvdzogJyNpbnNlcnRCZWxvdycsXG5cblx0YWRkVG86IGZ1bmN0aW9uKG93bmVyKSB7XG5cdFx0cmV0dXJuIG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcyk7XG5cdH0sXG5cblx0Y29weVRvOiBmdW5jdGlvbihvd25lcikge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKGZhbHNlKS5hZGRUbyhvd25lcik7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5bMF0ucmVkdWNlKG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuX3BhcmVudCkge1xuXHRcdFx0XHRjaGlsZC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoaWxkLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdG5hbWVkQ2hpbGRyZW4gPSBvd25lci5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0bmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRcdG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuXHRcdFx0XHRpbmRleCA9IG5hbWVkQXJyYXkgPyBuYW1lZEFycmF5LmluZGV4T2YodGhpcykgOiAtMTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpXG5cdFx0XHRcdFx0ZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHRuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGlmIChuYW1lZEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVswXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgbmFtZWRDaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlOiBmdW5jdGlvbihub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpLFxuXHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdFx0cHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcblx0XHRcdFx0XHRcdFx0fHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblx0XHRcdFx0QmFzZS5zcGxpY2Uob3duZXIuX2NoaWxkcmVuLCBudWxsLCBpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHRpZiAobm90aWZ5UGFyZW50KVxuXHRcdFx0XHRvd25lci5fY2hhbmdlZCgxMSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0c3RhcnQgPSBzdGFydCB8fCAwO1xuXHRcdGVuZCA9IEJhc2UucGljayhlbmQsIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0cmV0dXJuICFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoO1xuXHR9LFxuXG5cdGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtID0gdGhpcztcblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1N0cm9rZSgpO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTaGFkb3coKTtcblx0fSxcblxuXHRfZ2V0T3JkZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRmdW5jdGlvbiBnZXRMaXN0KGl0ZW0pIHtcblx0XHRcdHZhciBsaXN0ID0gW107XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpc3QudW5zaGlmdChpdGVtKTtcblx0XHRcdH0gd2hpbGUgKGl0ZW0gPSBpdGVtLl9wYXJlbnQpO1xuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHRcdHZhciBsaXN0MSA9IGdldExpc3QodGhpcyksXG5cdFx0XHRsaXN0MiA9IGdldExpc3QoaXRlbSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihsaXN0MS5sZW5ndGgsIGxpc3QyLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChsaXN0MVtpXSAhPSBsaXN0MltpXSkge1xuXHRcdFx0XHRyZXR1cm4gbGlzdDFbaV0uX2luZGV4IDwgbGlzdDJbaV0uX2luZGV4ID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHRoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pc0luc2VydGVkKCkgOiBmYWxzZTtcblx0fSxcblxuXHRpc0Fib3ZlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcblx0fSxcblxuXHRpc0JlbG93OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAxO1xuXHR9LFxuXG5cdGlzUGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbTtcblx0fSxcblxuXHRpc0NoaWxkOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuXHR9LFxuXG5cdGlzRGVzY2VuZGFudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCA9PT0gaXRlbSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0FuY2VzdG9yOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPyBpdGVtLmlzRGVzY2VuZGFudCh0aGlzKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzU2libGluZzogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW0uX3BhcmVudDtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cbn0sIEJhc2UuZWFjaChbJ3JvdGF0ZScsICdzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uKGtleSkge1xuXHR2YXIgcm90YXRlID0ga2V5ID09PSAncm90YXRlJztcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbHVlID0gKHJvdGF0ZSA/IEJhc2UgOiBQb2ludCkucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtrZXldKHZhbHVlLFxuXHRcdFx0XHRjZW50ZXIgfHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9O1xufSwge1xuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBteCA9IG5ldyBNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCwgX2FwcGx5TWF0cml4LCBfYXBwbHlSZWN1cnNpdmVseSxcblx0XHRcdF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0dHJhbnNmb3JtID0gbWF0cml4ICYmICFtYXRyaXguaXNJZGVudGl0eSgpLFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoX2FwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4KVxuXHRcdFx0XHRcdCYmICgoIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IHRyYW5zZm9ybSlcblx0XHRcdFx0XHRcdHx8IF9hcHBseU1hdHJpeCAmJiBfYXBwbHlSZWN1cnNpdmVseSAmJiB0aGlzLl9jaGlsZHJlbik7XG5cdFx0aWYgKCF0cmFuc2Zvcm0gJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0aWYgKCFtYXRyaXguaXNJbnZlcnRpYmxlKCkgJiYgX21hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdFx0X21hdHJpeC5fYmFja3VwID0gX21hdHJpeC5nZXRWYWx1ZXMoKTtcblx0XHRcdF9tYXRyaXgucHJlcGVuZChtYXRyaXgsIHRydWUpO1xuXHRcdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcih0cnVlKSxcblx0XHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcih0cnVlKTtcblx0XHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRcdGZpbGxDb2xvci50cmFuc2Zvcm0obWF0cml4KTtcblx0XHRcdGlmIChzdHJva2VDb2xvcilcblx0XHRcdFx0c3Ryb2tlQ29sb3IudHJhbnNmb3JtKG1hdHJpeCk7XG5cdFx0fVxuXHRcdGlmIChhcHBseU1hdHJpeCAmJiAoYXBwbHlNYXRyaXggPSB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgsXG5cdFx0XHRcdF9hcHBseVJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpKSkge1xuXHRcdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdFx0aWYgKF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeClcblx0XHRcdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHRpZiAodHJhbnNmb3JtIHx8IGFwcGx5TWF0cml4KSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0XHR2YXIgZGVjb21wID0gdHJhbnNmb3JtICYmIGJvdW5kcyAmJiBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0aWYgKGRlY29tcCAmJiBkZWNvbXAuc2tld2luZy5pc1plcm8oKSAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGNhY2hlLm5vbnNjYWxpbmcpIHtcblx0XHRcdFx0XHRkZWxldGUgYm91bmRzW2tleV07XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXBwbHlNYXRyaXggfHwgIWNhY2hlLmludGVybmFsKSB7XG5cdFx0XHRcdFx0dmFyIHJlY3QgPSBjYWNoZS5yZWN0O1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW3RoaXMuX2dldEJvdW5kc0NhY2hlS2V5KFxuXHRcdFx0XHRcdHRoaXMuX2JvdW5kc09wdGlvbnMgfHwge30pXTtcblx0XHRcdGlmIChjYWNoZWQpIHtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gPSBjYWNoZWQucmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gJiYgcG9zaXRpb24gJiYgdGhpcy5fcGl2b3QpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIHRydWUsIGFwcGx5UmVjdXJzaXZlbHksXG5cdFx0XHRcdFx0XHRzZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl9pbnZlcnNlVHJhbnNmb3JtKFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9HbG9iYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cGFyZW50VG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9QYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Zml0Qm91bmRzOiBmdW5jdGlvbihyZWN0YW5nbGUsIGZpbGwpIHtcblx0XHRyZWN0YW5nbGUgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0aXRlbVJhdGlvID0gYm91bmRzLmhlaWdodCAvIGJvdW5kcy53aWR0aCxcblx0XHRcdHJlY3RSYXRpbyA9IHJlY3RhbmdsZS5oZWlnaHQgLyByZWN0YW5nbGUud2lkdGgsXG5cdFx0XHRzY2FsZSA9IChmaWxsID8gaXRlbVJhdGlvID4gcmVjdFJhdGlvIDogaXRlbVJhdGlvIDwgcmVjdFJhdGlvKVxuXHRcdFx0XHRcdD8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoXG5cdFx0XHRcdFx0OiByZWN0YW5nbGUuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCxcblx0XHRcdG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksXG5cdFx0XHRcdFx0bmV3IFNpemUoYm91bmRzLndpZHRoICogc2NhbGUsIGJvdW5kcy5oZWlnaHQgKiBzY2FsZSkpO1xuXHRcdG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcblx0XHR0aGlzLnNldEJvdW5kcyhuZXdCb3VuZHMpO1xuXHR9XG59KSwge1xuXG5cdF9zZXRTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbENvbG9yKCkudG9DYW52YXNTdHlsZShjdHgsIG1hdHJpeCk7XG5cdFx0fVxuXHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCwgbWF0cml4KTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdFx0dmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRcdHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0cm9rZUpvaW4pXG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9IHN0cm9rZUpvaW47XG5cdFx0XHRpZiAoc3Ryb2tlQ2FwKVxuXHRcdFx0XHRjdHgubGluZUNhcCA9IHN0cm9rZUNhcDtcblx0XHRcdGlmIChtaXRlckxpbWl0KVxuXHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0XHRpZiAocGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoKSB7XG5cdFx0XHRcdHZhciBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0XHRkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXHRcdFx0XHRpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZiAoJ3NldExpbmVEYXNoJyBpbiBjdHgpIHtcblx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG5cdFx0XHRcdFx0XHRjdHgubW96RGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdHlsZS5oYXNTaGFkb3coKSkge1xuXHRcdFx0dmFyIHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRcdG14ID0gdmlld01hdHJpeC5fc2hpZnRsZXNzKCkucHJlcGVuZChcblx0XHRcdFx0XHRuZXcgTWF0cml4KCkuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbykpLFxuXHRcdFx0XHRibHVyID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChzdHlsZS5nZXRTaGFkb3dCbHVyKCksIDApKSxcblx0XHRcdFx0b2Zmc2V0ID0gbXgudHJhbnNmb3JtKHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCkpO1xuXHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc3R5bGUuZ2V0U2hhZG93Q29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRjdHguc2hhZG93Qmx1ciA9IGJsdXIuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuXHRcdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBvZmZzZXQueTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgcGFyZW50U3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fb3BhY2l0eSA9PT0gMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgbWF0cmljZXMgPSBwYXJhbS5tYXRyaWNlcyxcblx0XHRcdHZpZXdNYXRyaXggPSBwYXJhbS52aWV3TWF0cml4LFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0Z2xvYmFsTWF0cml4ID0gbWF0cmljZXNbbWF0cmljZXMubGVuZ3RoIC0gMV0uYXBwZW5kZWQobWF0cml4KTtcblx0XHRpZiAoIWdsb2JhbE1hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdHJldHVybjtcblxuXHRcdHZpZXdNYXRyaXggPSB2aWV3TWF0cml4ID8gdmlld01hdHJpeC5hcHBlbmRlZChnbG9iYWxNYXRyaXgpXG5cdFx0XHRcdDogZ2xvYmFsTWF0cml4O1xuXG5cdFx0bWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXHRcdGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcblx0XHRcdGdsb2JhbE1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuXHRcdFx0bm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuXHRcdFx0bmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcblx0XHRcdGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcblx0XHRcdFx0XHR8fCBwYXJhbS5kb250U3RhcnRcblx0XHRcdFx0XHR8fCBwYXJhbS5jbGlwXG5cdFx0XHRcdFx0fHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKVxuXHRcdFx0XHRcdFx0JiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG5cdFx0XHRwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0bWFpbkN0eCwgaXRlbU9mZnNldCwgcHJldk9mZnNldDtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKHZpZXdNYXRyaXgpO1xuXHRcdFx0aWYgKCFib3VuZHMud2lkdGggfHwgIWJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXZPZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpdGVtT2Zmc2V0ID0gcGFyYW0ub2Zmc2V0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpO1xuXHRcdFx0bWFpbkN0eCA9IGN0eDtcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoYm91bmRzLmdldFNpemUoKS5jZWlsKCkuYWRkKDEpXG5cdFx0XHRcdFx0Lm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcblx0XHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKVxuXHRcdFx0XHRjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIHN0cm9rZU1hdHJpeCA9IHBhcmVudFN0cm9rZU1hdHJpeFxuXHRcdFx0XHQ/IHBhcmVudFN0cm9rZU1hdHJpeC5hcHBlbmRlZChtYXRyaXgpXG5cdFx0XHRcdDogdGhpcy5fY2FuU2NhbGVTdHJva2UgJiYgIXRoaXMuZ2V0U3Ryb2tlU2NhbGluZyh0cnVlKVxuXHRcdFx0XHRcdCYmIHZpZXdNYXRyaXgsXG5cdFx0XHRjbGlwID0gIWRpcmVjdCAmJiBwYXJhbS5jbGlwSXRlbSxcblx0XHRcdHRyYW5zZm9ybSA9ICFzdHJva2VNYXRyaXggfHwgY2xpcDtcblx0XHRpZiAoZGlyZWN0KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXHRcdFx0aWYgKG5hdGl2ZUJsZW5kKVxuXHRcdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuXHRcdH0gZWxzZSBpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHRjdHgudHJhbnNsYXRlKC1pdGVtT2Zmc2V0LngsIC1pdGVtT2Zmc2V0LnkpO1xuXHRcdH1cblx0XHRpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHQoZGlyZWN0ID8gbWF0cml4IDogdmlld01hdHJpeCkuYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR9XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdHBhcmFtLmNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHR9XG5cdFx0aWYgKHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcblx0XHRcdHZhciBvZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpZiAob2Zmc2V0KVxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKC1vZmZzZXQueCwgLW9mZnNldC55KTtcblx0XHR9XG5cdFx0dGhpcy5fZHJhdyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bWF0cmljZXMucG9wKCk7XG5cdFx0aWYgKHBhcmFtLmNsaXAgJiYgIXBhcmFtLmRvbnRGaW5pc2gpXG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHRCbGVuZE1vZGUucHJvY2VzcyhibGVuZE1vZGUsIGN0eCwgbWFpbkN0eCwgb3BhY2l0eSxcblx0XHRcdFx0XHRpdGVtT2Zmc2V0LnN1YnRyYWN0KHByZXZPZmZzZXQpLm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHRcdHBhcmFtLm9mZnNldCA9IHByZXZPZmZzZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1VwZGF0ZWQ6IGZ1bmN0aW9uKHVwZGF0ZVZlcnNpb24pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRyZXR1cm4gcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbik7XG5cdFx0dmFyIHVwZGF0ZWQgPSB0aGlzLl91cGRhdGVWZXJzaW9uID09PSB1cGRhdGVWZXJzaW9uO1xuXHRcdGlmICghdXBkYXRlZCAmJiBwYXJlbnQgJiYgcGFyZW50Ll92aXNpYmxlXG5cdFx0XHRcdCYmIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdXBkYXRlZDtcblx0fSxcblxuXHRfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHNpemUsIHNlbGVjdGlvbkl0ZW1zLCB1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbixcblx0XHRcdGl0ZW1TZWxlY3RlZCA9IHNlbGVjdGlvbiAmIDEsXG5cdFx0XHRib3VuZHNTZWxlY3RlZCA9IHNlbGVjdGlvbiAmIDJcblx0XHRcdFx0XHR8fCBpdGVtU2VsZWN0ZWQgJiYgdGhpcy5fc2VsZWN0Qm91bmRzLFxuXHRcdFx0cG9zaXRpb25TZWxlY3RlZCA9IHNlbGVjdGlvbiAmIDQ7XG5cdFx0aWYgKCF0aGlzLl9kcmF3U2VsZWN0ZWQpXG5cdFx0XHRpdGVtU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRpZiAoKGl0ZW1TZWxlY3RlZCB8fCBib3VuZHNTZWxlY3RlZCB8fCBwb3NpdGlvblNlbGVjdGVkKVxuXHRcdFx0XHQmJiB0aGlzLl9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcblx0XHRcdHZhciBsYXllcixcblx0XHRcdFx0Y29sb3IgPSB0aGlzLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSkgfHwgKGxheWVyID0gdGhpcy5nZXRMYXllcigpKVxuXHRcdFx0XHRcdCYmIGxheWVyLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSksXG5cdFx0XHRcdG14ID0gbWF0cml4LmFwcGVuZGVkKHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpKSxcblx0XHRcdFx0aGFsZiA9IHNpemUgLyAyO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cdFx0XHRcdFx0PyBjb2xvci50b0NhbnZhc1N0eWxlKGN0eCkgOiAnIzAwOWRlYyc7XG5cdFx0XHRpZiAoaXRlbVNlbGVjdGVkKVxuXHRcdFx0XHR0aGlzLl9kcmF3U2VsZWN0ZWQoY3R4LCBteCwgc2VsZWN0aW9uSXRlbXMpO1xuXHRcdFx0aWYgKHBvc2l0aW9uU2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcblx0XHRcdFx0XHR4ID0gcG9pbnQueCxcblx0XHRcdFx0XHR5ID0gcG9pbnQueTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKHgsIHksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR2YXIgZGVsdGFzID0gW1swLCAtMV0sIFsxLCAwXSwgWzAsIDFdLCBbLTEsIDBdXSxcblx0XHRcdFx0XHRzdGFydCA9IGhhbGYsXG5cdFx0XHRcdFx0ZW5kID0gc2l6ZSArIDE7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGRlbHRhID0gZGVsdGFzW2ldLFxuXHRcdFx0XHRcdFx0ZHggPSBkZWx0YVswXSxcblx0XHRcdFx0XHRcdGR5ID0gZGVsdGFbMV07XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4ICsgZHggKiBzdGFydCwgeSArIGR5ICogc3RhcnQpO1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oeCArIGR4ICogZW5kLCB5ICsgZHkgKiBlbmQpO1xuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGJvdW5kc1NlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBteC5fdHJhbnNmb3JtQ29ybmVycyh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRcdFx0Y3R4WyFpID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY29vcmRzW2ldLCBjb29yZHNbKytpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZixcblx0XHRcdFx0XHRcdFx0c2l6ZSwgc2l6ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59LCBCYXNlLmVhY2goWydkb3duJywgJ2RyYWcnLCAndXAnLCAnbW92ZSddLCBmdW5jdGlvbihrZXkpIHtcblx0dGhpc1sncmVtb3ZlT24nICsgQmFzZS5jYXBpdGFsaXplKGtleSldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHRoYXNoW2tleV0gPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZU9uKGhhc2gpO1xuXHR9O1xufSwge1xuXG5cdHJlbW92ZU9uOiBmdW5jdGlvbihvYmopIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0aWYgKG9ialtuYW1lXSkge1xuXHRcdFx0XHR2YXIga2V5ID0gJ21vdXNlJyArIG5hbWUsXG5cdFx0XHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdFx0c2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV0gPSBzZXRzW2tleV0gfHwge307XG5cdFx0XHRcdHNldHNba2V5XVt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSkpO1xuXG52YXIgR3JvdXAgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyb3VwJyxcblx0X3NlbGVjdEJvdW5kczogZmFsc2UsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgMTAyNikge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW2ldLl9jbGlwTWFzaykge1xuXHRcdFx0XHRcdGNsaXBJdGVtID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NsaXBJdGVtID0gY2xpcEl0ZW07XG5cdFx0fVxuXHRcdHJldHVybiBjbGlwSXRlbTtcblx0fSxcblxuXHRpc0NsaXBwZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldENsaXBJdGVtKCk7XG5cdH0sXG5cblx0c2V0Q2xpcHBlZDogZnVuY3Rpb24oY2xpcHBlZCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdGlmIChjaGlsZClcblx0XHRcdGNoaWxkLnNldENsaXBNYXNrKGNsaXBwZWQpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uIF9nZXRCb3VuZHMobWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0XHRyZXR1cm4gY2xpcEl0ZW1cblx0XHRcdD8gY2xpcEl0ZW0uX2dldENhY2hlZEJvdW5kcyhcblx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChjbGlwSXRlbS5fbWF0cml4KSxcblx0XHRcdFx0QmFzZS5zZXQoe30sIG9wdGlvbnMsIHsgc3Ryb2tlOiBmYWxzZSB9KSlcblx0XHRcdDogX2dldEJvdW5kcy5iYXNlLmNhbGwodGhpcywgbWF0cml4LCBvcHRpb25zKTtcblx0fSxcblxuXHRfaGl0VGVzdENoaWxkcmVuOiBmdW5jdGlvbiBfaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0XHRyZXR1cm4gKCFjbGlwSXRlbSB8fCBjbGlwSXRlbS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdCYmIF9oaXRUZXN0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LFxuXHRcdFx0XHRcdGNsaXBJdGVtKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHZhciBjbGlwID0gcGFyYW0uY2xpcCxcblx0XHRcdGNsaXBJdGVtID0gIWNsaXAgJiYgdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdHBhcmFtLmRvbnRTdGFydCA9IHBhcmFtLmRvbnRGaW5pc2ggPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoY2xpcEl0ZW0pIHtcblx0XHRcdGNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHR9XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pXG5cdFx0XHRcdGl0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgTGF5ZXIgPSBHcm91cC5leHRlbmQoe1xuXHRfY2xhc3M6ICdMYXllcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTGF5ZXIoKSB7XG5cdFx0R3JvdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRfZ2V0T3duZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgfHwgdGhpcy5faW5kZXggIT0gbnVsbCAmJiB0aGlzLl9wcm9qZWN0O1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uIGlzSW5zZXJ0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGlzSW5zZXJ0ZWQuYmFzZS5jYWxsKHRoaXMpIDogdGhpcy5faW5kZXggIT0gbnVsbDtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24oKSB7XG5cdH1cbn0pO1xuXG52YXIgU2hhcGUgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NoYXBlJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhblNjYWxlU3Ryb2tlOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0dHlwZTogbnVsbCxcblx0XHRzaXplOiBudWxsLFxuXHRcdHJhZGl1czogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNoYXBlKHByb3BzLCBwb2ludCkge1xuXHRcdHRoaXMuX2luaXRpYWxpemUocHJvcHMsIHBvaW50KTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGVcblx0XHRcdCYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpXG5cdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0VHlwZShzb3VyY2UuX3R5cGUpO1xuXHRcdHRoaXMuc2V0U2l6ZShzb3VyY2UuX3NpemUpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHNvdXJjZS5fcmFkaXVzKTtcblx0fSxcblxuXHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fSxcblxuXHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdH0sXG5cblx0Z2V0U2hhcGU6ICcjZ2V0VHlwZScsXG5cdHNldFNoYXBlOiAnI3NldFR5cGUnLFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0fSBlbHNlIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikpKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0d2lkdGggPSBoZWlnaHQgPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gd2lkdGggLyAyO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLl9zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NpemUuX3NldCh3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJhZCA9IHRoaXMuX3JhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gJ2NpcmNsZSdcblx0XHRcdFx0PyByYWRcblx0XHRcdFx0OiBuZXcgTGlua2VkU2l6ZShyYWQud2lkdGgsIHJhZC5oZWlnaHQsIHRoaXMsICdzZXRSYWRpdXMnKTtcblx0fSxcblxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uKHJhZGl1cykge1xuXHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZTtcblx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdGlmIChyYWRpdXMgPT09IHRoaXMuX3JhZGl1cylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHNpemUgPSByYWRpdXMgKiAyO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdFx0dGhpcy5fc2l6ZS5fc2V0KHNpemUsIHNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdGlmICghdGhpcy5fcmFkaXVzKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cy5jbG9uZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3JhZGl1cy5lcXVhbHMocmFkaXVzKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzKTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBTaXplLm1heCh0aGlzLl9zaXplLCByYWRpdXMubXVsdGlwbHkoMikpO1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuX3NldChyYWRpdXMud2lkdGggKiAyLCByYWRpdXMuaGVpZ2h0ICogMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dG9QYXRoOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoW0Jhc2UuY2FwaXRhbGl6ZSh0aGlzLl90eXBlKV0oe1xuXHRcdFx0Y2VudGVyOiBuZXcgUG9pbnQoKSxcblx0XHRcdHNpemU6IHRoaXMuX3NpemUsXG5cdFx0XHRyYWRpdXM6IHRoaXMuX3JhZGl1cyxcblx0XHRcdGluc2VydDogZmFsc2Vcblx0XHR9KTtcblx0XHRwYXRoLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdGlmIChwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeClcblx0XHRcdHBhdGguc2V0QXBwbHlNYXRyaXgodHJ1ZSk7XG5cdFx0aWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydClcblx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0sXG5cblx0dG9TaGFwZTogJyNjbG9uZScsXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRvUGF0aChmYWxzZSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuXHRcdFx0dW50cmFuc2Zvcm1lZCA9ICFzdHJva2VNYXRyaXg7XG5cdFx0aWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlIHx8IGRvbnRQYWludCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdGlzQ2lyY2xlID0gdHlwZSA9PT0gJ2NpcmNsZSc7XG5cdFx0XHRpZiAoIXBhcmFtLmRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0aWYgKHVudHJhbnNmb3JtZWQgJiYgaXNDaXJjbGUpIHtcblx0XHRcdFx0Y3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByeCA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLndpZHRoLFxuXHRcdFx0XHRcdHJ5ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdHNpemUgPSB0aGlzLl9zaXplLFxuXHRcdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdFx0aWYgKHVudHJhbnNmb3JtZWQgJiYgdHlwZSA9PT0gJ3JlY3RhbmdsZScgJiYgcnggPT09IDAgJiYgcnkgPT09IDApIHtcblx0XHRcdFx0XHRjdHgucmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHggPSB3aWR0aCAvIDIsXG5cdFx0XHRcdFx0XHR5ID0gaGVpZ2h0IC8gMixcblx0XHRcdFx0XHRcdGthcHBhID0gMSAtIDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRcdFx0XHRcdGN4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRcdGN5ID0gcnkgKiBrYXBwYSxcblx0XHRcdFx0XHRcdGMgPSBbXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIC15LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIHksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gcnlcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0aWYgKHN0cm9rZU1hdHJpeClcblx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeC50cmFuc2Zvcm0oYywgYywgMzIpO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY1swXSwgY1sxXSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSwgY1s3XSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzhdLCBjWzldKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzEwXSwgY1sxMV0sIGNbMTJdLCBjWzEzXSwgY1sxNF0sIGNbMTVdKTtcblx0XHRcdFx0XHRpZiAoeSAhPT0gcnkpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMTZdLCBjWzE3XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxOF0sIGNbMTldLCBjWzIwXSwgY1syMV0sIGNbMjJdLCBjWzIzXSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzI0XSwgY1syNV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMjZdLCBjWzI3XSwgY1syOF0sIGNbMjldLCBjWzMwXSwgY1szMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldEZpbGxSdWxlKCkpO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzU3Ryb2tlKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG5cdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0c3Ryb2tlV2lkdGggPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKVxuXHRcdFx0XHRcdCYmIHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdHJlY3QgPSBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KTtcblx0XHRyZXR1cm4gc3Ryb2tlV2lkdGhcblx0XHRcdFx0PyByZWN0LmV4cGFuZChQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVdpZHRoLFxuXHRcdFx0XHRcdHRoaXMuX2dldFN0cm9rZU1hdHJpeChtYXRyaXgsIG9wdGlvbnMpKSlcblx0XHRcdFx0OiByZWN0O1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDb3JuZXJDZW50ZXIodGhhdCwgcG9pbnQsIGV4cGFuZCkge1xuXHRcdHZhciByYWRpdXMgPSB0aGF0Ll9yYWRpdXM7XG5cdFx0aWYgKCFyYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBoYWxmU2l6ZSA9IHRoYXQuX3NpemUuZGl2aWRlKDIpO1xuXHRcdFx0Zm9yICh2YXIgcSA9IDE7IHEgPD0gNDsgcSsrKSB7XG5cdFx0XHRcdHZhciBkaXIgPSBuZXcgUG9pbnQocSA+IDEgJiYgcSA8IDQgPyAtMSA6IDEsIHEgPiAyID8gLTEgOiAxKSxcblx0XHRcdFx0XHRjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuXHRcdFx0XHRcdGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG5cdFx0XHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUoXG5cdFx0XHRcdFx0XHRcdGV4cGFuZCA/IGNvcm5lci5hZGQoZGlyLm11bHRpcGx5KGV4cGFuZCkpIDogY29ybmVyLFxuXHRcdFx0XHRcdFx0XHRjZW50ZXIpO1xuXHRcdFx0XHRpZiAocmVjdC5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIHsgcG9pbnQ6IGNlbnRlciwgcXVhZHJhbnQ6IHEgfTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpc09uRWxsaXBzZVN0cm9rZShwb2ludCwgcmFkaXVzLCBwYWRkaW5nLCBxdWFkcmFudCkge1xuXHRcdHZhciB2ZWN0b3IgPSBwb2ludC5kaXZpZGUocmFkaXVzKTtcblx0XHRyZXR1cm4gKCFxdWFkcmFudCB8fCB2ZWN0b3IuaXNJblF1YWRyYW50KHF1YWRyYW50KSkgJiZcblx0XHRcdFx0dmVjdG9yLnN1YnRyYWN0KHZlY3Rvci5ub3JtYWxpemUoKSkubXVsdGlwbHkocmFkaXVzKVxuXHRcdFx0XHRcdC5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9jb250YWluczogZnVuY3Rpb24gX2NvbnRhaW5zKHBvaW50KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCk7XG5cdFx0XHRcdHJldHVybiBjZW50ZXJcblx0XHRcdFx0XHRcdD8gcG9pbnQuc3VidHJhY3QoY2VudGVyLnBvaW50KS5kaXZpZGUodGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRcdFx0XHQuZ2V0TGVuZ3RoKCkgPD0gMVxuXHRcdFx0XHRcdFx0OiBfY29udGFpbnMuYmFzZS5jYWxsKHRoaXMsIHBvaW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBwb2ludC5kaXZpZGUodGhpcy5zaXplKS5nZXRMZW5ndGgoKSA8PSAwLjU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LFxuXHRcdFx0XHRzdHJva2VNYXRyaXgpIHtcblx0XHRcdHZhciBoaXQgPSBmYWxzZSxcblx0XHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdFx0aGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRcdGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpO1xuXHRcdFx0aWYgKGhpdFN0cm9rZSB8fCBoaXRGaWxsKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdFx0c3Ryb2tlUmFkaXVzID0gaGl0U3Ryb2tlID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiAwLFxuXHRcdFx0XHRcdHN0cm9rZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLmFkZChcblx0XHRcdFx0XHRcdFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQhc3R5bGUuZ2V0U3Ryb2tlU2NhbGluZygpICYmIHN0cm9rZU1hdHJpeCkpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgcGFkZGluZyA9IHN0cm9rZVBhZGRpbmcubXVsdGlwbHkoMiksXG5cdFx0XHRcdFx0XHRjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHBhZGRpbmcpO1xuXHRcdFx0XHRcdGlmIChjZW50ZXIpIHtcblx0XHRcdFx0XHRcdGhpdCA9IGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LnN1YnRyYWN0KGNlbnRlci5wb2ludCksXG5cdFx0XHRcdFx0XHRcdFx0cmFkaXVzLCBzdHJva2VQYWRkaW5nLCBjZW50ZXIucXVhZHJhbnQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApLFxuXHRcdFx0XHRcdFx0XHRvdXRlciA9IHJlY3QuZXhwYW5kKHBhZGRpbmcpLFxuXHRcdFx0XHRcdFx0XHRpbm5lciA9IHJlY3QuZXhwYW5kKHBhZGRpbmcubmVnYXRlKCkpO1xuXHRcdFx0XHRcdFx0aGl0ID0gb3V0ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0JiYgIWlubmVyLl9jb250YWluc1BvaW50KHBvaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGl0ID0gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQsIHJhZGl1cywgc3Ryb2tlUGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoaXQgPyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2ZpbGwnLCB0aGlzKVxuXHRcdFx0XHRcdDogX2hpdFRlc3RTZWxmLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59LCB7XG5cbnN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gY3JlYXRlU2hhcGUodHlwZSwgcG9pbnQsIHNpemUsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBpdGVtID0gbmV3IFNoYXBlKEJhc2UuZ2V0TmFtZWQoYXJncyksIHBvaW50KTtcblx0XHRpdGVtLl90eXBlID0gdHlwZTtcblx0XHRpdGVtLl9zaXplID0gc2l6ZTtcblx0XHRpdGVtLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzT3B0aW9uczogeyBzdHJva2U6IGZhbHNlLCBoYW5kbGU6IGZhbHNlIH0sXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjcm9zc09yaWdpbjogbnVsbCxcblx0XHRzb3VyY2U6IG51bGxcblx0fSxcblx0X3ByaW9yaXRpemU6IFsnY3Jvc3NPcmlnaW4nXSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSYXN0ZXIob2JqZWN0LCBwb3NpdGlvbikge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShvYmplY3QsXG5cdFx0XHRcdHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSkge1xuXHRcdFx0dmFyIGltYWdlID0gdHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHQ/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iamVjdCkgOiBvYmplY3Q7XG5cdFx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShpbWFnZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldFNvdXJjZShvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZSgpO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcblx0fSxcblxuXHRjb3B5Q29udGVudDogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGltYWdlID0gc291cmNlLl9pbWFnZSxcblx0XHRcdGNhbnZhcyA9IHNvdXJjZS5fY2FudmFzO1xuXHRcdGlmIChpbWFnZSkge1xuXHRcdFx0dGhpcy5fc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdH0gZWxzZSBpZiAoY2FudmFzKSB7XG5cdFx0XHR2YXIgY29weUNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzb3VyY2UuX3NpemUpO1xuXHRcdFx0Y29weUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuXHRcdFx0dGhpcy5fc2V0SW1hZ2UoY29weUNhbnZhcyk7XG5cdFx0fVxuXHRcdHRoaXMuX2Nyb3NzT3JpZ2luID0gc291cmNlLl9jcm9zc09yaWdpbjtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUgPyBzaXplLndpZHRoIDogMCwgc2l6ZSA/IHNpemUuaGVpZ2h0IDogMCxcblx0XHRcdFx0dGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghc2l6ZS5lcXVhbHModGhpcy5fc2l6ZSkpIHtcblx0XHRcdGlmIChzaXplLndpZHRoID4gMCAmJiBzaXplLmhlaWdodCA+IDApIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRcdFx0dGhpcy5fc2V0SW1hZ2UoQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpKTtcblx0XHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLFxuXHRcdFx0XHRcdFx0XHRzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblx0XHRcdFx0dGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplID8gdGhpcy5fc2l6ZS53aWR0aCA6IDA7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5zZXRTaXplKHdpZHRoLCB0aGlzLmdldEhlaWdodCgpKTtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplID8gdGhpcy5fc2l6ZS5oZWlnaHQgOiAwO1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG5cdFx0dGhpcy5zZXRTaXplKHRoaXMuZ2V0V2lkdGgoKSwgaGVpZ2h0KTtcblx0fSxcblxuXHRnZXRMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkZWQ7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiAhc2l6ZSB8fCBzaXplLndpZHRoID09PSAwICYmIHNpemUuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0dSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcblx0XHRcdHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0NzIgLyB1LmdldExlbmd0aCgpLFxuXHRcdFx0NzIgLyB2LmdldExlbmd0aCgpXG5cdFx0KTtcblx0fSxcblxuXHRnZXRQcGk6ICcjZ2V0UmVzb2x1dGlvbicsXG5cblx0Z2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG5cdFx0XHR2YXIgdmlldyA9IHRoYXQuZ2V0VmlldygpLFxuXHRcdFx0XHR0eXBlID0gZXZlbnQgJiYgZXZlbnQudHlwZSB8fCAnbG9hZCc7XG5cdFx0XHRpZiAodmlldyAmJiB0aGF0LnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdHBhcGVyID0gdmlldy5fc2NvcGU7XG5cdFx0XHRcdHRoYXQuZW1pdCh0eXBlLCBuZXcgRXZlbnQoZXZlbnQpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRJbWFnZShpbWFnZSk7XG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0c2V0VGltZW91dChlbWl0LCAwKTtcblx0XHR9IGVsc2UgaWYgKGltYWdlKSB7XG5cdFx0XHREb21FdmVudC5hZGQoaW1hZ2UsIHtcblx0XHRcdFx0bG9hZDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHR0aGF0Ll9zZXRJbWFnZShpbWFnZSk7XG5cdFx0XHRcdFx0ZW1pdChldmVudCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBlbWl0XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X3NldEltYWdlOiBmdW5jdGlvbihpbWFnZSkge1xuXHRcdGlmICh0aGlzLl9jYW52YXMpXG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0aWYgKGltYWdlICYmIGltYWdlLmdldENvbnRleHQpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IGltYWdlO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IG51bGw7XG5cdFx0XHR0aGlzLl9sb2FkZWQgPSAhIShpbWFnZSAmJiBpbWFnZS5zcmMgJiYgaW1hZ2UuY29tcGxldGUpO1xuXHRcdH1cblx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLndpZHRoIDogMCxcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IGltYWdlLmhlaWdodCA6IDApO1xuXHRcdHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXHRcdHRoaXMuX2NoYW5nZWQoNTIxKTtcblx0fSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbWFnZSlcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcblx0XHRcdFx0dGhpcy5fY2FudmFzID0gY3R4LmNhbnZhcztcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzO1xuXHR9LFxuXG5cdHNldENhbnZhczogJyNzZXRJbWFnZScsXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24obW9kaWZ5KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZXh0KVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAobW9kaWZ5KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDUxMyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHR9LFxuXG5cdHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblx0fSxcblxuXHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlO1xuXHRcdHJldHVybiBpbWFnZSAmJiBpbWFnZS5zcmMgfHwgdGhpcy50b0RhdGFVUkwoKTtcblx0fSxcblxuXHRzZXRTb3VyY2U6IGZ1bmN0aW9uKHNyYykge1xuXHRcdHZhciBpbWFnZSA9IG5ldyBzZWxmLkltYWdlKCksXG5cdFx0XHRjcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdGlmIChjcm9zc09yaWdpbilcblx0XHRcdGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdFx0aW1hZ2Uuc3JjID0gc3JjO1xuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcblx0XHRyZXR1cm4gaW1hZ2UgJiYgaW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcblx0XHRpZiAoaW1hZ2UpXG5cdFx0XHRpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5fbG9hZGVkICYmIHRoaXMuX2ltYWdlO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuX3NldEltYWdlKHRoaXMuZ2V0U3ViQ2FudmFzKHJlY3QpKTtcblx0XHRyYXN0ZXIudHJhbnNsYXRlKHJlY3QuZ2V0Q2VudGVyKCkuc3VidHJhY3QodGhpcy5nZXRTaXplKCkuZGl2aWRlKDIpKSk7XG5cdFx0cmFzdGVyLl9tYXRyaXgucHJlcGVuZCh0aGlzLl9tYXRyaXgpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdHRvRGF0YVVSTDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXG5cdFx0XHRzcmMgPSBpbWFnZSAmJiBpbWFnZS5zcmM7XG5cdFx0aWYgKC9eZGF0YTovLnRlc3Qoc3JjKSlcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy50b0RhdGFVUkwuYXBwbHkoY2FudmFzLCBhcmd1bWVudHMpIDogbnVsbDtcblx0fSxcblxuXHRkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGltYWdlLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHZhciBib3VuZHMsIHBhdGg7XG5cdFx0aWYgKCFvYmplY3QpIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuXHRcdFx0cGF0aCA9IG9iamVjdDtcblx0XHRcdGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAoJ3dpZHRoJyBpbiBvYmplY3QpIHtcblx0XHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QpO1xuXHRcdFx0fSBlbHNlIGlmICgneCcgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0LnggLSAwLjUsIG9iamVjdC55IC0gMC41LCAxLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFib3VuZHMpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgc2FtcGxlU2l6ZSA9IDMyLFxuXHRcdFx0d2lkdGggPSBNYXRoLm1pbihib3VuZHMud2lkdGgsIHNhbXBsZVNpemUpLFxuXHRcdFx0aGVpZ2h0ID0gTWF0aC5taW4oYm91bmRzLmhlaWdodCwgc2FtcGxlU2l6ZSk7XG5cdFx0dmFyIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dDtcblx0XHRpZiAoIWN0eCkge1xuXHRcdFx0Y3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChcblx0XHRcdFx0XHRuZXcgU2l6ZShzYW1wbGVTaXplKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2FtcGxlU2l6ZSArIDEsIHNhbXBsZVNpemUgKyAxKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpXG5cdFx0XHRcdC5zY2FsZSh3aWR0aCAvIGJvdW5kcy53aWR0aCwgaGVpZ2h0IC8gYm91bmRzLmhlaWdodClcblx0XHRcdFx0LnRyYW5zbGF0ZSgtYm91bmRzLngsIC1ib3VuZHMueSk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0aWYgKHBhdGgpXG5cdFx0XHRwYXRoLmRyYXcoY3R4LCBuZXcgQmFzZSh7IGNsaXA6IHRydWUsIG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0dGhpcy5fbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKSxcblx0XHRcdHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdGlmIChlbGVtZW50KVxuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LCAtc2l6ZS53aWR0aCAvIDIsIC1zaXplLmhlaWdodCAvIDIpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksXG5cdFx0XHRcdE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuXHRcdFx0Y2hhbm5lbHMgPSBbMCwgMCwgMF0sXG5cdFx0XHR0b3RhbCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXHRcdFx0dG90YWwgKz0gYWxwaGE7XG5cdFx0XHRhbHBoYSAvPSAyNTU7XG5cdFx0XHRjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG5cdFx0XHRjaGFubmVsc1tpXSAvPSB0b3RhbDtcblx0XHRyZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSxcblx0XHRcdFx0ZGF0YVszXSAvIDI1NSk7XG5cdH0sXG5cblx0c2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdGFscGhhID0gY29sb3IuX2FscGhhLFxuXHRcdFx0Y3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0aW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcblx0XHRcdGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcblx0XHRkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcblx0XHRkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcblx0XHRkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fb3BhY2l0eTtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcblx0XHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBTeW1ib2xJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2xJdGVtJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc09wdGlvbnM6IHsgc3Ryb2tlOiB0cnVlIH0sXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzeW1ib2w6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTeW1ib2xJdGVtKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnMCxcblx0XHRcdFx0YXJnMSAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpXG5cdFx0XHR0aGlzLnNldERlZmluaXRpb24oYXJnMCBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24gP1xuXHRcdFx0XHRcdGFyZzAgOiBuZXcgU3ltYm9sRGVmaW5pdGlvbihhcmcwKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uID09PSBpdGVtLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR0aGlzLnNldERlZmluaXRpb24oc291cmNlLl9kZWZpbml0aW9uKTtcblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcblx0fSxcblxuXHRzZXREZWZpbml0aW9uOiBmdW5jdGlvbihkZWZpbml0aW9uKSB7XG5cdFx0dGhpcy5fZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRnZXRTeW1ib2w6ICcjZ2V0RGVmaW5pdGlvbicsXG5cdHNldFN5bWJvbDogJyNzZXREZWZpbml0aW9uJyxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5pc0VtcHR5KCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzLl9kZWZpbml0aW9uLl9pdGVtO1xuXHRcdHJldHVybiBpdGVtLl9nZXRDYWNoZWRCb3VuZHMoaXRlbS5fbWF0cml4LnByZXBlbmRlZChtYXRyaXgpLCBvcHRpb25zKTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4KSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpO1xuXHRcdGlmIChyZXMpXG5cdFx0XHRyZXMuaXRlbSA9IHRoaXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHRoaXMuX2RlZmluaXRpb24uX2l0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcblx0fVxuXG59KTtcblxudmFyIFN5bWJvbERlZmluaXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbERlZmluaXRpb24nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbERlZmluaXRpb24oaXRlbSwgZG9udENlbnRlcikge1xuXHRcdHRoaXMuX2lkID0gVUlELmdldCgpO1xuXHRcdHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKGl0ZW0pXG5cdFx0XHR0aGlzLnNldEl0ZW0oaXRlbSwgZG9udENlbnRlcik7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fY2xhc3MsIHRoaXMuX2l0ZW1dLFxuXHRcdFx0XHRcdG9wdGlvbnMsIGZhbHNlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHRpZiAoZmxhZ3MgJiA4KVxuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHRpZiAoZmxhZ3MgJiAxKVxuXHRcdFx0dGhpcy5wcm9qZWN0Ll9jaGFuZ2VkKGZsYWdzKTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fSxcblxuXHRzZXRJdGVtOiBmdW5jdGlvbihpdGVtLCBfZG9udENlbnRlcikge1xuXHRcdGlmIChpdGVtLl9zeW1ib2wpXG5cdFx0XHRpdGVtID0gaXRlbS5jbG9uZSgpO1xuXHRcdGlmICh0aGlzLl9pdGVtKVxuXHRcdFx0dGhpcy5faXRlbS5fc3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuXHRcdGlmICghX2RvbnRDZW50ZXIpXG5cdFx0XHRpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcblx0XHRpdGVtLl9zeW1ib2wgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0Z2V0RGVmaW5pdGlvbjogJyNnZXRJdGVtJyxcblx0c2V0RGVmaW5pdGlvbjogJyNzZXRJdGVtJyxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbEl0ZW0odGhpcywgcG9zaXRpb24pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbERlZmluaXRpb24odGhpcy5faXRlbS5jbG9uZShmYWxzZSkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0cmV0dXJuIHN5bWJvbCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBzeW1ib2wgJiYgdGhpcy5faXRlbS5lcXVhbHMoc3ltYm9sLl9pdGVtKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtID0gaXRlbTtcblx0XHRpZiAodmFsdWVzKVxuXHRcdFx0dGhpcy5pbmplY3QodmFsdWVzKTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmdzICYmIEJhc2UucmVhZChhcmdzKTtcblx0XHRcdHJldHVybiBCYXNlLnNldCh7XG5cdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdHRvbGVyYW5jZTogcGFwZXIuc2V0dGluZ3MuaGl0VG9sZXJhbmNlLFxuXHRcdFx0XHRmaWxsOiAhb3B0aW9ucyxcblx0XHRcdFx0c3Ryb2tlOiAhb3B0aW9ucyxcblx0XHRcdFx0c2VnbWVudHM6ICFvcHRpb25zLFxuXHRcdFx0XHRoYW5kbGVzOiBmYWxzZSxcblx0XHRcdFx0ZW5kczogZmFsc2UsXG5cdFx0XHRcdHBvc2l0aW9uOiBmYWxzZSxcblx0XHRcdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRcdFx0Ym91bmRzOiBmYWxzZSxcblx0XHRcdFx0Z3VpZGVzOiBmYWxzZSxcblx0XHRcdFx0c2VsZWN0ZWQ6IGZhbHNlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2VnbWVudCcsXG5cdGJlYW5zOiB0cnVlLFxuXHRfc2VsZWN0aW9uOiAwLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRwb2ludCwgaGFuZGxlSW4sIGhhbmRsZU91dCwgc2VsZWN0aW9uO1xuXHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdGlmIChhcmcwID09IG51bGwgfHwgdHlwZW9mIGFyZzAgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChjb3VudCA9PT0gMSAmJiBhcmcwICYmICdwb2ludCcgaW4gYXJnMCkge1xuXHRcdFx0XHRcdHBvaW50ID0gYXJnMC5wb2ludDtcblx0XHRcdFx0XHRoYW5kbGVJbiA9IGFyZzAuaGFuZGxlSW47XG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gYXJnMC5zZWxlY3Rpb247XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0XHRcdGhhbmRsZUluID0gYXJnMTtcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcyO1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IGFyZzM7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gWyBhcmcwLCBhcmcxIF07XG5cdFx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0XHRoYW5kbGVPdXQgPSBhcmc0ICE9PSB1bmRlZmluZWQgPyBbIGFyZzQsIGFyZzUgXSA6IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG5ldyBTZWdtZW50UG9pbnQocG9pbnQsIHRoaXMsICdfcG9pbnQnKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZUluLCB0aGlzLCAnX2hhbmRsZUluJyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVPdXQsIHRoaXMsICdfaGFuZGxlT3V0Jyk7XG5cdFx0aWYgKHNlbGVjdGlvbilcblx0XHRcdHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0c2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uLFxuXHRcdFx0b2JqID0gc2VsZWN0aW9uIHx8IHRoaXMuaGFzSGFuZGxlcygpXG5cdFx0XHRcdFx0PyBbcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdXG5cdFx0XHRcdFx0OiBwb2ludDtcblx0XHRpZiAoc2VsZWN0aW9uKVxuXHRcdFx0b2JqLnB1c2goc2VsZWN0aW9uKTtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlT3V0O1xuXHR9LFxuXG5cdHNldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5faGFuZGxlT3V0LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcblx0fSxcblxuXHRpc1Ntb290aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQ7XG5cdFx0cmV0dXJuICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdCYmIGhhbmRsZUluLmlzQ29sbGluZWFyKGhhbmRsZU91dCk7XG5cdH0sXG5cblx0Y2xlYXJIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXHR9LFxuXG5cdGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXHRcdHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG5cdFx0XHRwYXRoID0gdGhpcy5fcGF0aDtcblx0XHR0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgMDtcblx0XHRpZiAocGF0aCAmJiBzZWxlY3Rpb24gIT09IG9sZFNlbGVjdGlvbikge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFNlbGVjdGlvbiwgc2VsZWN0aW9uKTtcblx0XHRcdHBhdGguX2NoYW5nZWQoMTI5KTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZVNlbGVjdGlvbjogZnVuY3Rpb24oZmxhZywgc2VsZWN0ZWQpIHtcblx0XHR2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uO1xuXHRcdHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGVkID8gc2VsZWN0aW9uIHwgZmxhZyA6IHNlbGVjdGlvbiAmIH5mbGFnKTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgNyk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fY2hhbmdlU2VsZWN0aW9uKDcsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9pbmRleCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGggfHwgbnVsbDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleDtcblx0XHRpZiAocGF0aCkge1xuXHRcdFx0aWYgKGluZGV4ID4gMCAmJiAhcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0JiYgaW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEpXG5cdFx0XHRcdGluZGV4LS07XG5cdFx0XHRyZXR1cm4gcGF0aC5nZXRDdXJ2ZXMoKVtpbmRleF0gfHwgbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmVcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZSwgdGhpcyA9PT0gY3VydmUuX3NlZ21lbnQxID8gMCA6IDEpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuXHRcdHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0c21vb3RoOiBmdW5jdGlvbihvcHRpb25zLCBfZmlyc3QsIF9sYXN0KSB7XG5cdFx0dmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9LFxuXHRcdFx0dHlwZSA9IG9wdHMudHlwZSxcblx0XHRcdGZhY3RvciA9IG9wdHMuZmFjdG9yLFxuXHRcdFx0cHJldiA9IHRoaXMuZ2V0UHJldmlvdXMoKSxcblx0XHRcdG5leHQgPSB0aGlzLmdldE5leHQoKSxcblx0XHRcdHAwID0gKHByZXYgfHwgdGhpcykuX3BvaW50LFxuXHRcdFx0cDEgPSB0aGlzLl9wb2ludCxcblx0XHRcdHAyID0gKG5leHQgfHwgdGhpcykuX3BvaW50LFxuXHRcdFx0ZDEgPSBwMC5nZXREaXN0YW5jZShwMSksXG5cdFx0XHRkMiA9IHAxLmdldERpc3RhbmNlKHAyKTtcblx0XHRpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ2NhdG11bGwtcm9tJykge1xuXHRcdFx0dmFyIGEgPSBmYWN0b3IgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGZhY3Rvcixcblx0XHRcdFx0ZDFfYSA9IE1hdGgucG93KGQxLCBhKSxcblx0XHRcdFx0ZDFfMmEgPSBkMV9hICogZDFfYSxcblx0XHRcdFx0ZDJfYSA9IE1hdGgucG93KGQyLCBhKSxcblx0XHRcdFx0ZDJfMmEgPSBkMl9hICogZDJfYTtcblx0XHRcdGlmICghX2ZpcnN0ICYmIHByZXYpIHtcblx0XHRcdFx0dmFyIEEgPSAyICogZDJfMmEgKyAzICogZDJfYSAqIGQxX2EgKyBkMV8yYSxcblx0XHRcdFx0XHROID0gMyAqIGQyX2EgKiAoZDJfYSArIGQxX2EpO1xuXHRcdFx0XHR0aGlzLnNldEhhbmRsZUluKE4gIT09IDBcblx0XHRcdFx0XHQ/IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdChkMl8yYSAqIHAwLl94ICsgQSAqIHAxLl94IC0gZDFfMmEgKiBwMi5feCkgLyBOIC0gcDEuX3gsXG5cdFx0XHRcdFx0XHQoZDJfMmEgKiBwMC5feSArIEEgKiBwMS5feSAtIGQxXzJhICogcDIuX3kpIC8gTiAtIHAxLl95KVxuXHRcdFx0XHRcdDogbmV3IFBvaW50KCkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFfbGFzdCAmJiBuZXh0KSB7XG5cdFx0XHRcdHZhciBBID0gMiAqIGQxXzJhICsgMyAqIGQxX2EgKiBkMl9hICsgZDJfMmEsXG5cdFx0XHRcdFx0TiA9IDMgKiBkMV9hICogKGQxX2EgKyBkMl9hKTtcblx0XHRcdFx0dGhpcy5zZXRIYW5kbGVPdXQoTiAhPT0gMFxuXHRcdFx0XHRcdD8gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0KGQxXzJhICogcDIuX3ggKyBBICogcDEuX3ggLSBkMl8yYSAqIHAwLl94KSAvIE4gLSBwMS5feCxcblx0XHRcdFx0XHRcdChkMV8yYSAqIHAyLl95ICsgQSAqIHAxLl95IC0gZDJfMmEgKiBwMC5feSkgLyBOIC0gcDEuX3kpXG5cdFx0XHRcdFx0OiBuZXcgUG9pbnQoKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZ2VvbWV0cmljJykge1xuXHRcdFx0aWYgKHByZXYgJiYgbmV4dCkge1xuXHRcdFx0XHR2YXIgdmVjdG9yID0gcDAuc3VidHJhY3QocDIpLFxuXHRcdFx0XHRcdHQgPSBmYWN0b3IgPT09IHVuZGVmaW5lZCA/IDAuNCA6IGZhY3Rvcixcblx0XHRcdFx0XHRrID0gdCAqIGQxIC8gKGQxICsgZDIpO1xuXHRcdFx0XHRpZiAoIV9maXJzdClcblx0XHRcdFx0XHR0aGlzLnNldEhhbmRsZUluKHZlY3Rvci5tdWx0aXBseShrKSk7XG5cdFx0XHRcdGlmICghX2xhc3QpXG5cdFx0XHRcdFx0dGhpcy5zZXRIYW5kbGVPdXQodmVjdG9yLm11bHRpcGx5KGsgLSB0KSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignU21vb3RoaW5nIG1ldGhvZCBcXCcnICsgdHlwZSArICdcXCcgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRpc0ZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGlzTGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoICYmIHRoaXMuX2luZGV4ID09PSBwYXRoLl9zZWdtZW50cy5sZW5ndGggLSAxIHx8IGZhbHNlO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVJbiA9IHRoaXMuX2hhbmRsZUluLFxuXHRcdFx0aGFuZGxlT3V0ID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0dG1wID0gaGFuZGxlSW4uY2xvbmUoKTtcblx0XHRoYW5kbGVJbi5zZXQoaGFuZGxlT3V0KTtcblx0XHRoYW5kbGVPdXQuc2V0KHRtcCk7XG5cdH0sXG5cblx0cmV2ZXJzZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG5cdFx0dmFyIHUgPSAxIC0gZmFjdG9yLFxuXHRcdFx0diA9IGZhY3Rvcixcblx0XHRcdHBvaW50MSA9IGZyb20uX3BvaW50LFxuXHRcdFx0cG9pbnQyID0gdG8uX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4xID0gZnJvbS5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVJbjIgPSB0by5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQyID0gdG8uX2hhbmRsZU91dCxcblx0XHRcdGhhbmRsZU91dDEgPSBmcm9tLl9oYW5kbGVPdXQ7XG5cdFx0dGhpcy5fcG9pbnQuX3NldChcblx0XHRcdFx0dSAqIHBvaW50MS5feCArIHYgKiBwb2ludDIuX3gsXG5cdFx0XHRcdHUgKiBwb2ludDEuX3kgKyB2ICogcG9pbnQyLl95LCB0cnVlKTtcblx0XHR0aGlzLl9oYW5kbGVJbi5fc2V0KFxuXHRcdFx0XHR1ICogaGFuZGxlSW4xLl94ICsgdiAqIGhhbmRsZUluMi5feCxcblx0XHRcdFx0dSAqIGhhbmRsZUluMS5feSArIHYgKiBoYW5kbGVJbjIuX3ksIHRydWUpO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5fc2V0KFxuXHRcdFx0XHR1ICogaGFuZGxlT3V0MS5feCArIHYgKiBoYW5kbGVPdXQyLl94LFxuXHRcdFx0XHR1ICogaGFuZGxlT3V0MS5feSArIHYgKiBoYW5kbGVPdXQyLl95LCB0cnVlKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihtYXRyaXgsIGNvb3JkcywgY2hhbmdlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRoYW5kbGVJbiA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVJbiA6IG51bGwsXG5cdFx0XHRoYW5kbGVPdXQgPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZU91dCA6IG51bGwsXG5cdFx0XHR4ID0gcG9pbnQuX3gsXG5cdFx0XHR5ID0gcG9pbnQuX3ksXG5cdFx0XHRpID0gMjtcblx0XHRjb29yZHNbMF0gPSB4O1xuXHRcdGNvb3Jkc1sxXSA9IHk7XG5cdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIGkgLyAyKTtcblx0XHRcdHggPSBjb29yZHNbMF07XG5cdFx0XHR5ID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGNoYW5nZSkge1xuXHRcdFx0XHRwb2ludC5feCA9IHg7XG5cdFx0XHRcdHBvaW50Ll95ID0geTtcblx0XHRcdFx0aSA9IDI7XG5cdFx0XHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0XHRcdGhhbmRsZUluLl94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZUluLl95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWhhbmRsZUluKSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fVxufSk7XG5cbnZhciBTZWdtZW50UG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50UG9pbnQocG9pbnQsIG93bmVyLCBrZXkpIHtcblx0XHR2YXIgeCwgeSxcblx0XHRcdHNlbGVjdGVkO1xuXHRcdGlmICghcG9pbnQpIHtcblx0XHRcdHggPSB5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHkgPSBwb2ludFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQ7XG5cdFx0XHRpZiAoKHggPSBwdC54KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHB0ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR4ID0gcHQueDtcblx0XHRcdH1cblx0XHRcdHkgPSBwdC55O1xuXHRcdFx0c2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcblx0XHR9XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHRvd25lcltrZXldID0gdGhpcztcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuIGlzWmVybyh0aGlzLl94KSAmJiBpc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX293bmVyLl9zZWxlY3Rpb24gJiB0aGlzLl9nZXRTZWxlY3Rpb24oKSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZVNlbGVjdGlvbih0aGlzLl9nZXRTZWxlY3Rpb24oKSwgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdHJldHVybiB0aGlzID09PSBvd25lci5fcG9pbnQgPyAxXG5cdFx0XHQ6IHRoaXMgPT09IG93bmVyLl9oYW5kbGVJbiA/IDJcblx0XHRcdDogdGhpcyA9PT0gb3duZXIuX2hhbmRsZU91dCA/IDRcblx0XHRcdDogMDtcblx0fVxufSk7XG5cbnZhciBDdXJ2ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmUnLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHNlZzEsIHNlZzIsXG5cdFx0XHRwb2ludDEsIHBvaW50Mixcblx0XHRcdGhhbmRsZTEsIGhhbmRsZTI7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHNlZzEgPSBhcmcxO1xuXHRcdFx0c2VnMiA9IGFyZzI7XG5cdFx0fSBlbHNlIGlmICghY291bnQpIHtcblx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudCgpO1xuXHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0aWYgKCdzZWdtZW50MScgaW4gYXJnMCkge1xuXHRcdFx0XHRzZWcxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG5cdFx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQyKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3BvaW50MScgaW4gYXJnMCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwLnBvaW50MTtcblx0XHRcdFx0aGFuZGxlMSA9IGFyZzAuaGFuZGxlMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzAuaGFuZGxlMjtcblx0XHRcdFx0cG9pbnQyID0gYXJnMC5wb2ludDI7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0cG9pbnQxID0gW2FyZzBbMF0sIGFyZzBbMV1dO1xuXHRcdFx0XHRwb2ludDIgPSBbYXJnMFs2XSwgYXJnMFs3XV07XG5cdFx0XHRcdGhhbmRsZTEgPSBbYXJnMFsyXSAtIGFyZzBbMF0sIGFyZzBbM10gLSBhcmcwWzFdXTtcblx0XHRcdFx0aGFuZGxlMiA9IFthcmcwWzRdIC0gYXJnMFs2XSwgYXJnMFs1XSAtIGFyZzBbN11dO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcblx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudChhcmcxKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG5cdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0aGFuZGxlMSA9IGFyZzE7XG5cdFx0XHRoYW5kbGUyID0gYXJnMjtcblx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gOCkge1xuXHRcdFx0cG9pbnQxID0gW2FyZzAsIGFyZzFdO1xuXHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0aGFuZGxlMSA9IFthcmcyIC0gYXJnMCwgYXJnMyAtIGFyZzFdO1xuXHRcdFx0aGFuZGxlMiA9IFthcmc0IC0gYXJnNiwgYXJnNSAtIGFyZzddO1xuXHRcdH1cblx0XHR0aGlzLl9zZWdtZW50MSA9IHNlZzEgfHwgbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZzIgfHwgbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaGFzSGFuZGxlcygpXG5cdFx0XHRcdD8gW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0SGFuZGxlMSgpLCB0aGlzLmdldEhhbmRsZTIoKSxcblx0XHRcdFx0XHR0aGlzLmdldFBvaW50MigpXVxuXHRcdFx0XHQ6IFt0aGlzLmdldFBvaW50MSgpLCB0aGlzLmdldFBvaW50MigpXSxcblx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUxOiAnICsgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dCk7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUyOiAnICsgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluKTtcblx0XHRwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Y2xhc3NpZnk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDdXJ2ZS5jbGFzc2lmeSh0aGlzLmdldFZhbHVlcygpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dCk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGdldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50Mi5fcG9pbnQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzRmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuXHR9LFxuXG5cdGlzTGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoICYmIHRoaXMuX3NlZ21lbnQxLl9pbmRleCA9PT0gcGF0aC5fY3VydmVzLmxlbmd0aCAtIDFcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQxKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRQb2ludDIoKS5pc1NlbGVjdGVkKCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5nZXRQb2ludDEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldFBvaW50MigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRWYWx1ZXModGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyLCBtYXRyaXgpO1xuXHR9LFxuXG5cdGdldFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pKTtcblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9XG59LCB7XG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKVxuXHRcdFx0dGhpcy5fbGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBMaW5lKHRoaXMuX3NlZ21lbnQxLl9wb2ludCwgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcblx0fSxcblxuXHRnZXRQYXJ0OiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBuZXcgQ3VydmUoQ3VydmUuZ2V0UGFydCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0bykpO1xuXHR9LFxuXG5cdGdldFBhcnRMZW5ndGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0byk7XG5cdH0sXG5cblx0ZGl2aWRlQXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlQXRUaW1lKGxvY2F0aW9uICYmIGxvY2F0aW9uLmN1cnZlID09PSB0aGlzXG5cdFx0XHRcdD8gbG9jYXRpb24udGltZSA6IHRoaXMuZ2V0VGltZUF0KGxvY2F0aW9uKSk7XG5cdH0sXG5cblx0ZGl2aWRlQXRUaW1lOiBmdW5jdGlvbih0aW1lLCBfc2V0SGFuZGxlcykge1xuXHRcdHZhciB0TWluID0gMWUtOCxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKHRpbWUgPj0gdE1pbiAmJiB0aW1lIDw9IHRNYXgpIHtcblx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCB0aW1lKSxcblx0XHRcdFx0bGVmdCA9IHBhcnRzWzBdLFxuXHRcdFx0XHRyaWdodCA9IHBhcnRzWzFdLFxuXHRcdFx0XHRzZXRIYW5kbGVzID0gX3NldEhhbmRsZXMgfHwgdGhpcy5oYXNIYW5kbGVzKCksXG5cdFx0XHRcdHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcblx0XHRcdFx0c2VnMiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRcdGlmIChzZXRIYW5kbGVzKSB7XG5cdFx0XHRcdHNlZzEuX2hhbmRsZU91dC5fc2V0KGxlZnRbMl0gLSBsZWZ0WzBdLCBsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cdFx0XHRcdHNlZzIuX2hhbmRsZUluLl9zZXQocmlnaHRbNF0gLSByaWdodFs2XSxyaWdodFs1XSAtIHJpZ2h0WzddKTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gbGVmdFs2XSwgeSA9IGxlZnRbN10sXG5cdFx0XHRcdHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG5cdFx0XHRcdFx0XHRzZXRIYW5kbGVzICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLFxuXHRcdFx0XHRcdFx0c2V0SGFuZGxlcyAmJiBuZXcgUG9pbnQocmlnaHRbMl0gLSB4LCByaWdodFszXSAtIHkpKTtcblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdHBhdGguaW5zZXJ0KHNlZzEuX2luZGV4ICsgMSwgc2VnbWVudCk7XG5cdFx0XHRcdHJlcyA9IHRoaXMuZ2V0TmV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHRcdHJlcyA9IG5ldyBDdXJ2ZShzZWdtZW50LCBzZWcyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdEF0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRyZXR1cm4gcGF0aCA/IHBhdGguc3BsaXRBdChsb2NhdGlvbikgOiBudWxsO1xuXHR9LFxuXG5cdHNwbGl0QXRUaW1lOiBmdW5jdGlvbih0aW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3BsaXRBdCh0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRpbWUpKTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKG9mZnNldCwgaXNUaW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlQXRUaW1lKG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMC41IDogaXNUaW1lID8gb2Zmc2V0XG5cdFx0XHRcdDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNUaW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3BsaXRBdFRpbWUob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwLjUgOiBpc1RpbWUgPyBvZmZzZXRcblx0XHRcdFx0OiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcblx0fSxcblxuXHRyZXZlcnNlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50Mi5yZXZlcnNlZCgpLCB0aGlzLl9zZWdtZW50MS5yZXZlcnNlZCgpKTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuX3NldCgwLCAwKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uX3NldCgwLCAwKTtcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4LCBzdHJhaWdodCkge1xuXHRcdHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcblx0XHRcdGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcblx0XHRcdGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuXHRcdFx0cDIgPSBzZWdtZW50Mi5fcG9pbnQsXG5cdFx0XHR4MSA9IHAxLngsIHkxID0gcDEueSxcblx0XHRcdHgyID0gcDIueCwgeTIgPSBwMi55LFxuXHRcdFx0dmFsdWVzID0gc3RyYWlnaHRcblx0XHRcdFx0PyBbIHgxLCB5MSwgeDEsIHkxLCB4MiwgeTIsIHgyLCB5MiBdXG5cdFx0XHRcdDogW1xuXHRcdFx0XHRcdHgxLCB5MSxcblx0XHRcdFx0XHR4MSArIGgxLl94LCB5MSArIGgxLl95LFxuXHRcdFx0XHRcdHgyICsgaDIuX3gsIHkyICsgaDIuX3ksXG5cdFx0XHRcdFx0eDIsIHkyXG5cdFx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0c3ViZGl2aWRlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0eDEgPSB2WzJdLCB5MSA9IHZbM10sXG5cdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddO1xuXHRcdGlmICh0ID09PSB1bmRlZmluZWQpXG5cdFx0XHR0ID0gMC41O1xuXHRcdHZhciB1ID0gMSAtIHQsXG5cdFx0XHR4NCA9IHUgKiB4MCArIHQgKiB4MSwgeTQgPSB1ICogeTAgKyB0ICogeTEsXG5cdFx0XHR4NSA9IHUgKiB4MSArIHQgKiB4MiwgeTUgPSB1ICogeTEgKyB0ICogeTIsXG5cdFx0XHR4NiA9IHUgKiB4MiArIHQgKiB4MywgeTYgPSB1ICogeTIgKyB0ICogeTMsXG5cdFx0XHR4NyA9IHUgKiB4NCArIHQgKiB4NSwgeTcgPSB1ICogeTQgKyB0ICogeTUsXG5cdFx0XHR4OCA9IHUgKiB4NSArIHQgKiB4NiwgeTggPSB1ICogeTUgKyB0ICogeTYsXG5cdFx0XHR4OSA9IHUgKiB4NyArIHQgKiB4OCwgeTkgPSB1ICogeTcgKyB0ICogeTg7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFt4MCwgeTAsIHg0LCB5NCwgeDcsIHk3LCB4OSwgeTldLFxuXHRcdFx0W3g5LCB5OSwgeDgsIHk4LCB4NiwgeTYsIHgzLCB5M11cblx0XHRdO1xuXHR9LFxuXG5cdGdldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKHYsIGRpcikge1xuXHRcdHZhciBjdXJ2ZXMgPSBbXSxcblx0XHRcdGlvID0gZGlyID8gMCA6IDEsXG5cdFx0XHRvMCA9IHZbaW8gKyAwXSxcblx0XHRcdG8xID0gdltpbyArIDJdLFxuXHRcdFx0bzIgPSB2W2lvICsgNF0sXG5cdFx0XHRvMyA9IHZbaW8gKyA2XTtcblx0XHRpZiAoKG8wID49IG8xKSA9PT0gKG8xID49IG8yKSAmJiAobzEgPj0gbzIpID09PSAobzIgPj0gbzMpXG5cdFx0XHRcdHx8IEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdGN1cnZlcy5wdXNoKHYpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYSA9IDMgKiAobzEgLSBvMikgLSBvMCArIG8zLFxuXHRcdFx0XHRiID0gMiAqIChvMCArIG8yKSAtIDQgKiBvMSxcblx0XHRcdFx0YyA9IG8xIC0gbzAsXG5cdFx0XHRcdHRNaW4gPSAxZS04LFxuXHRcdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRcdG4gPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMsIHRNaW4sIHRNYXgpO1xuXHRcdFx0aWYgKCFuKSB7XG5cdFx0XHRcdGN1cnZlcy5wdXNoKHYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYsIHQpO1xuXHRcdFx0XHRjdXJ2ZXMucHVzaChwYXJ0c1swXSk7XG5cdFx0XHRcdGlmIChuID4gMSkge1xuXHRcdFx0XHRcdHQgPSAocm9vdHNbMV0gLSB0KSAvICgxIC0gdCk7XG5cdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUocGFydHNbMV0sIHQpO1xuXHRcdFx0XHRcdGN1cnZlcy5wdXNoKHBhcnRzWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJ2ZXMucHVzaChwYXJ0c1sxXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0c29sdmVDdWJpYzogZnVuY3Rpb24gKHYsIGNvb3JkLCB2YWwsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdHZhciB2MCA9IHZbY29vcmRdLFxuXHRcdFx0djEgPSB2W2Nvb3JkICsgMl0sXG5cdFx0XHR2MiA9IHZbY29vcmQgKyA0XSxcblx0XHRcdHYzID0gdltjb29yZCArIDZdLFxuXHRcdFx0cmVzID0gMDtcblx0XHRpZiAoICAhKHYwIDwgdmFsICYmIHYzIDwgdmFsICYmIHYxIDwgdmFsICYmIHYyIDwgdmFsIHx8XG5cdFx0XHRcdHYwID4gdmFsICYmIHYzID4gdmFsICYmIHYxID4gdmFsICYmIHYyID4gdmFsKSkge1xuXHRcdFx0dmFyIGMgPSAzICogKHYxIC0gdjApLFxuXHRcdFx0XHRiID0gMyAqICh2MiAtIHYxKSAtIGMsXG5cdFx0XHRcdGEgPSB2MyAtIHYwIC0gYyAtIGI7XG5cdFx0XHRyZXMgPSBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCB2MCAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRnZXRUaW1lT2Y6IGZ1bmN0aW9uKHYsIHBvaW50KSB7XG5cdFx0dmFyIHAwID0gbmV3IFBvaW50KHZbMF0sIHZbMV0pLFxuXHRcdFx0cDMgPSBuZXcgUG9pbnQodls2XSwgdls3XSksXG5cdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRnZW9tRXBzaWxvbiA9IDFlLTcsXG5cdFx0XHR0ID0gcG9pbnQuaXNDbG9zZShwMCwgZXBzaWxvbikgPyAwXG5cdFx0XHQgIDogcG9pbnQuaXNDbG9zZShwMywgZXBzaWxvbikgPyAxXG5cdFx0XHQgIDogbnVsbDtcblx0XHRpZiAodCA9PT0gbnVsbCkge1xuXHRcdFx0dmFyIGNvb3JkcyA9IFtwb2ludC54LCBwb2ludC55XSxcblx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYysrKSB7XG5cdFx0XHRcdHZhciBjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgYywgY29vcmRzW2NdLCByb290cywgMCwgMSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciB1ID0gcm9vdHNbaV07XG5cdFx0XHRcdFx0aWYgKHBvaW50LmlzQ2xvc2UoQ3VydmUuZ2V0UG9pbnQodiwgdSksIGdlb21FcHNpbG9uKSlcblx0XHRcdFx0XHRcdHJldHVybiB1O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0Nsb3NlKHAwLCBnZW9tRXBzaWxvbikgPyAwXG5cdFx0XHQgOiBwb2ludC5pc0Nsb3NlKHAzLCBnZW9tRXBzaWxvbikgPyAxXG5cdFx0XHQgOiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RUaW1lOiBmdW5jdGlvbih2LCBwb2ludCkge1xuXHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXHRcdFx0XHR2eCA9IHgzIC0geDAsIHZ5ID0geTMgLSB5MCxcblx0XHRcdFx0ZGV0ID0gdnggKiB2eCArIHZ5ICogdnk7XG5cdFx0XHRpZiAoZGV0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdHZhciB1ID0gKChwb2ludC54IC0geDApICogdnggKyAocG9pbnQueSAtIHkwKSAqIHZ5KSAvIGRldDtcblx0XHRcdHJldHVybiB1IDwgMWUtMTIgPyAwXG5cdFx0XHRcdCA6IHUgPiAwLjk5OTk5OTk5OTk5OSA/IDFcblx0XHRcdFx0IDogQ3VydmUuZ2V0VGltZU9mKHYsXG5cdFx0XHRcdFx0bmV3IFBvaW50KHgwICsgdSAqIHZ4LCB5MCArIHUgKiB2eSkpO1xuXHRcdH1cblxuXHRcdHZhciBjb3VudCA9IDEwMCxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pblQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVmaW5lKHQpIHtcblx0XHRcdGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG5cdFx0XHRcdHZhciBkaXN0ID0gcG9pbnQuZ2V0RGlzdGFuY2UoQ3VydmUuZ2V0UG9pbnQodiwgdCksIHRydWUpO1xuXHRcdFx0XHRpZiAoZGlzdCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRtaW5UID0gdDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspXG5cdFx0XHRyZWZpbmUoaSAvIGNvdW50KTtcblxuXHRcdHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXHRcdHdoaWxlIChzdGVwID4gMWUtOCkge1xuXHRcdFx0aWYgKCFyZWZpbmUobWluVCAtIHN0ZXApICYmICFyZWZpbmUobWluVCArIHN0ZXApKVxuXHRcdFx0XHRzdGVwIC89IDI7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5UO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG5cdFx0dmFyIGZsaXAgPSBmcm9tID4gdG87XG5cdFx0aWYgKGZsaXApIHtcblx0XHRcdHZhciB0bXAgPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IHRvO1xuXHRcdFx0dG8gPSB0bXA7XG5cdFx0fVxuXHRcdGlmIChmcm9tID4gMClcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgZnJvbSlbMV07XG5cdFx0aWYgKHRvIDwgMSlcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgKHRvIC0gZnJvbSkgLyAoMSAtIGZyb20pKVswXTtcblx0XHRyZXR1cm4gZmxpcFxuXHRcdFx0XHQ/IFt2WzZdLCB2WzddLCB2WzRdLCB2WzVdLCB2WzJdLCB2WzNdLCB2WzBdLCB2WzFdXVxuXHRcdFx0XHQ6IHY7XG5cdH0sXG5cblx0aXNGbGF0RW5vdWdoOiBmdW5jdGlvbih2LCBmbGF0bmVzcykge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XSxcblx0XHRcdHV4ID0gMyAqIHgxIC0gMiAqIHgwIC0geDMsXG5cdFx0XHR1eSA9IDMgKiB5MSAtIDIgKiB5MCAtIHkzLFxuXHRcdFx0dnggPSAzICogeDIgLSAyICogeDMgLSB4MCxcblx0XHRcdHZ5ID0gMyAqIHkyIC0gMiAqIHkzIC0geTA7XG5cdFx0cmV0dXJuIE1hdGgubWF4KHV4ICogdXgsIHZ4ICogdngpICsgTWF0aC5tYXgodXkgKiB1eSwgdnkgKiB2eSlcblx0XHRcdFx0PD0gMTYgKiBmbGF0bmVzcyAqIGZsYXRuZXNzO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN107XG5cdFx0cmV0dXJuIDMgKiAoKHkzIC0geTApICogKHgxICsgeDIpIC0gKHgzIC0geDApICogKHkxICsgeTIpXG5cdFx0XHRcdCsgeTEgKiAoeDAgLSB4MikgLSB4MSAqICh5MCAtIHkyKVxuXHRcdFx0XHQrIHkzICogKHgyICsgeDAgLyAzKSAtIHgzICogKHkyICsgeTAgLyAzKSkgLyAyMDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgbWluID0gdi5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBbMCwgMF07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspXG5cdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKHZbaV0sIHZbaSArIDJdLCB2W2kgKyA0XSwgdltpICsgNl0sXG5cdFx0XHRcdFx0aSwgMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdF9hZGRCb3VuZHM6IGZ1bmN0aW9uKHYwLCB2MSwgdjIsIHYzLCBjb29yZCwgcGFkZGluZywgbWluLCBtYXgsIHJvb3RzKSB7XG5cdFx0ZnVuY3Rpb24gYWRkKHZhbHVlLCBwYWRkaW5nKSB7XG5cdFx0XHR2YXIgbGVmdCA9IHZhbHVlIC0gcGFkZGluZyxcblx0XHRcdFx0cmlnaHQgPSB2YWx1ZSArIHBhZGRpbmc7XG5cdFx0XHRpZiAobGVmdCA8IG1pbltjb29yZF0pXG5cdFx0XHRcdG1pbltjb29yZF0gPSBsZWZ0O1xuXHRcdFx0aWYgKHJpZ2h0ID4gbWF4W2Nvb3JkXSlcblx0XHRcdFx0bWF4W2Nvb3JkXSA9IHJpZ2h0O1xuXHRcdH1cblxuXHRcdHBhZGRpbmcgLz0gMjtcblx0XHR2YXIgbWluUGFkID0gbWluW2Nvb3JkXSAtIHBhZGRpbmcsXG5cdFx0XHRtYXhQYWQgPSBtYXhbY29vcmRdICsgcGFkZGluZztcblx0XHRpZiAoICAgIHYwIDwgbWluUGFkIHx8IHYxIDwgbWluUGFkIHx8IHYyIDwgbWluUGFkIHx8IHYzIDwgbWluUGFkIHx8XG5cdFx0XHRcdHYwID4gbWF4UGFkIHx8IHYxID4gbWF4UGFkIHx8IHYyID4gbWF4UGFkIHx8IHYzID4gbWF4UGFkKSB7XG5cdFx0XHRpZiAodjEgPCB2MCAhPSB2MSA8IHYzICYmIHYyIDwgdjAgIT0gdjIgPCB2Mykge1xuXHRcdFx0XHRhZGQodjAsIHBhZGRpbmcpO1xuXHRcdFx0XHRhZGQodjMsIHBhZGRpbmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdFx0XHRiID0gMiAqICh2MCArIHYyKSAtIDQgKiB2MSxcblx0XHRcdFx0XHRjID0gdjEgLSB2MCxcblx0XHRcdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdFx0XHRhZGQodjMsIDApO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzW2ldLFxuXHRcdFx0XHRcdFx0dSA9IDEgLSB0O1xuXHRcdFx0XHRcdGlmICh0TWluIDw9IHQgJiYgdCA8PSB0TWF4KVxuXHRcdFx0XHRcdFx0YWRkKHUgKiB1ICogdSAqIHYwXG5cdFx0XHRcdFx0XHRcdCsgMyAqIHUgKiB1ICogdCAqIHYxXG5cdFx0XHRcdFx0XHRcdCsgMyAqIHUgKiB0ICogdCAqIHYyXG5cdFx0XHRcdFx0XHRcdCsgdCAqIHQgKiB0ICogdjMsXG5cdFx0XHRcdFx0XHRcdHBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59fSwgQmFzZS5lYWNoKFxuXHRbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShcblx0XHRcdFx0XHRcdFt0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDJdLCBmYWxzZSwgdGhpcy5fcGF0aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm91bmRzLmNsb25lKCk7XG5cdFx0fTtcblx0fSxcbntcblxufSksIEJhc2UuZWFjaCh7XG5cdGlzU3RyYWlnaHQ6IGZ1bmN0aW9uKHAxLCBoMSwgaDIsIHAyKSB7XG5cdFx0aWYgKGgxLmlzWmVybygpICYmIGgyLmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHYgPSBwMi5zdWJ0cmFjdChwMSk7XG5cdFx0XHRpZiAodi5pc1plcm8oKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKHYuaXNDb2xsaW5lYXIoaDEpICYmIHYuaXNDb2xsaW5lYXIoaDIpKSB7XG5cdFx0XHRcdHZhciBsID0gbmV3IExpbmUocDEsIHAyKSxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtNztcblx0XHRcdFx0aWYgKGwuZ2V0RGlzdGFuY2UocDEuYWRkKGgxKSkgPCBlcHNpbG9uICYmXG5cdFx0XHRcdFx0bC5nZXREaXN0YW5jZShwMi5hZGQoaDIpKSA8IGVwc2lsb24pIHtcblx0XHRcdFx0XHR2YXIgZGl2ID0gdi5kb3QodiksXG5cdFx0XHRcdFx0XHRzMSA9IHYuZG90KGgxKSAvIGRpdixcblx0XHRcdFx0XHRcdHMyID0gdi5kb3QoaDIpIC8gZGl2O1xuXHRcdFx0XHRcdHJldHVybiBzMSA+PSAwICYmIHMxIDw9IDEgJiYgczIgPD0gMCAmJiBzMiA+PSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKHAxLCBoMSwgaDIsIHAyKSB7XG5cdFx0dmFyIHRoaXJkID0gcDIuc3VidHJhY3QocDEpLmRpdmlkZSgzKTtcblx0XHRyZXR1cm4gaDEuZXF1YWxzKHRoaXJkKSAmJiBoMi5uZWdhdGUoKS5lcXVhbHModGhpcmQpO1xuXHR9XG59LCBmdW5jdGlvbih0ZXN0LCBuYW1lKSB7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihlcHNpbG9uKSB7XG5cdFx0dmFyIHNlZzEgPSB0aGlzLl9zZWdtZW50MSxcblx0XHRcdHNlZzIgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRyZXR1cm4gdGVzdChzZWcxLl9wb2ludCwgc2VnMS5faGFuZGxlT3V0LCBzZWcyLl9oYW5kbGVJbiwgc2VnMi5fcG9pbnQsXG5cdFx0XHRcdGVwc2lsb24pO1xuXHR9O1xuXG5cdHRoaXMuc3RhdGljc1tuYW1lXSA9IGZ1bmN0aW9uKHYsIGVwc2lsb24pIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XTtcblx0XHRyZXR1cm4gdGVzdChcblx0XHRcdFx0bmV3IFBvaW50KHgwLCB5MCksXG5cdFx0XHRcdG5ldyBQb2ludCh2WzJdIC0geDAsIHZbM10gLSB5MCksXG5cdFx0XHRcdG5ldyBQb2ludCh2WzRdIC0geDMsIHZbNV0gLSB5MyksXG5cdFx0XHRcdG5ldyBQb2ludCh4MywgeTMpLCBlcHNpbG9uKTtcblx0fTtcbn0sIHtcblx0c3RhdGljczoge30sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdHx8ICF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCk7XG5cdH0sXG5cblx0aGFzTGVuZ3RoOiBmdW5jdGlvbihlcHNpbG9uKSB7XG5cdFx0cmV0dXJuICghdGhpcy5nZXRQb2ludDEoKS5lcXVhbHModGhpcy5nZXRQb2ludDIoKSkgfHwgdGhpcy5oYXNIYW5kbGVzKCkpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0TGVuZ3RoKCkgPiAoZXBzaWxvbiB8fCAwKTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRyZXR1cm4gY3VydmUgJiYgdGhpcy5pc1N0cmFpZ2h0KCkgJiYgY3VydmUuaXNTdHJhaWdodCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0TGluZSgpLmlzQ29sbGluZWFyKGN1cnZlLmdldExpbmUoKSk7XG5cdH0sXG5cblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1N0cmFpZ2h0KCkgJiYgTWF0aC5hYnModGhpcy5nZXRUYW5nZW50QXRUaW1lKDAuNSkueSlcblx0XHRcdFx0PCAxZS04O1xuXHR9LFxuXG5cdGlzVmVydGljYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdFRpbWUoMC41KS54KVxuXHRcdFx0XHQ8IDFlLTg7XG5cdH1cbn0pLCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIF9pc1RpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0VGltZShcblx0XHRcdFx0X2lzVGltZSA/IG9mZnNldCA6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXRUaW1lOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgIT0gbnVsbCAmJiB0ID49IDAgJiYgdCA8PSAxXG5cdFx0XHRcdD8gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgdClcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldFRpbWVBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRUaW1lQXQodGhpcy5nZXRWYWx1ZXMoKSwgb2Zmc2V0LCBzdGFydCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyQXQ6ICcjZ2V0VGltZUF0JyxcblxuXHRnZXRPZmZzZXRBdFRpbWU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQYXJ0TGVuZ3RoKDAsIHQpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRoaXMuZ2V0VGltZU9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0VGltZU9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VGltZU9mKHRoaXMuZ2V0VmFsdWVzKCksIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6ICcjZ2V0VGltZU9mJyxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHR0ID0gQ3VydmUuZ2V0TmVhcmVzdFRpbWUodmFsdWVzLCBwb2ludCksXG5cdFx0XHRwdCA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCk7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQsIHB0LCBudWxsLCBwb2ludC5nZXREaXN0YW5jZShwdCkpO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRQb2ludCgpIDogbG9jO1xuXHR9XG5cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtZXRob2RzID0gWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRXZWlnaHRlZFRhbmdlbnQnLFxuXHRcdCdnZXRXZWlnaHRlZE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXTtcblx0cmV0dXJuIEJhc2UuZWFjaChtZXRob2RzLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24obG9jYXRpb24sIF9pc1RpbWUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cdFx0XHRcdHJldHVybiBDdXJ2ZVtuYW1lXSh2YWx1ZXMsIF9pc1RpbWUgPyBsb2NhdGlvblxuXHRcdFx0XHRcdFx0OiBDdXJ2ZS5nZXRUaW1lQXQodmFsdWVzLCBsb2NhdGlvbikpO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1tuYW1lICsgJ0F0VGltZSddID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5nZXRWYWx1ZXMoKSwgdGltZSk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdHN0YXRpY3M6IHtcblx0XHRcdFx0X2V2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqICh4MSAtIHgyKSArIDMgKiAoeDMgLSB4MCksXG5cdFx0XHRieCA9IDYgKiAoeDAgKyB4MikgLSAxMiAqIHgxLFxuXHRcdFx0Y3ggPSAzICogKHgxIC0geDApLFxuXG5cdFx0XHRheSA9IDkgKiAoeTEgLSB5MikgKyAzICogKHkzIC0geTApLFxuXHRcdFx0YnkgPSA2ICogKHkwICsgeTIpIC0gMTIgKiB5MSxcblx0XHRcdGN5ID0gMyAqICh5MSAtIHkwKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmFsdWF0ZSh2LCB0LCB0eXBlLCBub3JtYWxpemVkKSB7XG5cdFx0aWYgKHQgPT0gbnVsbCB8fCB0IDwgMCB8fCB0ID4gMSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XSxcblx0XHRcdGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0aWYgKGlzWmVybyh4MSAtIHgwKSAmJiBpc1plcm8oeTEgLSB5MCkpIHtcblx0XHRcdHgxID0geDA7XG5cdFx0XHR5MSA9IHkwO1xuXHRcdH1cblx0XHRpZiAoaXNaZXJvKHgyIC0geDMpICYmIGlzWmVybyh5MiAtIHkzKSkge1xuXHRcdFx0eDIgPSB4Mztcblx0XHRcdHkyID0geTM7XG5cdFx0fVxuXHRcdHZhciBjeCA9IDMgKiAoeDEgLSB4MCksXG5cdFx0XHRieCA9IDMgKiAoeDIgLSB4MSkgLSBjeCxcblx0XHRcdGF4ID0geDMgLSB4MCAtIGN4IC0gYngsXG5cdFx0XHRjeSA9IDMgKiAoeTEgLSB5MCksXG5cdFx0XHRieSA9IDMgKiAoeTIgLSB5MSkgLSBjeSxcblx0XHRcdGF5ID0geTMgLSB5MCAtIGN5IC0gYnksXG5cdFx0XHR4LCB5O1xuXHRcdGlmICh0eXBlID09PSAwKSB7XG5cdFx0XHR4ID0gdCA9PT0gMCA/IHgwIDogdCA9PT0gMSA/IHgzXG5cdFx0XHRcdFx0OiAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0ICsgeDA7XG5cdFx0XHR5ID0gdCA9PT0gMCA/IHkwIDogdCA9PT0gMSA/IHkzXG5cdFx0XHRcdFx0OiAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgeTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0TWluID0gMWUtOCxcblx0XHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdFx0aWYgKHQgPCB0TWluKSB7XG5cdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0eSA9IGN5O1xuXHRcdFx0fSBlbHNlIGlmICh0ID4gdE1heCkge1xuXHRcdFx0XHR4ID0gMyAqICh4MyAtIHgyKTtcblx0XHRcdFx0eSA9IDMgKiAoeTMgLSB5Mik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gKDMgKiBheCAqIHQgKyAyICogYngpICogdCArIGN4O1xuXHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5vcm1hbGl6ZWQpIHtcblx0XHRcdFx0aWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiAodCA8IHRNaW4gfHwgdCA+IHRNYXgpKSB7XG5cdFx0XHRcdFx0eCA9IHgyIC0geDE7XG5cdFx0XHRcdFx0eSA9IHkyIC0geTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0aWYgKGxlbikge1xuXHRcdFx0XHRcdHggLz0gbGVuO1xuXHRcdFx0XHRcdHkgLz0gbGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHR2YXIgeDIgPSA2ICogYXggKiB0ICsgMiAqIGJ4LFxuXHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcblx0XHRcdFx0XHRkID0gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuXHRcdFx0XHR4ID0gZCAhPT0gMCA/ICh4ICogeTIgLSB5ICogeDIpIC8gZCA6IDA7XG5cdFx0XHRcdHkgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cblx0XHRjbGFzc2lmeTogZnVuY3Rpb24odikge1xuXG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdGExID0geDAgKiAoeTMgLSB5MikgKyB5MCAqICh4MiAtIHgzKSArIHgzICogeTIgLSB5MyAqIHgyLFxuXHRcdFx0XHRhMiA9IHgxICogKHkwIC0geTMpICsgeTEgKiAoeDMgLSB4MCkgKyB4MCAqIHkzIC0geTAgKiB4Myxcblx0XHRcdFx0YTMgPSB4MiAqICh5MSAtIHkwKSArIHkyICogKHgwIC0geDEpICsgeDEgKiB5MCAtIHkxICogeDAsXG5cdFx0XHRcdGQzID0gMyAqIGEzLFxuXHRcdFx0XHRkMiA9IGQzIC0gYTIsXG5cdFx0XHRcdGQxID0gZDIgLSBhMiArIGExLFxuXHRcdFx0XHRsID0gTWF0aC5zcXJ0KGQxICogZDEgKyBkMiAqIGQyICsgZDMgKiBkMyksXG5cdFx0XHRcdHMgPSBsICE9PSAwID8gMSAvIGwgOiAwLFxuXHRcdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvLFxuXHRcdFx0XHRzZXJwZW50aW5lID0gJ3NlcnBlbnRpbmUnO1xuXHRcdFx0ZDEgKj0gcztcblx0XHRcdGQyICo9IHM7XG5cdFx0XHRkMyAqPSBzO1xuXG5cdFx0XHRmdW5jdGlvbiB0eXBlKHR5cGUsIHQxLCB0Mikge1xuXHRcdFx0XHR2YXIgaGFzUm9vdHMgPSB0MSAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHQxT2sgPSBoYXNSb290cyAmJiB0MSA+IDAgJiYgdDEgPCAxLFxuXHRcdFx0XHRcdHQyT2sgPSBoYXNSb290cyAmJiB0MiA+IDAgJiYgdDIgPCAxO1xuXHRcdFx0XHRpZiAoaGFzUm9vdHMgJiYgKCEodDFPayB8fCB0Mk9rKVxuXHRcdFx0XHRcdFx0fHwgdHlwZSA9PT0gJ2xvb3AnICYmICEodDFPayAmJiB0Mk9rKSkpIHtcblx0XHRcdFx0XHR0eXBlID0gJ2FyY2gnO1xuXHRcdFx0XHRcdHQxT2sgPSB0Mk9rID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdHJvb3RzOiB0MU9rIHx8IHQyT2tcblx0XHRcdFx0XHRcdFx0PyB0MU9rICYmIHQyT2tcblx0XHRcdFx0XHRcdFx0XHQ/IHQxIDwgdDIgPyBbdDEsIHQyXSA6IFt0MiwgdDFdXG5cdFx0XHRcdFx0XHRcdFx0OiBbdDFPayA/IHQxIDogdDJdXG5cdFx0XHRcdFx0XHRcdDogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNaZXJvKGQxKSkge1xuXHRcdFx0XHRyZXR1cm4gaXNaZXJvKGQyKVxuXHRcdFx0XHRcdFx0PyB0eXBlKGlzWmVybyhkMykgPyAnbGluZScgOiAncXVhZHJhdGljJylcblx0XHRcdFx0XHRcdDogdHlwZShzZXJwZW50aW5lLCBkMyAvICgzICogZDIpKTtcblx0XHRcdH1cblx0XHRcdHZhciBkID0gMyAqIGQyICogZDIgLSA0ICogZDEgKiBkMztcblx0XHRcdGlmIChpc1plcm8oZCkpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGUoJ2N1c3AnLCBkMiAvICgyICogZDEpKTtcblx0XHRcdH1cblx0XHRcdHZhciBmMSA9IGQgPiAwID8gTWF0aC5zcXJ0KGQgLyAzKSA6IE1hdGguc3FydCgtZCksXG5cdFx0XHRcdGYyID0gMiAqIGQxO1xuXHRcdFx0cmV0dXJuIHR5cGUoZCA+IDAgPyBzZXJwZW50aW5lIDogJ2xvb3AnLFxuXHRcdFx0XHRcdChkMiArIGYxKSAvIGYyLFxuXHRcdFx0XHRcdChkMiAtIGYxKSAvIGYyKTtcblx0XHR9LFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbih2LCBhLCBiLCBkcykge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHRcdHZhciBjID0gdjtcblx0XHRcdFx0aWYgKGIgPCAxKSB7XG5cdFx0XHRcdFx0YyA9IEN1cnZlLnN1YmRpdmlkZShjLCBiKVswXTtcblx0XHRcdFx0XHRhIC89IGI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEgPiAwKSB7XG5cdFx0XHRcdFx0YyA9IEN1cnZlLnN1YmRpdmlkZShjLCBhKVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZHggPSBjWzZdIC0gY1swXSxcblx0XHRcdFx0XHRkeSA9IGNbN10gLSBjWzFdO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzIHx8IGdldExlbmd0aEludGVncmFuZCh2KSwgYSwgYixcblx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGltZUF0OiBmdW5jdGlvbih2LCBvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDA7XG5cdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gc3RhcnQ7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdFx0Zm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHYsIGEsIGIsIGRzKSxcblx0XHRcdFx0ZGlmZiA9IGFicyhvZmZzZXQpIC0gcmFuZ2VMZW5ndGg7XG5cdFx0XHRpZiAoYWJzKGRpZmYpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRyZXR1cm4gZm9yd2FyZCA/IGIgOiBhO1xuXHRcdFx0fSBlbHNlIGlmIChkaWZmID4gZXBzaWxvbikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMzIsXG5cdFx0XHRcdFx0MWUtMTIpO1xuXHRcdH0sXG5cblx0XHRnZXRQb2ludDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDAsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0Q3VydmF0dXJlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMywgZmFsc2UpLng7XG5cdFx0fSxcblxuXHRcdGdldFBlYWtzOiBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdGF4ID0gICAgIC14MCArIDMgKiB4MSAtIDMgKiB4MiArIHgzLFxuXHRcdFx0XHRieCA9ICAzICogeDAgLSA2ICogeDEgKyAzICogeDIsXG5cdFx0XHRcdGN4ID0gLTMgKiB4MCArIDMgKiB4MSxcblx0XHRcdFx0YXkgPSAgICAgLXkwICsgMyAqIHkxIC0gMyAqIHkyICsgeTMsXG5cdFx0XHRcdGJ5ID0gIDMgKiB5MCAtIDYgKiB5MSArIDMgKiB5Mixcblx0XHRcdFx0Y3kgPSAtMyAqIHkwICsgMyAqIHkxLFxuXHRcdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0TnVtZXJpY2FsLnNvbHZlQ3ViaWMoXG5cdFx0XHRcdFx0OSAqIChheCAqIGF4ICsgYXkgKiBheSksXG5cdFx0XHRcdFx0OSAqIChheCAqIGJ4ICsgYnkgKiBheSksXG5cdFx0XHRcdFx0MiAqIChieCAqIGJ4ICsgYnkgKiBieSkgKyAzICogKGN4ICogYXggKyBjeSAqIGF5KSxcblx0XHRcdFx0XHQoY3ggKiBieCArIGJ5ICogY3kpLFxuXHRcdFx0XHRcdHJvb3RzLCB0TWluLCB0TWF4KTtcblx0XHRcdHJldHVybiByb290cy5zb3J0KCk7XG5cdFx0fVxuXHR9fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgdDEsIGMyLCB0Miwgb3ZlcmxhcCkge1xuXHRcdHZhciBleGNsdWRlU3RhcnQgPSAhb3ZlcmxhcCAmJiBjMS5nZXRQcmV2aW91cygpID09PSBjMixcblx0XHRcdGV4Y2x1ZGVFbmQgPSAhb3ZlcmxhcCAmJiBjMSAhPT0gYzIgJiYgYzEuZ2V0TmV4dCgpID09PSBjMixcblx0XHRcdHRNaW4gPSAxZS04LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmICh0MSAhPT0gbnVsbCAmJiB0MSA+PSAoZXhjbHVkZVN0YXJ0ID8gdE1pbiA6IDApICYmXG5cdFx0XHR0MSA8PSAoZXhjbHVkZUVuZCA/IHRNYXggOiAxKSkge1xuXHRcdFx0aWYgKHQyICE9PSBudWxsICYmIHQyID49IChleGNsdWRlRW5kID8gdE1pbiA6IDApICYmXG5cdFx0XHRcdHQyIDw9IChleGNsdWRlU3RhcnQgPyB0TWF4IDogMSkpIHtcblx0XHRcdFx0dmFyIGxvYzEgPSBuZXcgQ3VydmVMb2NhdGlvbihjMSwgdDEsIG51bGwsIG92ZXJsYXApLFxuXHRcdFx0XHRcdGxvYzIgPSBuZXcgQ3VydmVMb2NhdGlvbihjMiwgdDIsIG51bGwsIG92ZXJsYXApO1xuXHRcdFx0XHRsb2MxLl9pbnRlcnNlY3Rpb24gPSBsb2MyO1xuXHRcdFx0XHRsb2MyLl9pbnRlcnNlY3Rpb24gPSBsb2MxO1xuXHRcdFx0XHRpZiAoIWluY2x1ZGUgfHwgaW5jbHVkZShsb2MxKSkge1xuXHRcdFx0XHRcdEN1cnZlTG9jYXRpb24uaW5zZXJ0KGxvY2F0aW9ucywgbG9jMSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgpIHtcblx0XHRpZiAoKytjYWxscyA+PSA0MDk2IHx8ICsrcmVjdXJzaW9uID49IDQwKVxuXHRcdFx0cmV0dXJuIGNhbGxzO1xuXHRcdHZhciBmYXRMaW5lRXBzaWxvbiA9IDFlLTksXG5cdFx0XHRxMHggPSB2MlswXSwgcTB5ID0gdjJbMV0sIHEzeCA9IHYyWzZdLCBxM3kgPSB2Mls3XSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSksXG5cdFx0XHRmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG5cdFx0XHRkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcblx0XHRcdGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuXHRcdFx0ZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuXHRcdFx0ZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuXHRcdFx0ZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuXHRcdFx0ZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuXHRcdFx0aHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcblx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRib3R0b20gPSBodWxsWzFdLFxuXHRcdFx0dE1pbkNsaXAsXG5cdFx0XHR0TWF4Q2xpcDtcblx0XHRpZiAoZDEgPT09IDAgJiYgZDIgPT09IDBcblx0XHRcdFx0JiYgZHAwID09PSAwICYmIGRwMSA9PT0gMCAmJiBkcDIgPT09IDAgJiYgZHAzID09PSAwXG5cdFx0XHR8fCAodE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCkpID09IG51bGxcblx0XHRcdHx8ICh0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcC5yZXZlcnNlKCksIGJvdHRvbS5yZXZlcnNlKCksXG5cdFx0XHRcdGRNaW4sIGRNYXgpKSA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGNhbGxzO1xuXHRcdHZhciB0TWluTmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWluQ2xpcCxcblx0XHRcdHRNYXhOZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNYXhDbGlwO1xuXHRcdGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpIDwgZmF0TGluZUVwc2lsb24pIHtcblx0XHRcdHZhciB0ID0gKHRNaW5OZXcgKyB0TWF4TmV3KSAvIDIsXG5cdFx0XHRcdHUgPSAodU1pbiArIHVNYXgpIC8gMjtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRmbGlwID8gYzIgOiBjMSwgZmxpcCA/IHUgOiB0LFxuXHRcdFx0XHRcdGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdCA6IHUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2MSA9IEN1cnZlLmdldFBhcnQodjEsIHRNaW5DbGlwLCB0TWF4Q2xpcCk7XG5cdFx0XHRpZiAodE1heENsaXAgLSB0TWluQ2xpcCA+IDAuOCkge1xuXHRcdFx0XHRpZiAodE1heE5ldyAtIHRNaW5OZXcgPiB1TWF4IC0gdU1pbikge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHRcdHQgPSAodE1pbk5ldyArIHRNYXhOZXcpIC8gMjtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQpO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHR2MiwgcGFydHNbMV0sIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdCwgdE1heE5ldyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuXHRcdFx0XHRcdFx0dSA9ICh1TWluICsgdU1heCkgLyAyO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHRwYXJ0c1swXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdSwgdE1pbk5ldywgdE1heE5ldyk7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHBhcnRzWzFdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1LCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHVNYXggLSB1TWluID49IGZhdExpbmVFcHNpbG9uKSB7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHYyLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdE1pbk5ldywgdE1heE5ldywgdU1pbiwgdU1heCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbGxzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRkaXN0MSA9IGRxMSAtICgyICogZHEwICsgZHEzKSAvIDMsXG5cdFx0XHRkaXN0MiA9IGRxMiAtIChkcTAgKyAyICogZHEzKSAvIDMsXG5cdFx0XHRodWxsO1xuXHRcdGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuXHRcdFx0aHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXN0UmF0aW8gPSBkaXN0MSAvIGRpc3QyO1xuXHRcdFx0aHVsbCA9IFtcblx0XHRcdFx0ZGlzdFJhdGlvID49IDIgPyBbcDAsIHAxLCBwM11cblx0XHRcdFx0OiBkaXN0UmF0aW8gPD0gMC41ID8gW3AwLCBwMiwgcDNdXG5cdFx0XHRcdDogW3AwLCBwMSwgcDIsIHAzXSxcblx0XHRcdFx0W3AwLCBwM11cblx0XHRcdF07XG5cdFx0fVxuXHRcdHJldHVybiAoZGlzdDEgfHwgZGlzdDIpIDwgMCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8IGRNaW4pIHtcblx0XHRcdHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbFRvcCwgdHJ1ZSwgZE1pbik7XG5cdFx0fSBlbHNlIGlmIChodWxsQm90dG9tWzBdWzFdID4gZE1heCkge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsQm90dG9tLCBmYWxzZSwgZE1heCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBodWxsVG9wWzBdWzBdO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsUGFydChwYXJ0LCB0b3AsIHRocmVzaG9sZCkge1xuXHRcdHZhciBweCA9IHBhcnRbMF1bMF0sXG5cdFx0XHRweSA9IHBhcnRbMF1bMV07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBwYXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHF4ID0gcGFydFtpXVswXSxcblx0XHRcdFx0cXkgPSBwYXJ0W2ldWzFdO1xuXHRcdFx0aWYgKHRvcCA/IHF5ID49IHRocmVzaG9sZCA6IHF5IDw9IHRocmVzaG9sZCkge1xuXHRcdFx0XHRyZXR1cm4gcXkgPT09IHRocmVzaG9sZCA/IHF4XG5cdFx0XHRcdFx0XHQ6IHB4ICsgKHRocmVzaG9sZCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdH1cblx0XHRcdHB4ID0gcXg7XG5cdFx0XHRweSA9IHF5O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEN1cnZlTGluZUludGVyc2VjdGlvbnModiwgcHgsIHB5LCB2eCwgdnkpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRpZiAoaXNaZXJvKHZ4KSAmJiBpc1plcm8odnkpKSB7XG5cdFx0XHR2YXIgdCA9IEN1cnZlLmdldFRpbWVPZih2LCBuZXcgUG9pbnQocHgsIHB5KSk7XG5cdFx0XHRyZXR1cm4gdCA9PT0gbnVsbCA/IFtdIDogW3RdO1xuXHRcdH1cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKC12eSwgdngpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cnYgPSBbXSxcblx0XHRcdHJvb3RzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdltpXSAtIHB4LFxuXHRcdFx0XHR5ID0gdltpICsgMV0gLSBweTtcblx0XHRcdHJ2LnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR4ICogc2luICsgeSAqIGNvcyk7XG5cdFx0fVxuXHRcdEN1cnZlLnNvbHZlQ3ViaWMocnYsIDEsIDAsIHJvb3RzLCAwLCAxKTtcblx0XHRyZXR1cm4gcm9vdHM7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRmbGlwKSB7XG5cdFx0dmFyIHgxID0gdjJbMF0sIHkxID0gdjJbMV0sXG5cdFx0XHR4MiA9IHYyWzZdLCB5MiA9IHYyWzddLFxuXHRcdFx0cm9vdHMgPSBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdDEgPSByb290c1tpXSxcblx0XHRcdFx0cDEgPSBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLFxuXHRcdFx0XHR0MiA9IEN1cnZlLmdldFRpbWVPZih2MiwgcDEpO1xuXHRcdFx0aWYgKHQyICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGZsaXAgPyBjMiA6IGMxLCBmbGlwID8gdDIgOiB0MSxcblx0XHRcdFx0XHRcdGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdDEgOiB0Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIHB0ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHB0KSB7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0YzEsIEN1cnZlLmdldFRpbWVPZih2MSwgcHQpLFxuXHRcdFx0XHRcdGMyLCBDdXJ2ZS5nZXRUaW1lT2YodjIsIHB0KSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0bWluID0gTWF0aC5taW4sXG5cdFx0XHRtYXggPSBNYXRoLm1heDtcblxuXHRcdGlmIChtYXgodjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pICsgZXBzaWxvbiA+XG5cdFx0XHRtaW4odjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmXG5cdFx0XHRtaW4odjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pIC0gZXBzaWxvbiA8XG5cdFx0XHRtYXgodjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmXG5cdFx0XHRtYXgodjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pICsgZXBzaWxvbiA+XG5cdFx0XHRtaW4odjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pICYmXG5cdFx0XHRtaW4odjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pIC0gZXBzaWxvbiA8XG5cdFx0XHRtYXgodjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pKSB7XG5cdFx0XHR2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRcdGMxLCBvdmVybGFwWzBdLFxuXHRcdFx0XHRcdFx0XHRjMiwgb3ZlcmxhcFsxXSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdFx0XHRzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcblx0XHRcdFx0XHRzdHJhaWdodCA9IHN0cmFpZ2h0MSAmJiBzdHJhaWdodDIsXG5cdFx0XHRcdFx0ZmxpcCA9IHN0cmFpZ2h0MSAmJiAhc3RyYWlnaHQyLFxuXHRcdFx0XHRcdGJlZm9yZSA9IGxvY2F0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdChzdHJhaWdodFxuXHRcdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHRcdDogc3RyYWlnaHQxIHx8IHN0cmFpZ2h0MlxuXHRcdFx0XHRcdFx0PyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0XHQ6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoXG5cdFx0XHRcdFx0XHRcdGZsaXAgPyB2MiA6IHYxLCBmbGlwID8gdjEgOiB2Mixcblx0XHRcdFx0XHRcdFx0ZmxpcCA/IGMyIDogYzEsIGZsaXAgPyBjMSA6IGMyLFxuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsXG5cdFx0XHRcdFx0XHRcdDAsIDAsIDAsIDEsIDAsIDEpO1xuXHRcdFx0XHRpZiAoIXN0cmFpZ2h0IHx8IGxvY2F0aW9ucy5sZW5ndGggPT09IGJlZm9yZSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdDEgPSBpID4+IDEsXG5cdFx0XHRcdFx0XHRcdHQyID0gaSAmIDEsXG5cdFx0XHRcdFx0XHRcdGkxID0gdDEgKiA2LFxuXHRcdFx0XHRcdFx0XHRpMiA9IHQyICogNixcblx0XHRcdFx0XHRcdFx0cDEgPSBuZXcgUG9pbnQodjFbaTFdLCB2MVtpMSArIDFdKSxcblx0XHRcdFx0XHRcdFx0cDIgPSBuZXcgUG9pbnQodjJbaTJdLCB2MltpMiArIDFdKTtcblx0XHRcdFx0XHRcdGlmIChwMS5pc0Nsb3NlKHAyLCBlcHNpbG9uKSkge1xuXHRcdFx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjMSwgdDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRjMiwgdDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TG9vcEludGVyc2VjdGlvbih2MSwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBpbmZvID0gQ3VydmUuY2xhc3NpZnkodjEpO1xuXHRcdGlmIChpbmZvLnR5cGUgPT09ICdsb29wJykge1xuXHRcdFx0dmFyIHJvb3RzID0gaW5mby5yb290cztcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjMSwgcm9vdHNbMF0sXG5cdFx0XHRcdFx0YzEsIHJvb3RzWzFdKTtcblx0XHR9XG5cdCAgcmV0dXJuIGxvY2F0aW9ucztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMoY3VydmVzMSwgY3VydmVzMiwgaW5jbHVkZSwgbWF0cml4MSwgbWF0cml4Mixcblx0XHRcdF9yZXR1cm5GaXJzdCkge1xuXHRcdHZhciBzZWxmID0gIWN1cnZlczI7XG5cdFx0aWYgKHNlbGYpXG5cdFx0XHRjdXJ2ZXMyID0gY3VydmVzMTtcblx0XHR2YXIgbGVuZ3RoMSA9IGN1cnZlczEubGVuZ3RoLFxuXHRcdFx0bGVuZ3RoMiA9IGN1cnZlczIubGVuZ3RoLFxuXHRcdFx0dmFsdWVzMiA9IFtdLFxuXHRcdFx0YXJyYXlzID0gW10sXG5cdFx0XHRsb2NhdGlvbnMsXG5cdFx0XHRjdXJyZW50O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKVxuXHRcdFx0dmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUxID0gY3VydmVzMVtpXSxcblx0XHRcdFx0dmFsdWVzMSA9IHNlbGYgPyB2YWx1ZXMyW2ldIDogY3VydmUxLmdldFZhbHVlcyhtYXRyaXgxKSxcblx0XHRcdFx0cGF0aDEgPSBjdXJ2ZTEuZ2V0UGF0aCgpO1xuXHRcdFx0aWYgKHBhdGgxICE9PSBjdXJyZW50KSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBwYXRoMTtcblx0XHRcdFx0bG9jYXRpb25zID0gW107XG5cdFx0XHRcdGFycmF5cy5wdXNoKGxvY2F0aW9ucyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VsZikge1xuXHRcdFx0XHRnZXRMb29wSW50ZXJzZWN0aW9uKHZhbHVlczEsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGogPSBzZWxmID8gaSArIDEgOiAwOyBqIDwgbGVuZ3RoMjsgaisrKSB7XG5cdFx0XHRcdGlmIChfcmV0dXJuRmlyc3QgJiYgbG9jYXRpb25zLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0XHRnZXRDdXJ2ZUludGVyc2VjdGlvbnModmFsdWVzMSwgdmFsdWVzMltqXSwgY3VydmUxLCBjdXJ2ZXMyW2pdLFxuXHRcdFx0XHRcdFx0bG9jYXRpb25zLCBpbmNsdWRlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9jYXRpb25zID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsb2NhdGlvbnMucHVzaC5hcHBseShsb2NhdGlvbnMsIGFycmF5c1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRPdmVybGFwcyh2MSwgdjIpIHtcblxuXHRcdGZ1bmN0aW9uIGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYpIHtcblx0XHRcdHZhciB4ID0gdls2XSAtIHZbMF0sXG5cdFx0XHRcdHkgPSB2WzddIC0gdlsxXTtcblx0XHRcdHJldHVybiB4ICogeCArIHkgKiB5O1xuXHRcdH1cblxuXHRcdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRcdGdldERpc3RhbmNlID0gTGluZS5nZXREaXN0YW5jZSxcblx0XHRcdHRpbWVFcHNpbG9uID0gMWUtOCxcblx0XHRcdGdlb21FcHNpbG9uID0gMWUtNyxcblx0XHRcdHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuXHRcdFx0c3RyYWlnaHQyID0gQ3VydmUuaXNTdHJhaWdodCh2MiksXG5cdFx0XHRzdHJhaWdodEJvdGggPSBzdHJhaWdodDEgJiYgc3RyYWlnaHQyLFxuXHRcdFx0ZmxpcCA9IGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYxKSA8IGdldFNxdWFyZWRMaW5lTGVuZ3RoKHYyKSxcblx0XHRcdGwxID0gZmxpcCA/IHYyIDogdjEsXG5cdFx0XHRsMiA9IGZsaXAgPyB2MSA6IHYyLFxuXHRcdFx0cHggPSBsMVswXSwgcHkgPSBsMVsxXSxcblx0XHRcdHZ4ID0gbDFbNl0gLSBweCwgdnkgPSBsMVs3XSAtIHB5O1xuXHRcdGlmIChnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbMF0sIGwyWzFdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmXG5cdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbNl0sIGwyWzddLCB0cnVlKSA8IGdlb21FcHNpbG9uKSB7XG5cdFx0XHRpZiAoIXN0cmFpZ2h0Qm90aCAmJlxuXHRcdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDFbMl0sIGwxWzNdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmXG5cdFx0XHRcdGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMVs0XSwgbDFbNV0sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiZcblx0XHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzJdLCBsMlszXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJlxuXHRcdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDJbNF0sIGwyWzVdLCB0cnVlKSA8IGdlb21FcHNpbG9uKSB7XG5cdFx0XHRcdHN0cmFpZ2h0MSA9IHN0cmFpZ2h0MiA9IHN0cmFpZ2h0Qm90aCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzdHJhaWdodEJvdGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRpZiAoc3RyYWlnaHQxIF4gc3RyYWlnaHQyKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgdiA9IFt2MSwgdjJdLFxuXHRcdFx0cGFpcnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgcGFpcnMubGVuZ3RoIDwgMjsgaSsrKSB7XG5cdFx0XHR2YXIgaTEgPSBpICYgMSxcblx0XHRcdFx0aTIgPSBpMSBeIDEsXG5cdFx0XHRcdHQxID0gaSA+PiAxLFxuXHRcdFx0XHR0MiA9IEN1cnZlLmdldFRpbWVPZih2W2kxXSwgbmV3IFBvaW50KFxuXHRcdFx0XHRcdHZbaTJdW3QxID8gNiA6IDBdLFxuXHRcdFx0XHRcdHZbaTJdW3QxID8gNyA6IDFdKSk7XG5cdFx0XHRpZiAodDIgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgcGFpciA9IGkxID8gW3QxLCB0Ml0gOiBbdDIsIHQxXTtcblx0XHRcdFx0aWYgKCFwYWlycy5sZW5ndGggfHxcblx0XHRcdFx0XHRhYnMocGFpclswXSAtIHBhaXJzWzBdWzBdKSA+IHRpbWVFcHNpbG9uICYmXG5cdFx0XHRcdFx0YWJzKHBhaXJbMV0gLSBwYWlyc1swXVsxXSkgPiB0aW1lRXBzaWxvbikge1xuXHRcdFx0XHRcdHBhaXJzLnB1c2gocGFpcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChpID4gMiAmJiAhcGFpcnMubGVuZ3RoKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKHBhaXJzLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0cGFpcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoIXN0cmFpZ2h0Qm90aCkge1xuXHRcdFx0dmFyIG8xID0gQ3VydmUuZ2V0UGFydCh2MSwgcGFpcnNbMF1bMF0sIHBhaXJzWzFdWzBdKSxcblx0XHRcdFx0bzIgPSBDdXJ2ZS5nZXRQYXJ0KHYyLCBwYWlyc1swXVsxXSwgcGFpcnNbMV1bMV0pO1xuXHRcdFx0aWYgKGFicyhvMlsyXSAtIG8xWzJdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdGFicyhvMlszXSAtIG8xWzNdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdGFicyhvMls0XSAtIG8xWzRdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdGFicyhvMls1XSAtIG8xWzVdKSA+IGdlb21FcHNpbG9uKVxuXHRcdFx0XHRwYWlycyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBwYWlycztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRcdHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRcdHYyID0gY3VydmUgJiYgY3VydmUgIT09IHRoaXMgJiYgY3VydmUuZ2V0VmFsdWVzKCk7XG5cdFx0XHRyZXR1cm4gdjIgPyBnZXRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCB0aGlzLCBjdXJ2ZSwgW10pXG5cdFx0XHRcdFx0ICA6IGdldExvb3BJbnRlcnNlY3Rpb24odjEsIHRoaXMsIFtdKTtcblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0Z2V0T3ZlcmxhcHM6IGdldE92ZXJsYXBzLFxuXHRcdFx0Z2V0SW50ZXJzZWN0aW9uczogZ2V0SW50ZXJzZWN0aW9ucyxcblx0XHRcdGdldEN1cnZlTGluZUludGVyc2VjdGlvbnM6IGdldEN1cnZlTGluZUludGVyc2VjdGlvbnNcblx0XHR9XG5cdH07XG59KTtcblxudmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHRpbWUsIHBvaW50LCBfb3ZlcmxhcCwgX2Rpc3RhbmNlKSB7XG5cdFx0aWYgKHRpbWUgPj0gMC45OTk5OTk5OSkge1xuXHRcdFx0dmFyIG5leHQgPSBjdXJ2ZS5nZXROZXh0KCk7XG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0Y3VydmUgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0dGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludCB8fCBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0aW1lKTtcblx0XHR0aGlzLl9vdmVybGFwID0gX292ZXJsYXA7XG5cdFx0dGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG5cdFx0dGhpcy5faW50ZXJzZWN0aW9uID0gdGhpcy5fbmV4dCA9IHRoaXMuX3ByZXZpb3VzID0gbnVsbDtcblx0fSxcblxuXHRfc2V0Q3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHR0aGlzLl9wYXRoID0gcGF0aDtcblx0XHR0aGlzLl92ZXJzaW9uID0gcGF0aCA/IHBhdGguX3ZlcnNpb24gOiAwO1xuXHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0dGhpcy5fc2VnbWVudCA9IG51bGw7XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdH0sXG5cblx0X3NldFNlZ21lbnQ6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHR0aGlzLl9zZXRDdXJ2ZShzZWdtZW50LmdldEN1cnZlKCkpO1xuXHRcdHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdHRoaXMuX3RpbWUgPSBzZWdtZW50ID09PSB0aGlzLl9zZWdtZW50MSA/IDAgOiAxO1xuXHRcdHRoaXMuX3BvaW50ID0gc2VnbWVudC5fcG9pbnQuY2xvbmUoKTtcblx0fSxcblxuXHRnZXRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnQ7XG5cdFx0aWYgKCFzZWdtZW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRcdGlmICh0aW1lID09PSAwKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPT09IDEpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSBpZiAodGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHRpbWUpXG5cdFx0XHRcdFx0PCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHRpbWUsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHNlZ21lbnQ7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGlmIChwYXRoICYmIHBhdGguX3ZlcnNpb24gIT09IHRoaXMuX3ZlcnNpb24pIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9vZmZzZXQgPSB0aGlzLl9jdXJ2ZU9mZnNldCA9IHRoaXMuX2N1cnZlID0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cnlTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQgJiYgc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXHRcdFx0aWYgKGN1cnZlICYmICh0aGF0Ll90aW1lID0gY3VydmUuZ2V0VGltZU9mKHRoYXQuX3BvaW50KSkgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGF0Ll9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fY3VydmVcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudClcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDEpXG5cdFx0XHR8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQyLmdldFByZXZpb3VzKCkpO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZ2V0SW5kZXgoKTtcblx0fSxcblxuXHRnZXRUaW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRyZXR1cm4gY3VydmUgJiYgdGltZSA9PSBudWxsXG5cdFx0XHQ/IHRoaXMuX3RpbWUgPSBjdXJ2ZS5nZXRUaW1lT2YodGhpcy5fcG9pbnQpXG5cdFx0XHQ6IHRpbWU7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiAnI2dldFRpbWUnLFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXHRcdGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCksXG5cdFx0XHRcdGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdFx0aWYgKHBhdGggJiYgaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY3VydmVzID0gcGF0aC5nZXRDdXJ2ZXMoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuXHRcdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQgKz0gdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdGdldEN1cnZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fY3VydmVPZmZzZXQ7XG5cdFx0aWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRcdHRoaXMuX2N1cnZlT2Zmc2V0ID0gb2Zmc2V0ID0gdGltZSAhPSBudWxsICYmIGN1cnZlXG5cdFx0XHRcdFx0JiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0aW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaXN0YW5jZTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHJlcyA9IGN1cnZlICYmIGN1cnZlLmRpdmlkZUF0VGltZSh0aGlzLmdldFRpbWUoKSk7XG5cdFx0aWYgKHJlcykge1xuXHRcdFx0dGhpcy5fc2V0U2VnbWVudChyZXMuX3NlZ21lbnQxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGF0aCA9IGN1cnZlLl9wYXRoLFxuXHRcdFx0cmVzID0gY3VydmUgJiYgY3VydmUuc3BsaXRBdFRpbWUodGhpcy5nZXRUaW1lKCkpO1xuXHRcdGlmIChyZXMpIHtcblx0XHRcdHRoaXMuX3NldFNlZ21lbnQocGF0aC5nZXRMYXN0U2VnbWVudCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuICByZXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MsIF9pZ25vcmVPdGhlcikge1xuXHRcdHZhciByZXMgPSB0aGlzID09PSBsb2M7XG5cdFx0aWYgKCFyZXMgJiYgbG9jIGluc3RhbmNlb2YgQ3VydmVMb2NhdGlvbikge1xuXHRcdFx0dmFyIGMxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRjMiA9IGxvYy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRwMSA9IGMxLl9wYXRoLFxuXHRcdFx0XHRwMiA9IGMyLl9wYXRoO1xuXHRcdFx0aWYgKHAxID09PSBwMikge1xuXHRcdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTcsXG5cdFx0XHRcdFx0ZGlmZiA9IGFicyh0aGlzLmdldE9mZnNldCgpIC0gbG9jLmdldE9mZnNldCgpKSxcblx0XHRcdFx0XHRpMSA9ICFfaWdub3JlT3RoZXIgJiYgdGhpcy5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRcdGkyID0gIV9pZ25vcmVPdGhlciAmJiBsb2MuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0cmVzID0gKGRpZmYgPCBlcHNpbG9uXG5cdFx0XHRcdFx0XHR8fCBwMSAmJiBhYnMocDEuZ2V0TGVuZ3RoKCkgLSBkaWZmKSA8IGVwc2lsb24pXG5cdFx0XHRcdFx0JiYgKCFpMSAmJiAhaTIgfHwgaTEgJiYgaTIgJiYgaTEuZXF1YWxzKGkyLCB0cnVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG5cdFx0aWYgKHRpbWUgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3RpbWU6ICcgKyBmLm51bWJlcih0aW1lKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRpc1RvdWNoaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKGludGVyICYmIHRoaXMuZ2V0VGFuZ2VudCgpLmlzQ29sbGluZWFyKGludGVyLmdldFRhbmdlbnQoKSkpIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdGN1cnZlMiA9IGludGVyLmdldEN1cnZlKCk7XG5cdFx0XHRyZXR1cm4gIShjdXJ2ZTEuaXNTdHJhaWdodCgpICYmIGN1cnZlMi5pc1N0cmFpZ2h0KClcblx0XHRcdFx0XHQmJiBjdXJ2ZTEuZ2V0TGluZSgpLmludGVyc2VjdChjdXJ2ZTIuZ2V0TGluZSgpKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0Nyb3NzaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgdDEgPSB0aGlzLmdldFRpbWUoKSxcblx0XHRcdHQyID0gaW50ZXIuZ2V0VGltZSgpLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHR0MUluc2lkZSA9IHQxID49IHRNaW4gJiYgdDEgPD0gdE1heCxcblx0XHRcdHQySW5zaWRlID0gdDIgPj0gdE1pbiAmJiB0MiA8PSB0TWF4O1xuXHRcdGlmICh0MUluc2lkZSAmJiB0Mkluc2lkZSlcblx0XHRcdHJldHVybiAhdGhpcy5pc1RvdWNoaW5nKCk7XG5cdFx0dmFyIGMyID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0YzEgPSB0MSA8IHRNaW4gPyBjMi5nZXRQcmV2aW91cygpIDogYzIsXG5cdFx0XHRjNCA9IGludGVyLmdldEN1cnZlKCksXG5cdFx0XHRjMyA9IHQyIDwgdE1pbiA/IGM0LmdldFByZXZpb3VzKCkgOiBjNDtcblx0XHRpZiAodDEgPiB0TWF4KVxuXHRcdFx0YzIgPSBjMi5nZXROZXh0KCk7XG5cdFx0aWYgKHQyID4gdE1heClcblx0XHRcdGM0ID0gYzQuZ2V0TmV4dCgpO1xuXHRcdGlmICghYzEgfHwgIWMyIHx8ICFjMyB8fCAhYzQpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgb2Zmc2V0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkT2Zmc2V0cyhjdXJ2ZSwgZW5kKSB7XG5cdFx0XHR2YXIgdiA9IGN1cnZlLmdldFZhbHVlcygpLFxuXHRcdFx0XHRyb290cyA9IEN1cnZlLmNsYXNzaWZ5KHYpLnJvb3RzIHx8IEN1cnZlLmdldFBlYWtzKHYpLFxuXHRcdFx0XHRjb3VudCA9IHJvb3RzLmxlbmd0aCxcblx0XHRcdFx0dCA9IGVuZCAmJiBjb3VudCA+IDEgPyByb290c1tjb3VudCAtIDFdXG5cdFx0XHRcdFx0XHQ6IGNvdW50ID4gMCA/IHJvb3RzWzBdXG5cdFx0XHRcdFx0XHQ6IDAuNTtcblx0XHRcdG9mZnNldHMucHVzaChDdXJ2ZS5nZXRMZW5ndGgodiwgZW5kID8gdCA6IDAsIGVuZCA/IDEgOiB0KSAvIDIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzSW5SYW5nZShhbmdsZSwgbWluLCBtYXgpIHtcblx0XHRcdHJldHVybiBtaW4gPCBtYXhcblx0XHRcdFx0XHQ/IGFuZ2xlID4gbWluICYmIGFuZ2xlIDwgbWF4XG5cdFx0XHRcdFx0OiBhbmdsZSA+IG1pbiB8fCBhbmdsZSA8IG1heDtcblx0XHR9XG5cblx0XHRpZiAoIXQxSW5zaWRlKSB7XG5cdFx0XHRhZGRPZmZzZXRzKGMxLCB0cnVlKTtcblx0XHRcdGFkZE9mZnNldHMoYzIsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKCF0Mkluc2lkZSkge1xuXHRcdFx0YWRkT2Zmc2V0cyhjMywgdHJ1ZSk7XG5cdFx0XHRhZGRPZmZzZXRzKGM0LCBmYWxzZSk7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdG9mZnNldCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG9mZnNldHMpLFxuXHRcdFx0djIgPSB0MUluc2lkZSA/IGMyLmdldFRhbmdlbnRBdFRpbWUodDEpXG5cdFx0XHRcdFx0OiBjMi5nZXRQb2ludEF0KG9mZnNldCkuc3VidHJhY3QocHQpLFxuXHRcdFx0djEgPSB0MUluc2lkZSA/IHYyLm5lZ2F0ZSgpXG5cdFx0XHRcdFx0OiBjMS5nZXRQb2ludEF0KC1vZmZzZXQpLnN1YnRyYWN0KHB0KSxcblx0XHRcdHY0ID0gdDJJbnNpZGUgPyBjNC5nZXRUYW5nZW50QXRUaW1lKHQyKVxuXHRcdFx0XHRcdDogYzQuZ2V0UG9pbnRBdChvZmZzZXQpLnN1YnRyYWN0KHB0KSxcblx0XHRcdHYzID0gdDJJbnNpZGUgPyB2NC5uZWdhdGUoKVxuXHRcdFx0XHRcdDogYzMuZ2V0UG9pbnRBdCgtb2Zmc2V0KS5zdWJ0cmFjdChwdCksXG5cdFx0XHRhMSA9IHYxLmdldEFuZ2xlKCksXG5cdFx0XHRhMiA9IHYyLmdldEFuZ2xlKCksXG5cdFx0XHRhMyA9IHYzLmdldEFuZ2xlKCksXG5cdFx0XHRhNCA9IHY0LmdldEFuZ2xlKCk7XG5cdFx0cmV0dXJuICEhKHQxSW5zaWRlXG5cdFx0XHRcdD8gKGlzSW5SYW5nZShhMSwgYTMsIGE0KSBeIGlzSW5SYW5nZShhMiwgYTMsIGE0KSkgJiZcblx0XHRcdFx0ICAoaXNJblJhbmdlKGExLCBhNCwgYTMpIF4gaXNJblJhbmdlKGEyLCBhNCwgYTMpKVxuXHRcdFx0XHQ6IChpc0luUmFuZ2UoYTMsIGExLCBhMikgXiBpc0luUmFuZ2UoYTQsIGExLCBhMikpICYmXG5cdFx0XHRcdCAgKGlzSW5SYW5nZShhMywgYTIsIGExKSBeIGlzSW5SYW5nZShhNCwgYTIsIGExKSkpO1xuXHR9LFxuXG5cdGhhc092ZXJsYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX292ZXJsYXA7XG5cdH1cbn0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRyZXR1cm4gdGltZSAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0odGltZSwgdHJ1ZSk7XG5cdH07XG59LCB7XG5cdHByZXNlcnZlOiB0cnVlXG59KSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBpbnNlcnQobG9jYXRpb25zLCBsb2MsIG1lcmdlKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGxvY2F0aW9ucy5sZW5ndGgsXG5cdFx0XHRsID0gMCxcblx0XHRcdHIgPSBsZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gc2VhcmNoKGluZGV4LCBkaXIpIHtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGRpcjsgaSA+PSAtMSAmJiBpIDw9IGxlbmd0aDsgaSArPSBkaXIpIHtcblx0XHRcdFx0dmFyIGxvYzIgPSBsb2NhdGlvbnNbKChpICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdO1xuXHRcdFx0XHRpZiAoIWxvYy5nZXRQb2ludCgpLmlzQ2xvc2UobG9jMi5nZXRQb2ludCgpLFxuXHRcdFx0XHRcdFx0MWUtNykpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGlmIChsb2MuZXF1YWxzKGxvYzIpKVxuXHRcdFx0XHRcdHJldHVybiBsb2MyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGwgPD0gcikge1xuXHRcdFx0dmFyIG0gPSAobCArIHIpID4+PiAxLFxuXHRcdFx0XHRsb2MyID0gbG9jYXRpb25zW21dLFxuXHRcdFx0XHRmb3VuZDtcblx0XHRcdGlmIChtZXJnZSAmJiAoZm91bmQgPSBsb2MuZXF1YWxzKGxvYzIpID8gbG9jMlxuXHRcdFx0XHRcdDogKHNlYXJjaChtLCAtMSkgfHwgc2VhcmNoKG0sIDEpKSkpIHtcblx0XHRcdFx0aWYgKGxvYy5fb3ZlcmxhcCkge1xuXHRcdFx0XHRcdGZvdW5kLl9vdmVybGFwID0gZm91bmQuX2ludGVyc2VjdGlvbi5fb3ZlcmxhcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdFx0fVxuXHRcdHZhciBwYXRoMSA9IGxvYy5nZXRQYXRoKCksXG5cdFx0XHRwYXRoMiA9IGxvYzIuZ2V0UGF0aCgpLFxuXHRcdFx0ZGlmZiA9IHBhdGgxICE9PSBwYXRoMlxuXHRcdFx0XHQ/IHBhdGgxLl9pZCAtIHBhdGgyLl9pZFxuXHRcdFx0XHQ6IChsb2MuZ2V0SW5kZXgoKSArIGxvYy5nZXRUaW1lKCkpXG5cdFx0XHRcdC0gKGxvYzIuZ2V0SW5kZXgoKSArIGxvYzIuZ2V0VGltZSgpKTtcblx0XHRcdGlmIChkaWZmIDwgMCkge1xuXHRcdFx0XHRyID0gbSAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsID0gbSArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxvY2F0aW9ucy5zcGxpY2UobCwgMCwgbG9jKTtcblx0XHRyZXR1cm4gbG9jO1xuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXHRcdGluc2VydDogaW5zZXJ0LFxuXG5cdFx0ZXhwYW5kOiBmdW5jdGlvbihsb2NhdGlvbnMpIHtcblx0XHRcdHZhciBleHBhbmRlZCA9IGxvY2F0aW9ucy5zbGljZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpbnNlcnQoZXhwYW5kZWQsIGxvY2F0aW9uc1tpXS5faW50ZXJzZWN0aW9uLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgUGF0aEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVtJyxcblx0X3NlbGVjdEJvdW5kczogZmFsc2UsXG5cdF9jYW5TY2FsZVN0cm9rZTogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aEl0ZW0oKSB7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oYXJnKSB7XG5cdFx0XHR2YXIgZGF0YSxcblx0XHRcdFx0c2VnbWVudHMsXG5cdFx0XHRcdGNvbXBvdW5kO1xuXHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKSB7XG5cdFx0XHRcdHNlZ21lbnRzID0gYXJnLnNlZ21lbnRzO1xuXHRcdFx0XHRkYXRhID0gYXJnLnBhdGhEYXRhO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBhcmc7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRhdGEgPSBhcmc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VnbWVudHMpIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0XHRcdGNvbXBvdW5kID0gZmlyc3QgJiYgQXJyYXkuaXNBcnJheShmaXJzdFswXSk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGEpIHtcblx0XHRcdFx0Y29tcG91bmQgPSAoZGF0YS5tYXRjaCgvbS9naSkgfHwgW10pLmxlbmd0aCA+IDFcblx0XHRcdFx0XHRcdHx8IC96XFxzKlxcUysvaS50ZXN0KGRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN0b3IgPSBjb21wb3VuZCA/IENvbXBvdW5kUGF0aCA6IFBhdGg7XG5cdFx0XHRyZXR1cm4gbmV3IGN0b3IoYXJnKTtcblx0XHR9XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBcmVhKCkgPj0gMDtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT0gKGNsb2Nrd2lzZSA9ICEhY2xvY2t3aXNlKSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdHNldFBhdGhEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cblx0XHR2YXIgcGFydHMgPSBkYXRhICYmIGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQpO1xuXHRcdFx0c3dpdGNoIChsb3dlcikge1xuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0dmFyIG1vdmUgPSBsb3dlciA9PT0gJ20nO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG5cdFx0XHRcdFx0dGhpc1ttb3ZlID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRpZiAobW92ZSkge1xuXHRcdFx0XHRcdFx0c3RhcnQgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0bW92ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5jbG9uZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgoMWUtMTIpO1xuXHRcdFx0XHRjdXJyZW50ID0gc3RhcnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gcG9pbnQuaXNJbnNpZGUoXG5cdFx0XHRcdHRoaXMuZ2V0Qm91bmRzKHsgaW50ZXJuYWw6IHRydWUsIGhhbmRsZTogdHJ1ZSB9KSlcblx0XHRcdFx0XHQ/IHRoaXMuX2dldFdpbmRpbmcocG9pbnQpXG5cdFx0XHRcdFx0OiB7fTtcblx0XHRyZXR1cm4gd2luZGluZy5vblBhdGggfHwgISEodGhpcy5nZXRGaWxsUnVsZSgpID09PSAnZXZlbm9kZCdcblx0XHRcdFx0PyB3aW5kaW5nLndpbmRpbmdMICYgMSB8fCB3aW5kaW5nLndpbmRpbmdSICYgMVxuXHRcdFx0XHQ6IHdpbmRpbmcud2luZGluZyk7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocGF0aCwgaW5jbHVkZSwgX21hdHJpeCwgX3JldHVybkZpcnN0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzID09PSBwYXRoIHx8ICFwYXRoLFxuXHRcdFx0bWF0cml4MSA9IHRoaXMuX21hdHJpeC5fb3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHNlbGYgPyBtYXRyaXgxXG5cdFx0XHRcdDogKF9tYXRyaXggfHwgcGF0aC5fbWF0cml4KS5fb3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHJldHVybiBzZWxmIHx8IHRoaXMuZ2V0Qm91bmRzKG1hdHJpeDEpLmludGVyc2VjdHMoXG5cdFx0XHRcdHBhdGguZ2V0Qm91bmRzKG1hdHJpeDIpLCAxZS0xMilcblx0XHRcdFx0PyBDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0dGhpcy5nZXRDdXJ2ZXMoKSwgIXNlbGYgJiYgcGF0aC5nZXRDdXJ2ZXMoKSwgaW5jbHVkZSxcblx0XHRcdFx0XHRcdG1hdHJpeDEsIG1hdHJpeDIsIF9yZXR1cm5GaXJzdClcblx0XHRcdFx0OiBbXTtcblx0fSxcblxuXHRnZXRDcm9zc2luZ3M6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKHBhdGgsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpIHx8IGludGVyLmlzQ3Jvc3NpbmcoKTtcblx0XHR9KTtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5Mb2MgPSBudWxsO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYy5fZGlzdGFuY2UgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdG1pbkRpc3QgPSBsb2MuX2Rpc3RhbmNlO1xuXHRcdFx0XHRtaW5Mb2MgPSBsb2M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Mb2M7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldFBvaW50KCkgOiBsb2M7XG5cdH0sXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBmYWN0b3IpIHtcblx0XHR2YXIgaXNQYXRoID0gIXRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bmFtZSA9IGlzUGF0aCA/ICdfc2VnbWVudHMnIDogJ19jaGlsZHJlbicsXG5cdFx0XHRpdGVtc0Zyb20gPSBmcm9tW25hbWVdLFxuXHRcdFx0aXRlbXNUbyA9IHRvW25hbWVdLFxuXHRcdFx0aXRlbXMgPSB0aGlzW25hbWVdO1xuXHRcdGlmICghaXRlbXNGcm9tIHx8ICFpdGVtc1RvIHx8IGl0ZW1zRnJvbS5sZW5ndGggIT09IGl0ZW1zVG8ubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmFuZHMgaW4gaW50ZXJwb2xhdGUoKSBjYWxsOiAnICtcblx0XHRcdFx0XHRmcm9tICsgJywgJyArIHRvKTtcblx0XHR9XG5cdFx0dmFyIGN1cnJlbnQgPSBpdGVtcy5sZW5ndGgsXG5cdFx0XHRsZW5ndGggPSBpdGVtc1RvLmxlbmd0aDtcblx0XHRpZiAoY3VycmVudCA8IGxlbmd0aCkge1xuXHRcdFx0dmFyIGN0b3IgPSBpc1BhdGggPyBTZWdtZW50IDogUGF0aDtcblx0XHRcdGZvciAodmFyIGkgPSBjdXJyZW50OyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hZGQobmV3IGN0b3IoKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjdXJyZW50ID4gbGVuZ3RoKSB7XG5cdFx0XHR0aGlzW2lzUGF0aCA/ICdyZW1vdmVTZWdtZW50cycgOiAncmVtb3ZlQ2hpbGRyZW4nXShsZW5ndGgsIGN1cnJlbnQpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpdGVtc1tpXS5pbnRlcnBvbGF0ZShpdGVtc0Zyb21baV0sIGl0ZW1zVG9baV0sIGZhY3Rvcik7XG5cdFx0fVxuXHRcdGlmIChpc1BhdGgpIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZyb20uX2Nsb3NlZCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRjb21wYXJlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dmFyIG9rID0gZmFsc2U7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdHZhciBwYXRoczEgPSB0aGlzLl9jaGlsZHJlbiB8fCBbdGhpc10sXG5cdFx0XHRcdHBhdGhzMiA9IHBhdGguX2NoaWxkcmVuID8gcGF0aC5fY2hpbGRyZW4uc2xpY2UoKSA6IFtwYXRoXSxcblx0XHRcdFx0bGVuZ3RoMSA9IHBhdGhzMS5sZW5ndGgsXG5cdFx0XHRcdGxlbmd0aDIgPSBwYXRoczIubGVuZ3RoLFxuXHRcdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdG9rID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGkxID0gbGVuZ3RoMSAtIDE7IGkxID49IDAgJiYgb2s7IGkxLS0pIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gcGF0aHMxW2kxXTtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaTIgPSBsZW5ndGgyIC0gMTsgaTIgPj0gMCAmJiAhb2s7IGkyLS0pIHtcblx0XHRcdFx0XHRpZiAocGF0aDEuY29tcGFyZShwYXRoczJbaTJdKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaGVkW2kyXSkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkW2kyXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvayA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvayA9IG9rICYmIGNvdW50ID09PSBsZW5ndGgyO1xuXHRcdH1cblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cbn0pO1xuXG52YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c2VnbWVudHM6IFtdLFxuXHRcdGNsb3NlZDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NlZ21lbnRzID0gW107XG5cdFx0dGhpcy5fdmVyc2lvbiA9IDA7XG5cdFx0dmFyIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG5cdFx0XHQ/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG5cdFx0XHRcdD8gYXJnXG5cdFx0XHRcdDogYXJndW1lbnRzXG5cdFx0XHQ6IGFyZyAmJiAoYXJnLnNpemUgPT09IHVuZGVmaW5lZCAmJiAoYXJnLnggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdHx8IGFyZy5wb2ludCAhPT0gdW5kZWZpbmVkKSlcblx0XHRcdFx0PyBhcmd1bWVudHNcblx0XHRcdFx0OiBudWxsO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0U2VnbWVudHMoc291cmNlLl9zZWdtZW50cyk7XG5cdFx0dGhpcy5fY2xvc2VkID0gc291cmNlLl9jbG9zZWQ7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9hcmVhID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKGZsYWdzICYgMTYpIHtcblx0XHRcdFx0dGhpcy5fdmVyc2lvbisrO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdCAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZsYWdzICYgMzIpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0cmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG5cdH0sXG5cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cztcblx0fSxcblxuXHRzZXRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHR2YXIgZnVsbHlTZWxlY3RlZCA9IHRoaXMuaXNGdWxseVNlbGVjdGVkKCksXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5fc2VnbWVudHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIGxhc3QgPSBzZWdtZW50c1tsZW5ndGggLSAxXTtcblx0XHRcdGlmICh0eXBlb2YgbGFzdCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGxhc3QpO1xuXHRcdFx0XHRsZW5ndGgtLTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzLCAwLCB7fSwgbGVuZ3RoKSk7XG5cdFx0fVxuXHRcdGlmIChmdWxseVNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzWzBdO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbdGhpcy5fc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRpZiAoIWN1cnZlcykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRcdGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSxcblx0XHRcdFx0XHRzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnZlcygpWzBdO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0cmV0dXJuIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0aXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdH0sXG5cblx0c2V0Q2xvc2VkOiBmdW5jdGlvbihjbG9zZWQpIHtcblx0XHRpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2N1cnZlcy5sZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tsZW5ndGggLSAxXSA9IG5ldyBDdXJ2ZSh0aGlzLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHNbbGVuZ3RoIC0gMV0sIHRoaXMuX3NlZ21lbnRzWzBdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdH1cblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0ZiA9IG5ldyBGb3JtYXR0ZXIoX3ByZWNpc2lvbiksXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZLFxuXHRcdFx0cGFydHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCwgc2tpcExpbmUpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKF9tYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSkge1xuXHRcdFx0XHRcdFx0dmFyIGR4ID0gY3VyWCAtIHByZXZYLFxuXHRcdFx0XHRcdFx0XHRkeSA9IGN1clkgLSBwcmV2WTtcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goXG5cdFx0XHRcdFx0XHRcdCAgZHggPT09IDAgPyAndicgKyBmLm51bWJlcihkeSlcblx0XHRcdFx0XHRcdFx0OiBkeSA9PT0gMCA/ICdoJyArIGYubnVtYmVyKGR4KVxuXHRcdFx0XHRcdFx0XHQ6ICdsJyArIGYucGFpcihkeCwgZHkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCArICcgJyArIGYucGFpciggaW5YIC0gcHJldlgsICBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0ICsgJyAnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdH1cblxuXHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1swXSwgdHJ1ZSk7XG5cdFx0XHRwYXJ0cy5wdXNoKCd6Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcnKTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hZGQ6IGZ1bmN0aW9uKHNlZ3MsIGluZGV4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRhbW91bnQgPSBzZWdzLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9wYXRoKVxuXHRcdFx0XHRzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcblx0XHRcdHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgc2Vncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlZ21lbnRzLnNwbGljZS5hcHBseShzZWdtZW50cywgW2luZGV4LCAwXS5jb25jYXQoc2VncykpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdH1cblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgdG90YWwgPSB0aGlzLl9jb3VudEN1cnZlcygpLFxuXHRcdFx0XHRzdGFydCA9IGluZGV4ID4gMCAmJiBpbmRleCArIGFtb3VudCAtIDEgPT09IHRvdGFsID8gaW5kZXggLSAxXG5cdFx0XHRcdFx0OiBpbmRleCxcblx0XHRcdFx0aW5zZXJ0ID0gc3RhcnQsXG5cdFx0XHRcdGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgYW1vdW50LCB0b3RhbCk7XG5cdFx0XHRpZiAoc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UuYXBwbHkoY3VydmVzLCBbc3RhcnQsIDBdLmNvbmNhdChzZWdzLl9jdXJ2ZXMpKTtcblx0XHRcdFx0aW5zZXJ0ICs9IHNlZ3MuX2N1cnZlcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gaW5zZXJ0OyBpIDwgZW5kOyBpKyspXG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UoaSwgMCwgbmV3IEN1cnZlKHRoaXMsIG51bGwsIG51bGwpKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhzdGFydCwgZW5kKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0X2FkanVzdEN1cnZlczogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y3VydmU7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0Y3VydmUuX3BhdGggPSB0aGlzO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbaV07XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmICFzdGFydCA/IHNlZ21lbnRzLmxlbmd0aCAtIDFcblx0XHRcdFx0OiBzdGFydCAtIDFdKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tzdGFydF0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbZW5kXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbZW5kXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jb3VudEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIC0gMSA6IGxlbmd0aDtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KGFyZ3VtZW50cykpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydDogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KGFyZ3VtZW50cywgMSksIGluZGV4KVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4ICkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzKSk7XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudHM6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkTGlzdChzZWdtZW50cyksIGluZGV4KTtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCBpbmRleCArIDEpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudHM6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIF9pbmNsdWRlQ3VydmVzKSB7XG5cdFx0c3RhcnQgPSBzdGFydCB8fCAwO1xuXHRcdGVuZCA9IEJhc2UucGljayhlbmQsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCk7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjb3VudCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHJlbW92ZWQgPSBzZWdtZW50cy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KSxcblx0XHRcdGFtb3VudCA9IHJlbW92ZWQubGVuZ3RoO1xuXHRcdGlmICghYW1vdW50KVxuXHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSByZW1vdmVkW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvbilcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIHNlZ21lbnQuX3NlbGVjdGlvbiwgMCk7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IHNlZ21lbnQuX3BhdGggPSBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdHZhciBpbmRleCA9IHN0YXJ0ID4gMCAmJiBlbmQgPT09IGNvdW50ICsgKHRoaXMuX2Nsb3NlZCA/IDEgOiAwKVxuXHRcdFx0XHRcdD8gc3RhcnQgLSAxXG5cdFx0XHRcdFx0OiBzdGFydCxcblx0XHRcdFx0Y3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblx0XHRcdGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHRcdGN1cnZlc1tpXS5fcGF0aCA9IG51bGw7XG5cdFx0XHRpZiAoX2luY2x1ZGVDdXJ2ZXMpXG5cdFx0XHRcdHJlbW92ZWQuX2N1cnZlcyA9IGN1cnZlcy5zbGljZSgxKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhpbmRleCwgaW5kZXgpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVTZWdtZW50cycsXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChzZWdtZW50c1tpXS5oYXNIYW5kbGVzKCkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Y2xlYXJIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLmNsZWFySGFuZGxlcygpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0bGVuZ3RoICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJlYSA9IHRoaXMuX2FyZWE7XG5cdFx0aWYgKGFyZWEgPT0gbnVsbCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRcdGFyZWEgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGxhc3QgPSBpICsgMSA9PT0gbDtcblx0XHRcdFx0YXJlYSArPSBDdXJ2ZS5nZXRBcmVhKEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRcdHNlZ21lbnRzW2ldLCBzZWdtZW50c1tsYXN0ID8gMCA6IGkgKyAxXSxcblx0XHRcdFx0XHRcdG51bGwsIGxhc3QgJiYgIWNsb3NlZCkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYXJlYSA9IGFyZWE7XG5cdFx0fVxuXHRcdHJldHVybiBhcmVhO1xuXHR9LFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKCkgJiYgbGVuZ3RoID4gMCAmJiB0aGlzLl9zZWdtZW50U2VsZWN0aW9uXG5cdFx0XHRcdD09PSBsZW5ndGggKiA3O1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHModHJ1ZSk7XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG5cdFx0aWYgKCEoc2VsZWN0aW9uICYgMSkpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyhmYWxzZSk7XG5cdFx0c2V0U2VsZWN0aW9uLmJhc2UuY2FsbCh0aGlzLCBzZWxlY3Rpb24pO1xuXHR9LFxuXG5cdF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHNlbGVjdGlvbiA9IHNlbGVjdGVkID8gNyA6IDA7XG5cdFx0dGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IHNlbGVjdGlvbiAqIGxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uX3NlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzZWdtZW50LCBvbGRTZWxlY3Rpb24sIG5ld1NlbGVjdGlvbikge1xuXHRcdHNlZ21lbnQuX3NlbGVjdGlvbiA9IG5ld1NlbGVjdGlvbjtcblx0XHR2YXIgc2VsZWN0aW9uID0gdGhpcy5fc2VnbWVudFNlbGVjdGlvbiArPSBuZXdTZWxlY3Rpb24gLSBvbGRTZWxlY3Rpb247XG5cdFx0aWYgKHNlbGVjdGlvbiA+IDApXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGRpdmlkZUF0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQobG9jYXRpb24pLFxuXHRcdFx0Y3VydmU7XG5cdFx0cmV0dXJuIGxvYyAmJiAoY3VydmUgPSBsb2MuZ2V0Q3VydmUoKS5kaXZpZGVBdChsb2MuZ2V0Q3VydmVPZmZzZXQoKSkpXG5cdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRzcGxpdEF0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQobG9jYXRpb24pLFxuXHRcdFx0aW5kZXggPSBsb2MgJiYgbG9jLmluZGV4LFxuXHRcdFx0dGltZSA9IGxvYyAmJiBsb2MudGltZSxcblx0XHRcdHRNaW4gPSAxZS04LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmICh0aW1lID4gdE1heCkge1xuXHRcdFx0aW5kZXgrKztcblx0XHRcdHRpbWUgPSAwO1xuXHRcdH1cblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGN1cnZlcy5sZW5ndGgpIHtcblx0XHRcdGlmICh0aW1lID49IHRNaW4pIHtcblx0XHRcdFx0Y3VydmVzW2luZGV4KytdLmRpdmlkZUF0VGltZSh0aW1lKTtcblx0XHRcdH1cblx0XHRcdHZhciBzZWdzID0gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoLCB0cnVlKSxcblx0XHRcdFx0cGF0aDtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9zZWQoZmFsc2UpO1xuXHRcdFx0XHRwYXRoID0gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRcdHBhdGguY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRwYXRoLl9hZGQoc2VncywgMCk7XG5cdFx0XHR0aGlzLmFkZFNlZ21lbnQoc2Vnc1swXSk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKGluZGV4LCB0aW1lKSB7XG5cdFx0dmFyIGN1cnZlLFxuXHRcdFx0bG9jYXRpb24gPSB0aW1lID09PSB1bmRlZmluZWQgPyBpbmRleFxuXHRcdFx0XHQ6IChjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmVzKClbaW5kZXhdKVxuXHRcdFx0XHRcdCYmIGN1cnZlLmdldExvY2F0aW9uQXRUaW1lKHRpbWUpO1xuXHRcdHJldHVybiBsb2NhdGlvbiAhPSBudWxsID8gdGhpcy5zcGxpdEF0KGxvY2F0aW9uKSA6IG51bGw7XG5cdH0sXG5cblx0am9pbjogZnVuY3Rpb24ocGF0aCwgdG9sZXJhbmNlKSB7XG5cdFx0dmFyIGVwc2lsb24gPSB0b2xlcmFuY2UgfHwgMDtcblx0XHRpZiAocGF0aCAmJiBwYXRoICE9PSB0aGlzKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdFx0bGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKCFsYXN0Milcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmlzQ2xvc2UobGFzdDIuX3BvaW50LCBlcHNpbG9uKSlcblx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHR2YXIgZmlyc3QyID0gcGF0aC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuaXNDbG9zZShmaXJzdDIuX3BvaW50LCBlcHNpbG9uKSkge1xuXHRcdFx0XHRsYXN0MS5zZXRIYW5kbGVPdXQoZmlyc3QyLl9oYW5kbGVPdXQpO1xuXHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGZpcnN0MSA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5pc0Nsb3NlKGZpcnN0Mi5fcG9pbnQsIGVwc2lsb24pKVxuXHRcdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmlzQ2xvc2UobGFzdDIuX3BvaW50LCBlcHNpbG9uKSkge1xuXHRcdFx0XHRcdGZpcnN0MS5zZXRIYW5kbGVJbihsYXN0Mi5faGFuZGxlSW4pO1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgwLCBzZWdtZW50cy5sZW5ndGggLSAxKSwgMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0XHR0aGlzLl9hZGQoW3NlZ21lbnRzWzBdXSk7XG5cdFx0XHRwYXRoLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpLFxuXHRcdFx0bGFzdCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRpZiAoZmlyc3QgIT09IGxhc3QgJiYgZmlyc3QuX3BvaW50LmlzQ2xvc2UobGFzdC5fcG9pbnQsIGVwc2lsb24pKSB7XG5cdFx0XHRmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG5cdFx0XHRsYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0c2ltcGxpZnkgPSBvcHRpb25zICYmIG9wdGlvbnMuc2ltcGxpZnksXG5cdFx0XHR0b2xlcmFuY2UgPSBzaW1wbGlmeSA/IDFlLTcgOiAwO1xuXHRcdGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGlmICghY3VydmUuaGFzSGFuZGxlcygpICYmICghY3VydmUuaGFzTGVuZ3RoKHRvbGVyYW5jZSlcblx0XHRcdFx0XHR8fCBzaW1wbGlmeSAmJiBjdXJ2ZS5pc0NvbGxpbmVhcihjdXJ2ZS5nZXROZXh0KCkpKSlcblx0XHRcdFx0Y3VydmUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnRzLnJldmVyc2UoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0dGhpcy5fY3VydmVzID0gbnVsbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGZsYXR0ZW46IGZ1bmN0aW9uKGZsYXRuZXNzKSB7XG5cdFx0dmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMsIGZsYXRuZXNzIHx8IDAuMjUsIDI1NiwgdHJ1ZSksXG5cdFx0XHRwYXJ0cyA9IGZsYXR0ZW5lci5wYXJ0cyxcblx0XHRcdGxlbmd0aCA9IHBhcnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwYXJ0c1tpXS5jdXJ2ZS5zbGljZSgwLCAyKSkpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHBhcnRzW2xlbmd0aCAtIDFdLmN1cnZlLnNsaWNlKDYpKSk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHR9LFxuXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgUGF0aEZpdHRlcih0aGlzKS5maXQodG9sZXJhbmNlIHx8IDIuNSk7XG5cdFx0aWYgKHNlZ21lbnRzKVxuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdFx0cmV0dXJuICEhc2VnbWVudHM7XG5cdH0sXG5cblx0c21vb3RoOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0cyA9IG9wdGlvbnMgfHwge30sXG5cdFx0XHR0eXBlID0gb3B0cy50eXBlIHx8ICdhc3ltbWV0cmljJyxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG5cblx0XHRmdW5jdGlvbiBnZXRJbmRleCh2YWx1ZSwgX2RlZmF1bHQpIHtcblx0XHRcdHZhciBpbmRleCA9IHZhbHVlICYmIHZhbHVlLmluZGV4O1xuXHRcdFx0aWYgKGluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIHBhdGggPSB2YWx1ZS5wYXRoO1xuXHRcdFx0XHRpZiAocGF0aCAmJiBwYXRoICE9PSB0aGF0KVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcih2YWx1ZS5fY2xhc3MgKyAnICcgKyBpbmRleCArICcgb2YgJyArIHBhdGhcblx0XHRcdFx0XHRcdFx0KyAnIGlzIG5vdCBwYXJ0IG9mICcgKyB0aGF0KTtcblx0XHRcdFx0aWYgKF9kZWZhdWx0ICYmIHZhbHVlIGluc3RhbmNlb2YgQ3VydmUpXG5cdFx0XHRcdFx0aW5kZXgrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluZGV4ID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oaW5kZXggPCAwICYmIGNsb3NlZFxuXHRcdFx0XHRcdD8gaW5kZXggJSBsZW5ndGhcblx0XHRcdFx0XHQ6IGluZGV4IDwgMCA/IGluZGV4ICsgbGVuZ3RoIDogaW5kZXgsIGxlbmd0aCAtIDEpO1xuXHRcdH1cblxuXHRcdHZhciBsb29wID0gY2xvc2VkICYmIG9wdHMuZnJvbSA9PT0gdW5kZWZpbmVkICYmIG9wdHMudG8gPT09IHVuZGVmaW5lZCxcblx0XHRcdGZyb20gPSBnZXRJbmRleChvcHRzLmZyb20sIDApLFxuXHRcdFx0dG8gPSBnZXRJbmRleChvcHRzLnRvLCBsZW5ndGggLSAxKTtcblxuXHRcdGlmIChmcm9tID4gdG8pIHtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0ZnJvbSAtPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdG1wID0gZnJvbTtcblx0XHRcdFx0ZnJvbSA9IHRvO1xuXHRcdFx0XHR0byA9IHRtcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKC9eKD86YXN5bW1ldHJpY3xjb250aW51b3VzKSQvLnRlc3QodHlwZSkpIHtcblx0XHRcdHZhciBhc3ltbWV0cmljID0gdHlwZSA9PT0gJ2FzeW1tZXRyaWMnLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbixcblx0XHRcdFx0YW1vdW50ID0gdG8gLSBmcm9tICsgMSxcblx0XHRcdFx0biA9IGFtb3VudCAtIDEsXG5cdFx0XHRcdHBhZGRpbmcgPSBsb29wID8gbWluKGFtb3VudCwgNCkgOiAxLFxuXHRcdFx0XHRwYWRkaW5nTGVmdCA9IHBhZGRpbmcsXG5cdFx0XHRcdHBhZGRpbmdSaWdodCA9IHBhZGRpbmcsXG5cdFx0XHRcdGtub3RzID0gW107XG5cdFx0XHRpZiAoIWNsb3NlZCkge1xuXHRcdFx0XHRwYWRkaW5nTGVmdCA9IG1pbigxLCBmcm9tKTtcblx0XHRcdFx0cGFkZGluZ1JpZ2h0ID0gbWluKDEsIGxlbmd0aCAtIHRvIC0gMSk7XG5cdFx0XHR9XG5cdFx0XHRuICs9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuXHRcdFx0aWYgKG4gPD0gMSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGogPSBmcm9tIC0gcGFkZGluZ0xlZnQ7IGkgPD0gbjsgaSsrLCBqKyspIHtcblx0XHRcdFx0a25vdHNbaV0gPSBzZWdtZW50c1soaiA8IDAgPyBqICsgbGVuZ3RoIDogaikgJSBsZW5ndGhdLl9wb2ludDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHggPSBrbm90c1swXS5feCArIDIgKiBrbm90c1sxXS5feCxcblx0XHRcdFx0eSA9IGtub3RzWzBdLl95ICsgMiAqIGtub3RzWzFdLl95LFxuXHRcdFx0XHRmID0gMixcblx0XHRcdFx0bl8xID0gbiAtIDEsXG5cdFx0XHRcdHJ4ID0gW3hdLFxuXHRcdFx0XHRyeSA9IFt5XSxcblx0XHRcdFx0cmYgPSBbZl0sXG5cdFx0XHRcdHB4ID0gW10sXG5cdFx0XHRcdHB5ID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgaW50ZXJuYWwgPSBpIDwgbl8xLFxuXHRcdFx0XHRcdGEgPSBpbnRlcm5hbCA/IDEgOiBhc3ltbWV0cmljID8gMSA6IDIsXG5cdFx0XHRcdFx0YiA9IGludGVybmFsID8gNCA6IGFzeW1tZXRyaWMgPyAyIDogNyxcblx0XHRcdFx0XHR1ID0gaW50ZXJuYWwgPyA0IDogYXN5bW1ldHJpYyA/IDMgOiA4LFxuXHRcdFx0XHRcdHYgPSBpbnRlcm5hbCA/IDIgOiBhc3ltbWV0cmljID8gMCA6IDEsXG5cdFx0XHRcdFx0bSA9IGEgLyBmO1xuXHRcdFx0XHRmID0gcmZbaV0gPSBiIC0gbTtcblx0XHRcdFx0eCA9IHJ4W2ldID0gdSAqIGtub3RzW2ldLl94ICsgdiAqIGtub3RzW2kgKyAxXS5feCAtIG0gKiB4O1xuXHRcdFx0XHR5ID0gcnlbaV0gPSB1ICoga25vdHNbaV0uX3kgKyB2ICoga25vdHNbaSArIDFdLl95IC0gbSAqIHk7XG5cdFx0XHR9XG5cblx0XHRcdHB4W25fMV0gPSByeFtuXzFdIC8gcmZbbl8xXTtcblx0XHRcdHB5W25fMV0gPSByeVtuXzFdIC8gcmZbbl8xXTtcblx0XHRcdGZvciAodmFyIGkgPSBuIC0gMjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0cHhbaV0gPSAocnhbaV0gLSBweFtpICsgMV0pIC8gcmZbaV07XG5cdFx0XHRcdHB5W2ldID0gKHJ5W2ldIC0gcHlbaSArIDFdKSAvIHJmW2ldO1xuXHRcdFx0fVxuXHRcdFx0cHhbbl0gPSAoMyAqIGtub3RzW25dLl94IC0gcHhbbl8xXSkgLyAyO1xuXHRcdFx0cHlbbl0gPSAoMyAqIGtub3RzW25dLl95IC0gcHlbbl8xXSkgLyAyO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gcGFkZGluZ0xlZnQsIG1heCA9IG4gLSBwYWRkaW5nUmlnaHQsIGogPSBmcm9tO1xuXHRcdFx0XHRcdGkgPD0gbWF4OyBpKyssIGorKykge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ogPCAwID8gaiArIGxlbmd0aCA6IGpdLFxuXHRcdFx0XHRcdHB0ID0gc2VnbWVudC5fcG9pbnQsXG5cdFx0XHRcdFx0aHggPSBweFtpXSAtIHB0Ll94LFxuXHRcdFx0XHRcdGh5ID0gcHlbaV0gLSBwdC5feTtcblx0XHRcdFx0aWYgKGxvb3AgfHwgaSA8IG1heClcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZU91dChoeCwgaHkpO1xuXHRcdFx0XHRpZiAobG9vcCB8fCBpID4gcGFkZGluZ0xlZnQpXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbigtaHgsIC1oeSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcblx0XHRcdFx0c2VnbWVudHNbaSA8IDAgPyBpICsgbGVuZ3RoIDogaV0uc21vb3RoKG9wdHMsXG5cdFx0XHRcdFx0XHQhbG9vcCAmJiBpID09PSBmcm9tLCAhbG9vcCAmJiBpID09PSB0byk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHRvU2hhcGU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdGlmICghdGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0dG9wQ2VudGVyO1xuXG5cdFx0ZnVuY3Rpb24gaXNDb2xsaW5lYXIoaSwgaikge1xuXHRcdFx0dmFyIHNlZzEgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VnMiA9IHNlZzEuZ2V0TmV4dCgpLFxuXHRcdFx0XHRzZWczID0gc2VnbWVudHNbal0sXG5cdFx0XHRcdHNlZzQgPSBzZWczLmdldE5leHQoKTtcblx0XHRcdHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWczLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnNC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNDb2xsaW5lYXIoXG5cdFx0XHRcdFx0XHRzZWc0Ll9wb2ludC5zdWJ0cmFjdChzZWczLl9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzT3J0aG9nb25hbChpKSB7XG5cdFx0XHR2YXIgc2VnMiA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcxID0gc2VnMi5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRzZWczID0gc2VnMi5nZXROZXh0KCk7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzT3J0aG9nb25hbChcblx0XHRcdFx0XHRcdHNlZzMuX3BvaW50LnN1YnRyYWN0KHNlZzIuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNBcmMoaSkge1xuXHRcdFx0dmFyIHNlZzEgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VnMiA9IHNlZzEuZ2V0TmV4dCgpLFxuXHRcdFx0XHRoYW5kbGUxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRoYW5kbGUyID0gc2VnMi5faGFuZGxlSW4sXG5cdFx0XHRcdGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2O1xuXHRcdFx0aWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG5cdFx0XHRcdHZhciBwdDEgPSBzZWcxLl9wb2ludCxcblx0XHRcdFx0XHRwdDIgPSBzZWcyLl9wb2ludCxcblx0XHRcdFx0XHRjb3JuZXIgPSBuZXcgTGluZShwdDEsIGhhbmRsZTEsIHRydWUpLmludGVyc2VjdChcblx0XHRcdFx0XHRcdFx0bmV3IExpbmUocHQyLCBoYW5kbGUyLCB0cnVlKSwgdHJ1ZSk7XG5cdFx0XHRcdHJldHVybiBjb3JuZXIgJiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUxLmdldExlbmd0aCgpIC9cblx0XHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChwdDEpLmdldExlbmd0aCgpIC0ga2FwcGEpXG5cdFx0XHRcdFx0JiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUyLmdldExlbmd0aCgpIC9cblx0XHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChwdDIpLmdldExlbmd0aCgpIC0ga2FwcGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERpc3RhbmNlKGksIGopIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5fcG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudHNbal0uX3BvaW50KTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzSGFuZGxlcygpICYmIHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0NvbGxpbmVhcigwLCAyKSAmJiBpc0NvbGxpbmVhcigxLCAzKSAmJiBpc09ydGhvZ29uYWwoMSkpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgMyksIGdldERpc3RhbmNlKDAsIDEpKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludC5hZGQoc2VnbWVudHNbMl0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDggJiYgaXNBcmMoMCkgJiYgaXNBcmMoMikgJiYgaXNBcmMoNClcblx0XHRcdFx0JiYgaXNBcmMoNikgJiYgaXNDb2xsaW5lYXIoMSwgNSkgJiYgaXNDb2xsaW5lYXIoMywgNykpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMSwgNiksIGdldERpc3RhbmNlKDAsIDMpKTtcblx0XHRcdHJhZGl1cyA9IHNpemUuc3VidHJhY3QobmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgNyksXG5cdFx0XHRcdFx0Z2V0RGlzdGFuY2UoMSwgMikpKS5kaXZpZGUoMik7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1szXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzRdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQXJjKDApICYmIGlzQXJjKDEpICYmIGlzQXJjKDIpICYmIGlzQXJjKDMpKSB7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhnZXREaXN0YW5jZSgwLCAyKSAtIGdldERpc3RhbmNlKDEsIDMpKSkge1xuXHRcdFx0XHR0eXBlID0gU2hhcGUuQ2lyY2xlO1xuXHRcdFx0XHRyYWRpdXMgPSBnZXREaXN0YW5jZSgwLCAyKSAvIDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gU2hhcGUuRWxsaXBzZTtcblx0XHRcdFx0cmFkaXVzID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMiwgMCkgLyAyLCBnZXREaXN0YW5jZSgzLCAxKSAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50O1xuXHRcdH1cblxuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcblx0XHRcdFx0c2hhcGUgPSBuZXcgdHlwZSh7XG5cdFx0XHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0c2hhcGUuY29weUF0dHJpYnV0ZXModGhpcywgdHJ1ZSk7XG5cdFx0XHRzaGFwZS5fbWF0cml4LnByZXBlbmQodGhpcy5fbWF0cml4KTtcblx0XHRcdHNoYXBlLnJvdGF0ZSh0b3BDZW50ZXIuc3VidHJhY3QoY2VudGVyKS5nZXRBbmdsZSgpICsgOTApO1xuXHRcdFx0aWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydClcblx0XHRcdFx0c2hhcGUuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRyZXR1cm4gc2hhcGU7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHRvUGF0aDogJyNjbG9uZScsXG5cblx0Y29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShwYXRoKSB7XG5cdFx0aWYgKCFwYXRoIHx8IHBhdGggaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRyZXR1cm4gY29tcGFyZS5iYXNlLmNhbGwodGhpcywgcGF0aCk7XG5cdFx0dmFyIGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHBhdGguZ2V0Q3VydmVzKCksXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gY3VydmVzMi5sZW5ndGg7XG5cdFx0aWYgKCFsZW5ndGgxIHx8ICFsZW5ndGgyKSB7XG5cdFx0XHRyZXR1cm4gbGVuZ3RoMSA9PSBsZW5ndGgyO1xuXHRcdH1cblx0XHR2YXIgdjEgPSBjdXJ2ZXMxWzBdLmdldFZhbHVlcygpLFxuXHRcdFx0dmFsdWVzMiA9IFtdLFxuXHRcdFx0cG9zMSA9IDAsIHBvczIsXG5cdFx0XHRlbmQxID0gMCwgZW5kMjtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuXHRcdFx0dmFyIHYyID0gY3VydmVzMltpXS5nZXRWYWx1ZXMoKTtcblx0XHRcdHZhbHVlczIucHVzaCh2Mik7XG5cdFx0XHR2YXIgb3ZlcmxhcHMgPSBDdXJ2ZS5nZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdHBvczIgPSAhaSAmJiBvdmVybGFwc1swXVswXSA+IDAgPyBsZW5ndGgyIC0gMSA6IGk7XG5cdFx0XHRcdGVuZDIgPSBvdmVybGFwc1swXVsxXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRcdGVwc2lsb24gPSAxZS04LFxuXHRcdFx0djIgPSB2YWx1ZXMyW3BvczJdLFxuXHRcdFx0c3RhcnQyO1xuXHRcdHdoaWxlICh2MSAmJiB2Mikge1xuXHRcdFx0dmFyIG92ZXJsYXBzID0gQ3VydmUuZ2V0T3ZlcmxhcHModjEsIHYyKTtcblx0XHRcdGlmIChvdmVybGFwcykge1xuXHRcdFx0XHR2YXIgdDEgPSBvdmVybGFwc1swXVswXTtcblx0XHRcdFx0aWYgKGFicyh0MSAtIGVuZDEpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRcdGVuZDEgPSBvdmVybGFwc1sxXVswXTtcblx0XHRcdFx0XHRpZiAoZW5kMSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0djEgPSArK3BvczEgPCBsZW5ndGgxID8gY3VydmVzMVtwb3MxXS5nZXRWYWx1ZXMoKSA6IG51bGw7XG5cdFx0XHRcdFx0XHRlbmQxID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIHQyID0gb3ZlcmxhcHNbMF1bMV07XG5cdFx0XHRcdFx0aWYgKGFicyh0MiAtIGVuZDIpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRcdFx0aWYgKCFzdGFydDIpXG5cdFx0XHRcdFx0XHRcdHN0YXJ0MiA9IFtwb3MyLCB0Ml07XG5cdFx0XHRcdFx0XHRlbmQyID0gb3ZlcmxhcHNbMV1bMV07XG5cdFx0XHRcdFx0XHRpZiAoZW5kMiA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoKytwb3MyID49IGxlbmd0aDIpXG5cdFx0XHRcdFx0XHRcdFx0cG9zMiA9IDA7XG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVzMltwb3MyXSB8fCBjdXJ2ZXMyW3BvczJdLmdldFZhbHVlcygpO1xuXHRcdFx0XHRcdFx0XHRlbmQyID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdjEpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHN0YXJ0MlswXSA9PT0gcG9zMiAmJiBzdGFydDJbMV0gPT09IGVuZDI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0am9pbiwgY2FwLCBtaXRlckxpbWl0LFxuXHRcdFx0YXJlYSwgbG9jLCByZXMsXG5cdFx0XHRoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGl0Q3VydmVzID0gb3B0aW9ucy5jdXJ2ZXMsXG5cdFx0XHRzdHJva2VSYWRpdXMgPSBoaXRTdHJva2Vcblx0XHRcdFx0XHQ/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyXG5cdFx0XHRcdFx0OiBoaXRGaWxsICYmIG9wdGlvbnMudG9sZXJhbmNlID4gMCB8fCBoaXRDdXJ2ZXNcblx0XHRcdFx0XHRcdD8gMCA6IG51bGw7XG5cdFx0aWYgKHN0cm9rZVJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKHN0cm9rZVJhZGl1cyA+IDApIHtcblx0XHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKTtcblx0XHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCk7XG5cdFx0XHRcdG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdHN0cm9rZVBhZGRpbmcgPSBzdHJva2VQYWRkaW5nLmFkZChcblx0XHRcdFx0XHRQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cywgc3Ryb2tlTWF0cml4KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqb2luID0gY2FwID0gJ3JvdW5kJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0Nsb3NlRW5vdWdoKHB0LCBwYWRkaW5nKSB7XG5cdFx0XHRyZXR1cm4gcG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHB0LCBuYW1lKSB7XG5cdFx0XHRpZiAoIW9wdGlvbnMuc2VsZWN0ZWQgfHwgcHQuaXNTZWxlY3RlZCgpKSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuXHRcdFx0XHRpZiAocHQgIT09IGFuY2hvcilcblx0XHRcdFx0XHRwdCA9IHB0LmFkZChhbmNob3IpO1xuXHRcdFx0XHRpZiAoaXNDbG9zZUVub3VnaChwdCwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG5cdFx0XHRcdFx0XHRzZWdtZW50OiBzZWcsXG5cdFx0XHRcdFx0XHRwb2ludDogcHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50cyhzZWcsIGVuZHMpIHtcblx0XHRcdHJldHVybiAoZW5kcyB8fCBvcHRpb25zLnNlZ21lbnRzKVxuXHRcdFx0XHQmJiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5fcG9pbnQsICdzZWdtZW50Jylcblx0XHRcdFx0fHwgKCFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcykgJiYgKFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVJbiwgJ2hhbmRsZS1pbicpIHx8XG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZU91dCwgJ2hhbmRsZS1vdXQnKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVG9BcmVhKHBvaW50KSB7XG5cdFx0XHRhcmVhLmFkZChwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcblx0XHRcdHZhciBpc0pvaW4gPSBjbG9zZWQgfHwgc2VnbWVudC5faW5kZXggPiAwXG5cdFx0XHRcdFx0JiYgc2VnbWVudC5faW5kZXggPCBudW1TZWdtZW50cyAtIDE7XG5cdFx0XHRpZiAoKGlzSm9pbiA/IGpvaW4gOiBjYXApID09PSAncm91bmQnKSB7XG5cdFx0XHRcdHJldHVybiBpc0Nsb3NlRW5vdWdoKHNlZ21lbnQuX3BvaW50LCBzdHJva2VQYWRkaW5nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFyZWEgPSBuZXcgUGF0aCh7IGludGVybmFsOiB0cnVlLCBjbG9zZWQ6IHRydWUgfSk7XG5cdFx0XHRcdGlmIChpc0pvaW4pIHtcblx0XHRcdFx0XHRpZiAoIXNlZ21lbnQuaXNTbW9vdGgoKSkge1xuXHRcdFx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHN0cm9rZVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ICAgbWl0ZXJMaW1pdCwgbnVsbCwgc3Ryb2tlTWF0cml4LCBhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChjYXAgPT09ICdzcXVhcmUnKSB7XG5cdFx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgc3Ryb2tlUmFkaXVzLCBudWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHZhciBsb2M7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZWEuY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdFx0XHR8fCAobG9jID0gYXJlYS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpKVxuXHRcdFx0XHRcdFx0XHQmJiBpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCB0b2xlcmFuY2VQYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmVuZHMgJiYgIW9wdGlvbnMuc2VnbWVudHMgJiYgIWNsb3NlZCkge1xuXHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1swXSwgdHJ1ZSlcblx0XHRcdFx0XHR8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKVxuXHRcdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW2ldKSlcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRpZiAoc3Ryb2tlUmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jKSB7XG5cdFx0XHRcdHZhciB0aW1lID0gbG9jLmdldFRpbWUoKTtcblx0XHRcdFx0aWYgKHRpbWUgPT09IDAgfHwgdGltZSA9PT0gMSAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0XHRpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSlcblx0XHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFsb2MgJiYgam9pbiA9PT0gJ21pdGVyJyAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdFx0XHRpZiAocG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudC5fcG9pbnQpXG5cdFx0XHRcdFx0XHRcdDw9IG1pdGVyTGltaXQgKiBzdHJva2VSYWRpdXNcblx0XHRcdFx0XHRcdFx0JiYgY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpKSB7XG5cdFx0XHRcdFx0XHRsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICFsb2MgJiYgaGl0RmlsbCAmJiB0aGlzLl9jb250YWlucyhwb2ludClcblx0XHRcdFx0fHwgbG9jICYmICFoaXRTdHJva2UgJiYgIWhpdEN1cnZlc1xuXHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpXG5cdFx0XHRcdFx0OiBsb2Ncblx0XHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdjdXJ2ZScsIHRoaXMsIHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IGxvYyxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGxvYy5nZXRQb2ludCgpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHR9XG5cbn0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQob2Zmc2V0KTtcblx0XHRcdHJldHVybiBsb2MgJiYgbG9jW25hbWVdKCk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldExvY2F0aW9uT2YocG9pbnQpO1xuXHRcdFx0aWYgKGxvYylcblx0XHRcdFx0cmV0dXJuIGxvYztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldE9mZnNldCgpIDogbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdGFydCA9IGxlbmd0aCxcblx0XHRcdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdFx0bGVuZ3RoICs9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0XHRpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gc3RhcnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VydmVzLmxlbmd0aCA+IDAgJiYgb2Zmc2V0IDw9IHRoaXMuZ2V0TGVuZ3RoKCkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAob2Zmc2V0ICYmIG9mZnNldC5nZXRQYXRoICYmIG9mZnNldC5nZXRQYXRoKCkgPT09IHRoaXMpIHtcblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGRyYXdIYW5kbGVzKGN0eCwgc2VnbWVudHMsIG1hdHJpeCwgc2l6ZSkge1xuXHRcdHZhciBoYWxmID0gc2l6ZSAvIDIsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRwWCwgcFk7XG5cblx0XHRmdW5jdGlvbiBkcmF3SGFuZGxlKGluZGV4KSB7XG5cdFx0XHR2YXIgaFggPSBjb29yZHNbaW5kZXhdLFxuXHRcdFx0XHRoWSA9IGNvb3Jkc1tpbmRleCArIDFdO1xuXHRcdFx0aWYgKHBYICE9IGhYIHx8IHBZICE9IGhZKSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhwWCwgcFkpO1xuXHRcdFx0XHRjdHgubGluZVRvKGhYLCBoWSk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKGhYLCBoWSwgaGFsZiwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWxlY3Rpb24gPSBzZWdtZW50Ll9zZWxlY3Rpb247XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRwWCA9IGNvb3Jkc1swXTtcblx0XHRcdHBZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKHNlbGVjdGlvbiAmIDIpXG5cdFx0XHRcdGRyYXdIYW5kbGUoMik7XG5cdFx0XHRpZiAoc2VsZWN0aW9uICYgNClcblx0XHRcdFx0ZHJhd0hhbmRsZSg0KTtcblx0XHRcdGN0eC5maWxsUmVjdChwWCAtIGhhbGYsIHBZIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG5cdFx0XHRpZiAoIShzZWxlY3Rpb24gJiAxKSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiArIDEsIHBZIC0gaGFsZiArIDEsIHNpemUgLSAyLCBzaXplIC0gMik7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcblx0XHRcdFx0Y3VyWCA9IHBvaW50Ll94O1xuXHRcdFx0XHRjdXJZID0gcG9pbnQuX3k7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdFx0XHRpblggPSBjdXJYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRcdGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuXHRcdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcblx0XHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE9mZnNldChpKSB7XG5cdFx0XHRcdHJldHVybiBkYXNoQXJyYXlbKChpICUgZGFzaExlbmd0aCkgKyBkYXNoTGVuZ3RoKSAlIGRhc2hMZW5ndGhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcblx0XHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1N0cm9rZSkge1xuXHRcdFx0XHRcdGlmIChkYXNoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0dmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMsIDAuMjUsIDMyLCBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSBmbGF0dGVuZXIubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20gJSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0ZmxhdHRlbmVyLmRyYXdQYXJ0KGN0eCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoZnJvbSwgMCksIE1hdGgubWF4KHRvLCAwKSk7XG5cdFx0XHRcdFx0XHRcdGZyb20gPSB0byArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIG1hdHJpeCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRkcmF3SGFuZGxlcyhjdHgsIHRoaXMuX3NlZ21lbnRzLCBtYXRyaXgsIHBhcGVyLnNldHRpbmdzLmhhbmRsZVNpemUpO1xuXHRcdH1cblx0fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcblx0XHRpZiAoIXNlZ21lbnRzLmxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKSxcblx0XHRcdFx0ZnJvbSA9IGN1cnJlbnQuX3BvaW50LFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dGhyb3VnaCxcblx0XHRcdFx0cGVlayA9IEJhc2UucGVlayhhcmd1bWVudHMpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2socGVlaywgdHJ1ZSksXG5cdFx0XHRcdGNlbnRlciwgZXh0ZW50LCB2ZWN0b3IsIG1hdHJpeDtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dmFyIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdHRocm91Z2ggPSBtaWRkbGUuYWRkKG1pZGRsZS5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoXG5cdFx0XHRcdFx0XHRjbG9ja3dpc2UgPyAtOTAgOiA5MCkpO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLnJlbWFpbihhcmd1bWVudHMpIDw9IDIpIHtcblx0XHRcdFx0dGhyb3VnaCA9IHRvO1xuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdFx0XHRpZiAoaXNaZXJvKHJhZGl1cy53aWR0aCkgfHwgaXNaZXJvKHJhZGl1cy5oZWlnaHQpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bGFyZ2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0cnggPSBhYnMocmFkaXVzLndpZHRoKSxcblx0XHRcdFx0XHRyeSA9IGFicyhyYWRpdXMuaGVpZ2h0KSxcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeCxcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeSxcblx0XHRcdFx0XHR4U3EgPSB4ICogeCxcblx0XHRcdFx0XHR5U3EgPSB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IHNxcnQoeFNxIC8gcnhTcSArIHlTcSAvIHJ5U3EpO1xuXHRcdFx0XHRpZiAoZmFjdG9yID4gMSkge1xuXHRcdFx0XHRcdHJ4ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeSAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcng7XG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmFjdG9yID0gKHJ4U3EgKiByeVNxIC0gcnhTcSAqIHlTcSAtIHJ5U3EgKiB4U3EpIC9cblx0XHRcdFx0XHRcdChyeFNxICogeVNxICsgcnlTcSAqIHhTcSk7XG5cdFx0XHRcdGlmIChhYnMoZmFjdG9yKSA8IDFlLTEyKVxuXHRcdFx0XHRcdGZhY3RvciA9IDA7XG5cdFx0XHRcdGlmIChmYWN0b3IgPCAwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHRjZW50ZXIgPSBuZXcgUG9pbnQocnggKiB5IC8gcnksIC1yeSAqIHggLyByeClcblx0XHRcdFx0XHRcdC5tdWx0aXBseSgobGFyZ2UgPT09IGNsb2Nrd2lzZSA/IC0xIDogMSkgKiBzcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBhYnMoZXh0ZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aHJvdWdoU2lkZSA9PT0gY2VudGVyU2lkZSkge1xuXHRcdFx0XHRcdGV4dGVudCArPSBleHRlbnQgPCAwID8gMzYwIDogLTM2MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGVwc2lsb24gPSAxZS03LFxuXHRcdFx0XHRleHQgPSBhYnMoZXh0ZW50KSxcblx0XHRcdFx0Y291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbCgoZXh0IC0gZXBzaWxvbikgLyA5MCksXG5cdFx0XHRcdGluYyA9IGV4dGVudCAvIGNvdW50LFxuXHRcdFx0XHRoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcblx0XHRcdFx0eiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIHB0ID0gdG8sXG5cdFx0XHRcdFx0b3V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0b3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KG91dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIF9pbiA9IHZlY3Rvci5yb3RhdGUoLTkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRfaW4gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQoX2luKSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHB0LCBfaW4sIG91dCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IHZlY3Rvci5yb3RhdGUoaW5jKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZChzZWdtZW50cyk7XG5cdFx0fSxcblxuXHRcdGxpbmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGFyYW1ldGVyID0gQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1cnZlVG8oY3VycmVudC5hZGQodGhyb3VnaCksIGN1cnJlbnQuYWRkKHRvKSwgcGFyYW1ldGVyKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZTEpLCBjdXJyZW50LmFkZChoYW5kbGUyKSxcblx0XHRcdFx0XHRjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZSksIGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGFyY0J5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuXHRcdFx0XHRwb2ludCA9IGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhCYXNlLnBlZWsoYXJndW1lbnRzKSwgdHJ1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGNsb2Nrd2lzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0dGhpcy5qb2luKHRoaXMsIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBtZXRob2QgPSBvcHRpb25zLmhhbmRsZVxuXHRcdFx0XHQ/ICdnZXRIYW5kbGVCb3VuZHMnXG5cdFx0XHRcdDogb3B0aW9ucy5zdHJva2Vcblx0XHRcdFx0PyAnZ2V0U3Ryb2tlQm91bmRzJ1xuXHRcdFx0XHQ6ICdnZXRCb3VuZHMnO1xuXHRcdHJldHVybiBQYXRoW21ldGhvZF0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcywgbWF0cml4LCBvcHRpb25zKTtcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucywgc3Ryb2tlUGFkZGluZykge1xuXHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdO1xuXHRcdGlmICghZmlyc3QpXG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRwcmV2Q29vcmRzID0gZmlyc3QuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpKSxcblx0XHRcdG1pbiA9IHByZXZDb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gbmV3IEFycmF5KDIpO1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0Q3VydmUuX2FkZEJvdW5kcyhcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2ldLFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaSArIDRdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpICsgMl0sXG5cdFx0XHRcdFx0Y29vcmRzW2ldLFxuXHRcdFx0XHRcdGksIHN0cm9rZVBhZGRpbmcgPyBzdHJva2VQYWRkaW5nW2ldIDogMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRcdH1cblx0XHRcdHZhciB0bXAgPSBwcmV2Q29vcmRzO1xuXHRcdFx0cHJldkNvb3JkcyA9IGNvb3Jkcztcblx0XHRcdGNvb3JkcyA9IHRtcDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoZmlyc3QpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0Z2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3R5bGUgPSBwYXRoLmdldFN0eWxlKCksXG5cdFx0XHRzdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdHN0cm9rZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSxcblx0XHRcdHN0cm9rZU1hdHJpeCA9IHN0cm9rZSAmJiBwYXRoLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSxcblx0XHRcdHN0cm9rZVBhZGRpbmcgPSBzdHJva2UgJiYgUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VXaWR0aCxcblx0XHRcdFx0c3Ryb2tlTWF0cml4KSxcblx0XHRcdGJvdW5kcyA9IFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucyxcblx0XHRcdFx0c3Ryb2tlUGFkZGluZyk7XG5cdFx0aWYgKCFzdHJva2UpXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xuXHRcdHZhciBzdHJva2VSYWRpdXMgPSBzdHJva2VXaWR0aCAvIDIsXG5cdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpLFxuXHRcdFx0am9pbkJvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFNpemUoc3Ryb2tlUGFkZGluZykpO1xuXG5cdFx0ZnVuY3Rpb24gYWRkUG9pbnQocG9pbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy5pbmNsdWRlKHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSb3VuZChzZWdtZW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMudW5pdGUoXG5cdFx0XHRcdFx0am9pbkJvdW5kcy5zZXRDZW50ZXIoc2VnbWVudC5fcG9pbnQudHJhbnNmb3JtKG1hdHJpeCkpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRKb2luKHNlZ21lbnQsIGpvaW4pIHtcblx0XHRcdGlmIChqb2luID09PSAncm91bmQnIHx8IHNlZ21lbnQuaXNTbW9vdGgoKSkge1xuXHRcdFx0XHRhZGRSb3VuZChzZWdtZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCBzdHJva2VSYWRpdXMsIG1pdGVyTGltaXQsXG5cdFx0XHRcdFx0XHRtYXRyaXgsIHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcblx0XHRcdGlmIChjYXAgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCBzdHJva2VSYWRpdXMsIG1hdHJpeCxcblx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSAoY2xvc2VkID8gMCA6IDEpO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcblx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzWzBdLCBqb2luKTtcblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZENhcChzZWdtZW50c1swXSwgY2FwKTtcblx0XHRcdGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRfZ2V0U3Ryb2tlUGFkZGluZzogZnVuY3Rpb24ocmFkaXVzLCBtYXRyaXgpIHtcblx0XHRpZiAoIW1hdHJpeClcblx0XHRcdHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuXHRcdHZhciBob3IgPSBuZXcgUG9pbnQocmFkaXVzLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHZlciA9IG5ldyBQb2ludCgwLCByYWRpdXMpLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0cGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhID0gaG9yLmdldExlbmd0aCgpLFxuXHRcdFx0YiA9IHZlci5nZXRMZW5ndGgoKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKHBoaSksXG5cdFx0XHR0YW4gPSBNYXRoLnRhbihwaGkpLFxuXHRcdFx0dHggPSBNYXRoLmF0YW4yKGIgKiB0YW4sIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4yKGIsIHRhbiAqIGEpO1xuXHRcdHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyArIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuXHRcdFx0XHRNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuXHR9LFxuXG5cdF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgbWF0cml4LFxuXHRcdFx0c3Ryb2tlTWF0cml4LCBhZGRQb2ludCwgaXNBcmVhKSB7XG5cdFx0dmFyIGN1cnZlMiA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcblx0XHRcdGN1cnZlMSA9IGN1cnZlMi5nZXRQcmV2aW91cygpLFxuXHRcdFx0cG9pbnQgPSBjdXJ2ZTIuZ2V0UG9pbnQxKCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0VGltZSgxKS5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHRcdC50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KSxcblx0XHRcdG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXRUaW1lKDApLm11bHRpcGx5KHJhZGl1cylcblx0XHRcdFx0LnRyYW5zZm9ybShzdHJva2VNYXRyaXgpO1xuXHRcdGlmIChub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMikgPCAwKSB7XG5cdFx0XHRub3JtYWwxID0gbm9ybWFsMS5uZWdhdGUoKTtcblx0XHRcdG5vcm1hbDIgPSBub3JtYWwyLm5lZ2F0ZSgpO1xuXHRcdH1cblx0XHRpZiAoaXNBcmVhKVxuXHRcdFx0YWRkUG9pbnQocG9pbnQpO1xuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0aWYgKGpvaW4gPT09ICdtaXRlcicpIHtcblx0XHRcdHZhciBjb3JuZXIgPSBuZXcgTGluZShwb2ludC5hZGQobm9ybWFsMSksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcblx0XHRcdFx0KS5pbnRlcnNlY3QobmV3IExpbmUocG9pbnQuYWRkKG5vcm1hbDIpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlXG5cdFx0XHRcdCksIHRydWUpO1xuXHRcdFx0aWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQgKiByYWRpdXMpIHtcblx0XHRcdFx0YWRkUG9pbnQoY29ybmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDIpKTtcblx0fSxcblxuXHRfYWRkU3F1YXJlQ2FwOiBmdW5jdGlvbihzZWdtZW50LCBjYXAsIHJhZGl1cywgbWF0cml4LCBzdHJva2VNYXRyaXgsXG5cdFx0XHRhZGRQb2ludCwgaXNBcmVhKSB7XG5cdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHRsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCksXG5cdFx0XHRub3JtYWwgPSBsb2MuZ2V0Tm9ybWFsKClcblx0XHRcdFx0XHQubXVsdGlwbHkobG9jLmdldFRpbWUoKSA9PT0gMCA/IHJhZGl1cyA6IC1yYWRpdXMpXG5cdFx0XHRcdFx0LnRyYW5zZm9ybShzdHJva2VNYXRyaXgpO1xuXHRcdGlmIChjYXAgPT09ICdzcXVhcmUnKSB7XG5cdFx0XHRpZiAoaXNBcmVhKSB7XG5cdFx0XHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHRcdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0XHR9XG5cdFx0XHRwb2ludCA9IHBvaW50LmFkZChub3JtYWwucm90YXRlKC05MCkpO1xuXHRcdH1cblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3R5bGUgPSBwYXRoLmdldFN0eWxlKCksXG5cdFx0XHRzdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRqb2luUGFkZGluZztcblx0XHRpZiAoc3Ryb2tlKSB7XG5cdFx0XHR2YXIgc3Ryb2tlTWF0cml4ID0gcGF0aC5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucyksXG5cdFx0XHRcdHN0cm9rZVJhZGl1cyA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyLFxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJylcblx0XHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VDYXAoKSA9PT0gJ3NxdWFyZScpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBNYXRoLm1heChqb2luUmFkaXVzLCBzdHJva2VSYWRpdXMgKiBNYXRoLlNRUlQyKTtcblx0XHRcdHN0cm9rZVBhZGRpbmcgPSBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdGpvaW5QYWRkaW5nID0gUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhqb2luUmFkaXVzLCBzdHJva2VNYXRyaXgpO1xuXHRcdH1cblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0eDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuXHRcdFx0XHR2YXIgcGFkZGluZyA9ICFqID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuXHRcdFx0XHRcdHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmdbMF0gOiAwLFxuXHRcdFx0XHRcdHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gOiAwLFxuXHRcdFx0XHRcdHggPSBjb29yZHNbal0sXG5cdFx0XHRcdFx0eSA9IGNvb3Jkc1tqICsgMV0sXG5cdFx0XHRcdFx0eG4gPSB4IC0gcGFkZGluZ1gsXG5cdFx0XHRcdFx0eHggPSB4ICsgcGFkZGluZ1gsXG5cdFx0XHRcdFx0eW4gPSB5IC0gcGFkZGluZ1ksXG5cdFx0XHRcdFx0eXggPSB5ICsgcGFkZGluZ1k7XG5cdFx0XHRcdGlmICh4biA8IHgxKSB4MSA9IHhuO1xuXHRcdFx0XHRpZiAoeHggPiB4MikgeDIgPSB4eDtcblx0XHRcdFx0aWYgKHluIDwgeTEpIHkxID0geW47XG5cdFx0XHRcdGlmICh5eCA+IHkyKSB5MiA9IHl4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9XG59fSk7XG5cblBhdGguaW5qZWN0KHsgc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRlbGxpcHNlU2VnbWVudHMgPSBbXG5cdFx0XHRuZXcgU2VnbWVudChbLTEsIDBdLCBbMCwga2FwcGEgXSwgWzAsIC1rYXBwYV0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIC0xXSwgWy1rYXBwYSwgMF0sIFtrYXBwYSwgMCBdKSxcblx0XHRcdG5ldyBTZWdtZW50KFsxLCAwXSwgWzAsIC1rYXBwYV0sIFswLCBrYXBwYSBdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAxXSwgW2thcHBhLCAwIF0sIFsta2FwcGEsIDBdKVxuXHRcdF07XG5cblx0ZnVuY3Rpb24gY3JlYXRlUGF0aChzZWdtZW50cywgY2xvc2VkLCBhcmdzKSB7XG5cdFx0dmFyIHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcblx0XHRcdHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdHBhdGguX2FkZChzZWdtZW50cyk7XG5cdFx0cGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHJldHVybiBwYXRoLnNldChwcm9wcywgeyBpbnNlcnQ6IHRydWUgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IGVsbGlwc2VTZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoXG5cdFx0XHRcdHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLm11bHRpcGx5KHJhZGl1cyksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdExpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoW1xuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpKSxcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJykpXG5cdFx0XHRdLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnLCAwLFxuXHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG5cdFx0XHRcdHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuXHRcdFx0XHR0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG5cdFx0XHRcdGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcblx0XHRcdFx0c2VnbWVudHM7XG5cdFx0XHRpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ciksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIpXG5cdFx0XHRcdF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGh4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRoeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Um91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0T3ZhbDogJyNFbGxpcHNlJyxcblxuXHRcdEFyYzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndGhyb3VnaCcpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpLFxuXHRcdFx0XHRwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oZnJvbSk7XG5cdFx0XHRwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcblx0XHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdFx0fSxcblxuXHRcdFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHNpZGVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAnc2lkZXMnKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBzaWRlcyxcblx0XHRcdFx0dGhyZWUgPSBzaWRlcyAlIDMgPT09IDAsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuXHRcdFx0XHRvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcblx0XHRcdFx0XHR2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0U3RhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdwb2ludHMnKSAqIDIsXG5cdFx0XHRcdHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMxJyksXG5cdFx0XHRcdHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMyJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBwb2ludHMsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSlcblx0XHRcdFx0XHRcdC5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMpIHtcblx0XHR2YXIgbGlzdCA9IGl0ZW1zLFxuXHRcdFx0Zmlyc3QgPSBsaXN0WzBdO1xuXHRcdGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3RbMF0gPT09ICdudW1iZXInKVxuXHRcdFx0bGlzdCA9IFtsaXN0XTtcblx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHRcdGlmIChsaXN0ID09PSBpdGVtcyAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBQYXRoKSlcblx0XHRcdFx0bGlzdCA9IEJhc2Uuc2xpY2UobGlzdCk7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuXHRcdFx0XHRsaXN0W2ldID0gbmV3IFBhdGgoeyBzZWdtZW50czogaXRlbSwgaW5zZXJ0OiBmYWxzZSB9KTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHRsaXN0LnNwbGljZS5hcHBseShsaXN0LCBbaSwgMV0uY29uY2F0KGl0ZW0ucmVtb3ZlQ2hpbGRyZW4oKSkpO1xuXHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBsaXN0KTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShvcHRpb25zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcGF0aCA9IGNoaWxkcmVuW2ldLnJlZHVjZShvcHRpb25zKTtcblx0XHRcdGlmIChwYXRoLmlzRW1wdHkoKSlcblx0XHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0aWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdHZhciBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiByZWR1Y2UuYmFzZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKCFjaGlsZHJlbltpXS5fY2xvc2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHNldENsb3NlZDogZnVuY3Rpb24oY2xvc2VkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuW2ldLnNldENsb3NlZChjbG9zZWQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0TGFzdFNlZ21lbnQoKTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0Y3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjdXJ2ZXMucHVzaC5hcHBseShjdXJ2ZXMsIGNoaWxkcmVuW2ldLmdldEN1cnZlcygpKTtcblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsZW5ndGggKz0gY2hpbGRyZW5baV0uZ2V0TGVuZ3RoKCk7XG5cdFx0cmV0dXJuIGxlbmd0aDtcblx0fSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cGF0aHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdHBhdGhzLnB1c2goY2hpbGQuZ2V0UGF0aERhdGEoX21hdHJpeCAmJiAhbXguaXNJZGVudGl0eSgpXG5cdFx0XHRcdFx0PyBfbWF0cml4LmFwcGVuZGVkKG14KSA6IF9tYXRyaXgsIF9wcmVjaXNpb24pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGhzLmpvaW4oJycpO1xuXHR9LFxuXG5cdF9oaXRUZXN0Q2hpbGRyZW46IGZ1bmN0aW9uIF9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcblx0XHRyZXR1cm4gX2hpdFRlc3RDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgcG9pbnQsXG5cdFx0XHRcdG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCcgPyBvcHRpb25zXG5cdFx0XHRcdFx0OiBCYXNlLnNldCh7fSwgb3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KSxcblx0XHRcdFx0dmlld01hdHJpeCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4ubGVuZ3RoKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXG5cdFx0aWYgKCFwYXJhbS5jbGlwKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0RmlsbFJ1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2VsZWN0aW9uSXRlbXMpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdGlmICghc2VsZWN0aW9uSXRlbXNbY2hpbGQuX2lkXSkge1xuXHRcdFx0XHRjaGlsZC5fZHJhd1NlbGVjdGVkKGN0eCwgbXguaXNJZGVudGl0eSgpID8gbWF0cml4XG5cdFx0XHRcdFx0XHQ6IG1hdHJpeC5hcHBlbmRlZChteCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcblx0XHRpZiAoY2hlY2sgJiYgIWNoaWxkcmVuLmxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiBCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsXG5cdFx0XHQnYXJjVG8nLCAnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLFxuXHRcdFx0J2FyY0J5J10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdG1vdmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdFx0cGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdDogbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0XHR0aGlzLmFkZENoaWxkKHBhdGgpO1xuXHRcdFx0XHRwYXRoLm1vdmVUby5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKSxcblx0XHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMubW92ZVRvKGxhc3QgPyBwb2ludC5hZGQobGFzdC5fcG9pbnQpIDogcG9pbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKHRvbGVyYW5jZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSwgQmFzZS5lYWNoKFsncmV2ZXJzZScsICdmbGF0dGVuJywgJ3NpbXBsaWZ5JywgJ3Ntb290aCddLCBmdW5jdGlvbihrZXkpIHtcblx0dGhpc1trZXldID0gZnVuY3Rpb24ocGFyYW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHJlcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cmVzID0gY2hpbGRyZW5baV1ba2V5XShwYXJhbSkgfHwgcmVzO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xufSwge30pKTtcblxuUGF0aEl0ZW0uaW5qZWN0KG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdG9wZXJhdG9ycyA9IHtcblx0XHRcdHVuaXRlOiAgICAgeyAnMSc6IHRydWUsICcyJzogdHJ1ZSB9LFxuXHRcdFx0aW50ZXJzZWN0OiB7ICcyJzogdHJ1ZSB9LFxuXHRcdFx0c3VidHJhY3Q6ICB7ICcxJzogdHJ1ZSB9LFxuXHRcdFx0ZXhjbHVkZTogICB7ICcxJzogdHJ1ZSwgJy0xJzogdHJ1ZSB9XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBwcmVwYXJlUGF0aChwYXRoLCByZXNvbHZlKSB7XG5cdFx0dmFyIHJlcyA9IHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSh7IHNpbXBsaWZ5OiB0cnVlIH0pXG5cdFx0XHRcdC50cmFuc2Zvcm0obnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHJlc29sdmVcblx0XHRcdFx0PyByZXMucmVzb2x2ZUNyb3NzaW5ncygpLnJlb3JpZW50KFxuXHRcdFx0XHRcdHJlcy5nZXRGaWxsUnVsZSgpID09PSAnbm9uemVybycsIHRydWUpXG5cdFx0XHRcdDogcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlUmVzdWx0KHBhdGhzLCBzaW1wbGlmeSwgcGF0aDEsIHBhdGgyLCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJlc3VsdC5hZGRDaGlsZHJlbihwYXRocywgdHJ1ZSk7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlZHVjZSh7IHNpbXBsaWZ5OiBzaW1wbGlmeSB9KTtcblx0XHRpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuaW5zZXJ0ID09IGZhbHNlKSkge1xuXHRcdFx0cmVzdWx0Lmluc2VydEFib3ZlKHBhdGgyICYmIHBhdGgxLmlzU2libGluZyhwYXRoMilcblx0XHRcdFx0XHQmJiBwYXRoMS5nZXRJbmRleCgpIDwgcGF0aDIuZ2V0SW5kZXgoKSA/IHBhdGgyIDogcGF0aDEpO1xuXHRcdH1cblx0XHRyZXN1bHQuY29weUF0dHJpYnV0ZXMocGF0aDEsIHRydWUpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFjZUJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24sIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50cmFjZSA9PSBmYWxzZSB8fCBvcHRpb25zLnN0cm9rZSkgJiZcblx0XHRcdFx0L14oc3VidHJhY3R8aW50ZXJzZWN0KSQvLnRlc3Qob3BlcmF0aW9uKSlcblx0XHRcdHJldHVybiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pO1xuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSwgdHJ1ZSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIsIHRydWUpLFxuXHRcdFx0b3BlcmF0b3IgPSBvcGVyYXRvcnNbb3BlcmF0aW9uXTtcblx0XHRvcGVyYXRvcltvcGVyYXRpb25dID0gdHJ1ZTtcblx0XHRpZiAoX3BhdGgyICYmIChvcGVyYXRvci5zdWJ0cmFjdCB8fCBvcGVyYXRvci5leGNsdWRlKVxuXHRcdFx0XHReIChfcGF0aDIuaXNDbG9ja3dpc2UoKSBeIF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0dmFyIGNyb3NzaW5ncyA9IGRpdmlkZUxvY2F0aW9ucyhcblx0XHRcdFx0Q3VydmVMb2NhdGlvbi5leHBhbmQoX3BhdGgxLmdldENyb3NzaW5ncyhfcGF0aDIpKSksXG5cdFx0XHRwYXRoczEgPSBfcGF0aDEuX2NoaWxkcmVuIHx8IFtfcGF0aDFdLFxuXHRcdFx0cGF0aHMyID0gX3BhdGgyICYmIChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKSxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRjdXJ2ZXMgPSBbXSxcblx0XHRcdHBhdGhzO1xuXG5cdFx0ZnVuY3Rpb24gY29sbGVjdChwYXRocykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGggPSBwYXRoc1tpXTtcblx0XHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgcGF0aC5fc2VnbWVudHMpO1xuXHRcdFx0XHRjdXJ2ZXMucHVzaC5hcHBseShjdXJ2ZXMsIHBhdGguZ2V0Q3VydmVzKCkpO1xuXHRcdFx0XHRwYXRoLl9vdmVybGFwc09ubHkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjcm9zc2luZ3MubGVuZ3RoKSB7XG5cdFx0XHRjb2xsZWN0KHBhdGhzMSk7XG5cdFx0XHRpZiAocGF0aHMyKVxuXHRcdFx0XHRjb2xsZWN0KHBhdGhzMik7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNyb3NzaW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cHJvcGFnYXRlV2luZGluZyhjcm9zc2luZ3NbaV0uX3NlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBjdXJ2ZXMsXG5cdFx0XHRcdFx0XHRvcGVyYXRvcik7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRpZiAoIXNlZ21lbnQuX3dpbmRpbmcpIHtcblx0XHRcdFx0XHRwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBjdXJ2ZXMsIG9wZXJhdG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIShpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCkpXG5cdFx0XHRcdFx0c2VnbWVudC5fcGF0aC5fb3ZlcmxhcHNPbmx5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRwYXRocyA9IHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aHMgPSByZW9yaWVudFBhdGhzKFxuXHRcdFx0XHRcdHBhdGhzMiA/IHBhdGhzMS5jb25jYXQocGF0aHMyKSA6IHBhdGhzMS5zbGljZSgpLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0XHRcdHJldHVybiAhIW9wZXJhdG9yW3ddO1xuXHRcdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVSZXN1bHQocGF0aHMsIHRydWUsIHBhdGgxLCBwYXRoMiwgb3B0aW9ucyk7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pIHtcblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuXHRcdFx0X3BhdGgyID0gcHJlcGFyZVBhdGgocGF0aDIpLFxuXHRcdFx0Y3Jvc3NpbmdzID0gX3BhdGgxLmdldENyb3NzaW5ncyhfcGF0aDIpLFxuXHRcdFx0c3VidHJhY3QgPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcsXG5cdFx0XHRkaXZpZGUgPSBvcGVyYXRpb24gPT09ICdkaXZpZGUnLFxuXHRcdFx0YWRkZWQgPSB7fSxcblx0XHRcdHBhdGhzID0gW107XG5cblx0XHRmdW5jdGlvbiBhZGRQYXRoKHBhdGgpIHtcblx0XHRcdGlmICghYWRkZWRbcGF0aC5faWRdICYmIChkaXZpZGUgfHxcblx0XHRcdFx0XHRfcGF0aDIuY29udGFpbnMocGF0aC5nZXRQb2ludEF0KHBhdGguZ2V0TGVuZ3RoKCkgLyAyKSlcblx0XHRcdFx0XHRcdF4gc3VidHJhY3QpKSB7XG5cdFx0XHRcdHBhdGhzLnVuc2hpZnQocGF0aCk7XG5cdFx0XHRcdHJldHVybiBhZGRlZFtwYXRoLl9pZF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSBjcm9zc2luZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBwYXRoID0gY3Jvc3NpbmdzW2ldLnNwbGl0KCk7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRpZiAoYWRkUGF0aChwYXRoKSlcblx0XHRcdFx0XHRwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuXHRcdFx0XHRfcGF0aDEuZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFkZFBhdGgoX3BhdGgxKTtcblx0XHRyZXR1cm4gY3JlYXRlUmVzdWx0KHBhdGhzLCBmYWxzZSwgcGF0aDEsIHBhdGgyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxpbmtJbnRlcnNlY3Rpb25zKGZyb20sIHRvKSB7XG5cdFx0dmFyIHByZXYgPSBmcm9tO1xuXHRcdHdoaWxlIChwcmV2KSB7XG5cdFx0XHRpZiAocHJldiA9PT0gdG8pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXYgPSBwcmV2Ll9wcmV2aW91cztcblx0XHR9XG5cdFx0d2hpbGUgKGZyb20uX25leHQgJiYgZnJvbS5fbmV4dCAhPT0gdG8pXG5cdFx0XHRmcm9tID0gZnJvbS5fbmV4dDtcblx0XHRpZiAoIWZyb20uX25leHQpIHtcblx0XHRcdHdoaWxlICh0by5fcHJldmlvdXMpXG5cdFx0XHRcdHRvID0gdG8uX3ByZXZpb3VzO1xuXHRcdFx0ZnJvbS5fbmV4dCA9IHRvO1xuXHRcdFx0dG8uX3ByZXZpb3VzID0gZnJvbTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjbGVhckN1cnZlSGFuZGxlcyhjdXJ2ZXMpIHtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0Y3VydmVzW2ldLmNsZWFySGFuZGxlcygpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVvcmllbnRQYXRocyhwYXRocywgaXNJbnNpZGUsIGNsb2Nrd2lzZSkge1xuXHRcdHZhciBsZW5ndGggPSBwYXRocyAmJiBwYXRocy5sZW5ndGg7XG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIGxvb2t1cCA9IEJhc2UuZWFjaChwYXRocywgZnVuY3Rpb24gKHBhdGgsIGkpIHtcblx0XHRcdFx0XHR0aGlzW3BhdGguX2lkXSA9IHtcblx0XHRcdFx0XHRcdGNvbnRhaW5lcjogbnVsbCxcblx0XHRcdFx0XHRcdHdpbmRpbmc6IHBhdGguaXNDbG9ja3dpc2UoKSA/IDEgOiAtMSxcblx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSwge30pLFxuXHRcdFx0XHRzb3J0ZWQgPSBwYXRocy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYWJzKGIuZ2V0QXJlYSgpKSAtIGFicyhhLmdldEFyZWEoKSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRmaXJzdCA9IHNvcnRlZFswXTtcblx0XHRcdGlmIChjbG9ja3dpc2UgPT0gbnVsbClcblx0XHRcdFx0Y2xvY2t3aXNlID0gZmlyc3QuaXNDbG9ja3dpc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gc29ydGVkW2ldLFxuXHRcdFx0XHRcdGVudHJ5MSA9IGxvb2t1cFtwYXRoMS5faWRdLFxuXHRcdFx0XHRcdHBvaW50ID0gcGF0aDEuZ2V0SW50ZXJpb3JQb2ludCgpLFxuXHRcdFx0XHRcdGNvbnRhaW5lcldpbmRpbmcgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0dmFyIHBhdGgyID0gc29ydGVkW2pdO1xuXHRcdFx0XHRcdGlmIChwYXRoMi5jb250YWlucyhwb2ludCkpIHtcblx0XHRcdFx0XHRcdHZhciBlbnRyeTIgPSBsb29rdXBbcGF0aDIuX2lkXTtcblx0XHRcdFx0XHRcdGNvbnRhaW5lcldpbmRpbmcgPSBlbnRyeTIud2luZGluZztcblx0XHRcdFx0XHRcdGVudHJ5MS53aW5kaW5nICs9IGNvbnRhaW5lcldpbmRpbmc7XG5cdFx0XHRcdFx0XHRlbnRyeTEuY29udGFpbmVyID0gZW50cnkyLmV4Y2x1ZGUgPyBlbnRyeTIuY29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdFx0OiBwYXRoMjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNJbnNpZGUoZW50cnkxLndpbmRpbmcpID09PSBpc0luc2lkZShjb250YWluZXJXaW5kaW5nKSkge1xuXHRcdFx0XHRcdGVudHJ5MS5leGNsdWRlID0gdHJ1ZTtcblx0XHRcdFx0XHRwYXRoc1tlbnRyeTEuaW5kZXhdID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY29udGFpbmVyID0gZW50cnkxLmNvbnRhaW5lcjtcblx0XHRcdFx0XHRwYXRoMS5zZXRDbG9ja3dpc2UoY29udGFpbmVyID8gIWNvbnRhaW5lci5pc0Nsb2Nrd2lzZSgpXG5cdFx0XHRcdFx0XHRcdDogY2xvY2t3aXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRmdW5jdGlvbiBkaXZpZGVMb2NhdGlvbnMobG9jYXRpb25zLCBpbmNsdWRlLCBjbGVhckxhdGVyKSB7XG5cdFx0dmFyIHJlc3VsdHMgPSBpbmNsdWRlICYmIFtdLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRjbGVhckhhbmRsZXMgPSBmYWxzZSxcblx0XHRcdGNsZWFyQ3VydmVzID0gY2xlYXJMYXRlciB8fCBbXSxcblx0XHRcdGNsZWFyTG9va3VwID0gY2xlYXJMYXRlciAmJiB7fSxcblx0XHRcdHJlbm9ybWFsaXplTG9jcyxcblx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0SWQoY3VydmUpIHtcblx0XHRcdHJldHVybiBjdXJ2ZS5fcGF0aC5faWQgKyAnLicgKyBjdXJ2ZS5fc2VnbWVudDEuX2luZGV4O1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAoY2xlYXJMYXRlciAmJiBjbGVhckxhdGVyLmxlbmd0aCkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY2xlYXJMYXRlcltpXTtcblx0XHRcdGlmIChjdXJ2ZS5fcGF0aClcblx0XHRcdFx0Y2xlYXJMb29rdXBbZ2V0SWQoY3VydmUpXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcblx0XHRcdFx0dGltZSA9IGxvYy5fdGltZSxcblx0XHRcdFx0b3JpZ1RpbWUgPSB0aW1lLFxuXHRcdFx0XHRleGNsdWRlID0gaW5jbHVkZSAmJiAhaW5jbHVkZShsb2MpLFxuXHRcdFx0XHRjdXJ2ZSA9IGxvYy5fY3VydmUsXG5cdFx0XHRcdHNlZ21lbnQ7XG5cdFx0XHRpZiAoY3VydmUpIHtcblx0XHRcdFx0aWYgKGN1cnZlICE9PSBwcmV2Q3VydmUpIHtcblx0XHRcdFx0XHRjbGVhckhhbmRsZXMgPSAhY3VydmUuaGFzSGFuZGxlcygpXG5cdFx0XHRcdFx0XHRcdHx8IGNsZWFyTG9va3VwICYmIGNsZWFyTG9va3VwW2dldElkKGN1cnZlKV07XG5cdFx0XHRcdFx0cmVub3JtYWxpemVMb2NzID0gW107XG5cdFx0XHRcdFx0cHJldlRpbWUgPSBudWxsO1xuXHRcdFx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXZUaW1lID49IHRNaW4pIHtcblx0XHRcdFx0XHR0aW1lIC89IHByZXZUaW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhjbHVkZSkge1xuXHRcdFx0XHRpZiAocmVub3JtYWxpemVMb2NzKVxuXHRcdFx0XHRcdHJlbm9ybWFsaXplTG9jcy5wdXNoKGxvYyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpbmNsdWRlKSB7XG5cdFx0XHRcdHJlc3VsdHMudW5zaGlmdChsb2MpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlRpbWUgPSBvcmlnVGltZTtcblx0XHRcdGlmICh0aW1lIDwgdE1pbikge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lID4gdE1heCkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5ld0N1cnZlID0gY3VydmUuZGl2aWRlQXRUaW1lKHRpbWUsIHRydWUpO1xuXHRcdFx0XHRpZiAoY2xlYXJIYW5kbGVzKVxuXHRcdFx0XHRcdGNsZWFyQ3VydmVzLnB1c2goY3VydmUsIG5ld0N1cnZlKTtcblx0XHRcdFx0c2VnbWVudCA9IG5ld0N1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IHJlbm9ybWFsaXplTG9jcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdHZhciBsID0gcmVub3JtYWxpemVMb2NzW2pdO1xuXHRcdFx0XHRcdGwuX3RpbWUgPSAobC5fdGltZSAtIHRpbWUpIC8gKDEgLSB0aW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bG9jLl9zZXRTZWdtZW50KHNlZ21lbnQpO1xuXHRcdFx0dmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRkZXN0ID0gbG9jLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRpZiAoaW50ZXIpIHtcblx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMoaW50ZXIsIGRlc3QpO1xuXHRcdFx0XHR2YXIgb3RoZXIgPSBpbnRlcjtcblx0XHRcdFx0d2hpbGUgKG90aGVyKSB7XG5cdFx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMob3RoZXIuX2ludGVyc2VjdGlvbiwgaW50ZXIpO1xuXHRcdFx0XHRcdG90aGVyID0gb3RoZXIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGRlc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghY2xlYXJMYXRlcilcblx0XHRcdGNsZWFyQ3VydmVIYW5kbGVzKGNsZWFyQ3VydmVzKTtcblx0XHRyZXR1cm4gcmVzdWx0cyB8fCBsb2NhdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGRpciwgY2xvc2VkLCBkb250RmxpcCkge1xuXHRcdHZhciBpYSA9IGRpciA/IDEgOiAwLFxuXHRcdFx0aW8gPSBpYSBeIDEsXG5cdFx0XHRwdiA9IFtwb2ludC54LCBwb2ludC55XSxcblx0XHRcdHBhID0gcHZbaWFdLFxuXHRcdFx0cG8gPSBwdltpb10sXG5cdFx0XHR3aW5kaW5nRXBzaWxvbiA9IDFlLTksXG5cdFx0XHRxdWFsaXR5RXBzaWxvbiA9IDFlLTYsXG5cdFx0XHRwYUwgPSBwYSAtIHdpbmRpbmdFcHNpbG9uLFxuXHRcdFx0cGFSID0gcGEgKyB3aW5kaW5nRXBzaWxvbixcblx0XHRcdHdpbmRpbmdMID0gMCxcblx0XHRcdHdpbmRpbmdSID0gMCxcblx0XHRcdHBhdGhXaW5kaW5nTCA9IDAsXG5cdFx0XHRwYXRoV2luZGluZ1IgPSAwLFxuXHRcdFx0b25QYXRoID0gZmFsc2UsXG5cdFx0XHRvbkFueVBhdGggPSBmYWxzZSxcblx0XHRcdHF1YWxpdHkgPSAxLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdHZQcmV2LFxuXHRcdFx0dkNsb3NlO1xuXG5cdFx0ZnVuY3Rpb24gYWRkV2luZGluZyh2KSB7XG5cdFx0XHR2YXIgbzAgPSB2W2lvICsgMF0sXG5cdFx0XHRcdG8zID0gdltpbyArIDZdO1xuXHRcdFx0aWYgKHBvIDwgbWluKG8wLCBvMykgfHwgcG8gPiBtYXgobzAsIG8zKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgYTAgPSB2W2lhICsgMF0sXG5cdFx0XHRcdGExID0gdltpYSArIDJdLFxuXHRcdFx0XHRhMiA9IHZbaWEgKyA0XSxcblx0XHRcdFx0YTMgPSB2W2lhICsgNl07XG5cdFx0XHRpZiAobzAgPT09IG8zKSB7XG5cdFx0XHRcdGlmIChhMCA8IHBhUiAmJiBhMyA+IHBhTCB8fCBhMyA8IHBhUiAmJiBhMCA+IHBhTCkge1xuXHRcdFx0XHRcdG9uUGF0aCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHQgPSAgIHBvID09PSBvMCA/IDBcblx0XHRcdFx0XHQ6IHBvID09PSBvMyA/IDFcblx0XHRcdFx0XHQ6IHBhTCA+IG1heChhMCwgYTEsIGEyLCBhMykgfHwgcGFSIDwgbWluKGEwLCBhMSwgYTIsIGEzKVxuXHRcdFx0XHRcdD8gMVxuXHRcdFx0XHRcdDogQ3VydmUuc29sdmVDdWJpYyh2LCBpbywgcG8sIHJvb3RzLCAwLCAxKSA+IDBcblx0XHRcdFx0XHRcdD8gcm9vdHNbMF1cblx0XHRcdFx0XHRcdDogMSxcblx0XHRcdFx0YSA9ICAgdCA9PT0gMCA/IGEwXG5cdFx0XHRcdFx0OiB0ID09PSAxID8gYTNcblx0XHRcdFx0XHQ6IEN1cnZlLmdldFBvaW50KHYsIHQpW2RpciA/ICd5JyA6ICd4J10sXG5cdFx0XHRcdHdpbmRpbmcgPSBvMCA+IG8zID8gMSA6IC0xLFxuXHRcdFx0XHR3aW5kaW5nUHJldiA9IHZQcmV2W2lvXSA+IHZQcmV2W2lvICsgNl0gPyAxIDogLTEsXG5cdFx0XHRcdGEzUHJldiA9IHZQcmV2W2lhICsgNl07XG5cdFx0XHRpZiAocG8gIT09IG8wKSB7XG5cdFx0XHRcdGlmIChhIDwgcGFMKSB7XG5cdFx0XHRcdFx0cGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYSA+IHBhUikge1xuXHRcdFx0XHRcdHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9uUGF0aCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEgPiBwYSAtIHF1YWxpdHlFcHNpbG9uICYmIGEgPCBwYSArIHF1YWxpdHlFcHNpbG9uKVxuXHRcdFx0XHRcdHF1YWxpdHkgLz0gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh3aW5kaW5nICE9PSB3aW5kaW5nUHJldikge1xuXHRcdFx0XHRcdGlmIChhMCA8IHBhTCkge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhMCA+IHBhUikge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGEwICE9IGEzUHJldikge1xuXHRcdFx0XHRcdGlmIChhM1ByZXYgPCBwYVIgJiYgYSA+IHBhUikge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRvblBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYTNQcmV2ID4gcGFMICYmIGEgPCBwYUwpIHtcblx0XHRcdFx0XHRcdHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0b25QYXRoID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cXVhbGl0eSA9IDA7XG5cdFx0XHR9XG5cdFx0XHR2UHJldiA9IHY7XG5cdFx0XHRyZXR1cm4gIWRvbnRGbGlwICYmIGEgPiBwYUwgJiYgYSA8IHBhUlxuXHRcdFx0XHRcdCYmIEN1cnZlLmdldFRhbmdlbnQodiwgdClbZGlyID8gJ3gnIDogJ3knXSA9PT0gMFxuXHRcdFx0XHRcdCYmIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgIWRpciwgY2xvc2VkLCB0cnVlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVDdXJ2ZSh2KSB7XG5cdFx0XHR2YXIgbzAgPSB2W2lvICsgMF0sXG5cdFx0XHRcdG8xID0gdltpbyArIDJdLFxuXHRcdFx0XHRvMiA9IHZbaW8gKyA0XSxcblx0XHRcdFx0bzMgPSB2W2lvICsgNl07XG5cdFx0XHRpZiAocG8gPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSAmJiBwbyA+PSBtaW4obzAsIG8xLCBvMiwgbzMpKSB7XG5cdFx0XHRcdHZhciBhMCA9IHZbaWEgKyAwXSxcblx0XHRcdFx0XHRhMSA9IHZbaWEgKyAyXSxcblx0XHRcdFx0XHRhMiA9IHZbaWEgKyA0XSxcblx0XHRcdFx0XHRhMyA9IHZbaWEgKyA2XSxcblx0XHRcdFx0XHRtb25vQ3VydmVzID0gcGFMID4gbWF4KGEwLCBhMSwgYTIsIGEzKSB8fFxuXHRcdFx0XHRcdFx0XHRcdCBwYVIgPCBtaW4oYTAsIGExLCBhMiwgYTMpXG5cdFx0XHRcdFx0XHRcdD8gW3ZdIDogQ3VydmUuZ2V0TW9ub0N1cnZlcyh2LCBkaXIpLFxuXHRcdFx0XHRcdHJlcztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtb25vQ3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChyZXMgPSBhZGRXaW5kaW5nKG1vbm9DdXJ2ZXNbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldLFxuXHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRcdHYgPSBjdXJ2ZS5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0cmVzO1xuXHRcdFx0aWYgKCFpIHx8IGN1cnZlc1tpIC0gMV0uX3BhdGggIT09IHBhdGgpIHtcblx0XHRcdFx0dlByZXYgPSBudWxsO1xuXHRcdFx0XHRpZiAoIXBhdGguX2Nsb3NlZCkge1xuXHRcdFx0XHRcdHZDbG9zZSA9IEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRcdFx0cGF0aC5nZXRMYXN0Q3VydmUoKS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdFx0XHRjdXJ2ZS5nZXRTZWdtZW50MSgpLFxuXHRcdFx0XHRcdFx0XHRudWxsLCAhY2xvc2VkKTtcblx0XHRcdFx0XHRpZiAodkNsb3NlW2lvXSAhPT0gdkNsb3NlW2lvICsgNl0pIHtcblx0XHRcdFx0XHRcdHZQcmV2ID0gdkNsb3NlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdlByZXYpIHtcblx0XHRcdFx0XHR2UHJldiA9IHY7XG5cdFx0XHRcdFx0dmFyIHByZXYgPSBwYXRoLmdldExhc3RDdXJ2ZSgpO1xuXHRcdFx0XHRcdHdoaWxlIChwcmV2ICYmIHByZXYgIT09IGN1cnZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdjIgPSBwcmV2LmdldFZhbHVlcygpO1xuXHRcdFx0XHRcdFx0aWYgKHYyW2lvXSAhPT0gdjJbaW8gKyA2XSkge1xuXHRcdFx0XHRcdFx0XHR2UHJldiA9IHYyO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHByZXYgPSBwcmV2LmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZXMgPSBoYW5kbGVDdXJ2ZSh2KSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0aWYgKGkgKyAxID09PSBsIHx8IGN1cnZlc1tpICsgMV0uX3BhdGggIT09IHBhdGgpIHtcblx0XHRcdFx0aWYgKHZDbG9zZSAmJiAocmVzID0gaGFuZGxlQ3VydmUodkNsb3NlKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0aWYgKG9uUGF0aCAmJiAhcGF0aFdpbmRpbmdMICYmICFwYXRoV2luZGluZ1IpIHtcblx0XHRcdFx0XHRwYXRoV2luZGluZ0wgPSBwYXRoV2luZGluZ1IgPSBwYXRoLmlzQ2xvY2t3aXNlKGNsb3NlZCkgXiBkaXJcblx0XHRcdFx0XHRcdFx0PyAxIDogLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2luZGluZ0wgKz0gcGF0aFdpbmRpbmdMO1xuXHRcdFx0XHR3aW5kaW5nUiArPSBwYXRoV2luZGluZ1I7XG5cdFx0XHRcdHBhdGhXaW5kaW5nTCA9IHBhdGhXaW5kaW5nUiA9IDA7XG5cdFx0XHRcdGlmIChvblBhdGgpIHtcblx0XHRcdFx0XHRvbkFueVBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdG9uUGF0aCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZDbG9zZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdpbmRpbmdMID0gYWJzKHdpbmRpbmdMKTtcblx0XHR3aW5kaW5nUiA9IGFicyh3aW5kaW5nUik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpbmRpbmc6IG1heCh3aW5kaW5nTCwgd2luZGluZ1IpLFxuXHRcdFx0d2luZGluZ0w6IHdpbmRpbmdMLFxuXHRcdFx0d2luZGluZ1I6IHdpbmRpbmdSLFxuXHRcdFx0cXVhbGl0eTogcXVhbGl0eSxcblx0XHRcdG9uUGF0aDogb25BbnlQYXRoXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgcGF0aDEsIHBhdGgyLCBjdXJ2ZXMsIG9wZXJhdG9yKSB7XG5cdFx0dmFyIGNoYWluID0gW10sXG5cdFx0XHRzdGFydCA9IHNlZ21lbnQsXG5cdFx0XHR0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHR3aW5kaW5nO1xuXHRcdGRvIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcblx0XHRcdFx0bGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjaGFpbi5wdXNoKHsgc2VnbWVudDogc2VnbWVudCwgY3VydmU6IGN1cnZlLCBsZW5ndGg6IGxlbmd0aCB9KTtcblx0XHRcdHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblx0XHRcdHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcblx0XHR9IHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50Ll9pbnRlcnNlY3Rpb24gJiYgc2VnbWVudCAhPT0gc3RhcnQpO1xuXHRcdHZhciBvZmZzZXRzID0gWzAuNSwgMC4yNSwgMC43NV0sXG5cdFx0XHR3aW5kaW5nID0geyB3aW5kaW5nOiAwLCBxdWFsaXR5OiAtMSB9LFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAmJiB3aW5kaW5nLnF1YWxpdHkgPCAwLjU7IGkrKykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogb2Zmc2V0c1tpXTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBsID0gY2hhaW4ubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IGNoYWluW2pdLFxuXHRcdFx0XHRcdGN1cnZlTGVuZ3RoID0gZW50cnkubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoIDw9IGN1cnZlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGN1cnZlID0gZW50cnkuY3VydmUsXG5cdFx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBwYXRoLl9wYXJlbnQsXG5cdFx0XHRcdFx0XHRvcGVyYW5kID0gcGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogcGF0aCxcblx0XHRcdFx0XHRcdHQgPSBOdW1lcmljYWwuY2xhbXAoY3VydmUuZ2V0VGltZUF0KGxlbmd0aCksIHRNaW4sIHRNYXgpLFxuXHRcdFx0XHRcdFx0cHQgPSBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0KSxcblx0XHRcdFx0XHRcdGRpciA9IGFicyhjdXJ2ZS5nZXRUYW5nZW50QXRUaW1lKHQpLnkpIDwgTWF0aC5TUVJUMV8yO1xuXHRcdFx0XHRcdHZhciB3aW5kID0gIShvcGVyYXRvci5zdWJ0cmFjdCAmJiBwYXRoMiAmJiAoXG5cdFx0XHRcdFx0XHRcdG9wZXJhbmQgPT09IHBhdGgxICYmXG5cdFx0XHRcdFx0XHRcdFx0cGF0aDIuX2dldFdpbmRpbmcocHQsIGRpciwgdHJ1ZSkud2luZGluZyB8fFxuXHRcdFx0XHRcdFx0XHRvcGVyYW5kID09PSBwYXRoMiAmJlxuXHRcdFx0XHRcdFx0XHRcdCFwYXRoMS5fZ2V0V2luZGluZyhwdCwgZGlyLCB0cnVlKS53aW5kaW5nKSlcblx0XHRcdFx0XHRcdFx0PyBnZXRXaW5kaW5nKHB0LCBjdXJ2ZXMsIGRpciwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0OiB7IHdpbmRpbmc6IDAsIHF1YWxpdHk6IDEgfTtcblx0XHRcdFx0XHRpZiAod2luZC5xdWFsaXR5ID4gd2luZGluZy5xdWFsaXR5KVxuXHRcdFx0XHRcdFx0d2luZGluZyA9IHdpbmQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuZ3RoIC09IGN1cnZlTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBqID0gY2hhaW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdGNoYWluW2pdLnNlZ21lbnQuX3dpbmRpbmcgPSB3aW5kaW5nO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSB7XG5cdFx0dmFyIHBhdGhzID0gW10sXG5cdFx0XHRzdGFydHM7XG5cblx0XHRmdW5jdGlvbiBpc1ZhbGlkKHNlZykge1xuXHRcdFx0dmFyIHdpbmRpbmc7XG5cdFx0XHRyZXR1cm4gISEoc2VnICYmICFzZWcuX3Zpc2l0ZWQgJiYgKCFvcGVyYXRvclxuXHRcdFx0XHRcdHx8IG9wZXJhdG9yWyh3aW5kaW5nID0gc2VnLl93aW5kaW5nIHx8IHt9KS53aW5kaW5nXVxuXHRcdFx0XHRcdFx0JiYgIShvcGVyYXRvci51bml0ZSAmJiB3aW5kaW5nLndpbmRpbmcgPT09IDJcblx0XHRcdFx0XHRcdFx0JiYgd2luZGluZy53aW5kaW5nTCAmJiB3aW5kaW5nLndpbmRpbmdSKSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU3RhcnQoc2VnKSB7XG5cdFx0XHRpZiAoc2VnKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChzZWcgPT09IHN0YXJ0c1tpXSlcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdmlzaXRQYXRoKHBhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0c2VnbWVudHNbaV0uX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENyb3NzaW5nU2VnbWVudHMoc2VnbWVudCwgY29sbGVjdFN0YXJ0cykge1xuXHRcdFx0dmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRzdGFydCA9IGludGVyLFxuXHRcdFx0XHRjcm9zc2luZ3MgPSBbXTtcblx0XHRcdGlmIChjb2xsZWN0U3RhcnRzKVxuXHRcdFx0XHRzdGFydHMgPSBbc2VnbWVudF07XG5cblx0XHRcdGZ1bmN0aW9uIGNvbGxlY3QoaW50ZXIsIGVuZCkge1xuXHRcdFx0XHR3aGlsZSAoaW50ZXIgJiYgaW50ZXIgIT09IGVuZCkge1xuXHRcdFx0XHRcdHZhciBvdGhlciA9IGludGVyLl9zZWdtZW50LFxuXHRcdFx0XHRcdFx0cGF0aCA9IG90aGVyICYmIG90aGVyLl9wYXRoO1xuXHRcdFx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdFx0XHR2YXIgbmV4dCA9IG90aGVyLmdldE5leHQoKSB8fCBwYXRoLmdldEZpcnN0U2VnbWVudCgpLFxuXHRcdFx0XHRcdFx0XHRuZXh0SW50ZXIgPSBuZXh0Ll9pbnRlcnNlY3Rpb247XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgIT09IHNlZ21lbnQgJiYgKGlzU3RhcnQob3RoZXIpXG5cdFx0XHRcdFx0XHRcdHx8IGlzU3RhcnQobmV4dClcblx0XHRcdFx0XHRcdFx0fHwgbmV4dCAmJiAoaXNWYWxpZChvdGhlcikgJiYgKGlzVmFsaWQobmV4dClcblx0XHRcdFx0XHRcdFx0XHR8fCBuZXh0SW50ZXIgJiYgaXNWYWxpZChuZXh0SW50ZXIuX3NlZ21lbnQpKSkpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y3Jvc3NpbmdzLnB1c2gob3RoZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGNvbGxlY3RTdGFydHMpXG5cdFx0XHRcdFx0XHRcdHN0YXJ0cy5wdXNoKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW50ZXIgPSBpbnRlci5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaW50ZXIpIHtcblx0XHRcdFx0Y29sbGVjdChpbnRlcik7XG5cdFx0XHRcdHdoaWxlIChpbnRlciAmJiBpbnRlci5fcHJldilcblx0XHRcdFx0XHRpbnRlciA9IGludGVyLl9wcmV2O1xuXHRcdFx0XHRjb2xsZWN0KGludGVyLCBzdGFydCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3Jvc3NpbmdzO1xuXHRcdH1cblxuXHRcdHNlZ21lbnRzLnNvcnQoZnVuY3Rpb24oc2VnMSwgc2VnMikge1xuXHRcdFx0dmFyIGludGVyMSA9IHNlZzEuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0aW50ZXIyID0gc2VnMi5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRvdmVyMSA9ICEhKGludGVyMSAmJiBpbnRlcjEuX292ZXJsYXApLFxuXHRcdFx0XHRvdmVyMiA9ICEhKGludGVyMiAmJiBpbnRlcjIuX292ZXJsYXApLFxuXHRcdFx0XHRwYXRoMSA9IHNlZzEuX3BhdGgsXG5cdFx0XHRcdHBhdGgyID0gc2VnMi5fcGF0aDtcblx0XHRcdHJldHVybiBvdmVyMSBeIG92ZXIyXG5cdFx0XHRcdFx0PyBvdmVyMSA/IDEgOiAtMVxuXHRcdFx0XHRcdDogIWludGVyMSBeICFpbnRlcjJcblx0XHRcdFx0XHRcdD8gaW50ZXIxID8gMSA6IC0xXG5cdFx0XHRcdFx0XHQ6IHBhdGgxICE9PSBwYXRoMlxuXHRcdFx0XHRcdFx0XHQ/IHBhdGgxLl9pZCAtIHBhdGgyLl9pZFxuXHRcdFx0XHRcdFx0XHQ6IHNlZzEuX2luZGV4IC0gc2VnMi5faW5kZXg7XG5cdFx0fSk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZyA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHR2YWxpZCA9IGlzVmFsaWQoc2VnKSxcblx0XHRcdFx0cGF0aCA9IG51bGwsXG5cdFx0XHRcdGZpbmlzaGVkID0gZmFsc2UsXG5cdFx0XHRcdGNsb3NlZCA9IHRydWUsXG5cdFx0XHRcdGJyYW5jaGVzID0gW10sXG5cdFx0XHRcdGJyYW5jaCxcblx0XHRcdFx0dmlzaXRlZCxcblx0XHRcdFx0aGFuZGxlSW47XG5cdFx0XHRpZiAodmFsaWQgJiYgc2VnLl9wYXRoLl9vdmVybGFwc09ubHkpIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gc2VnLl9wYXRoLFxuXHRcdFx0XHRcdHBhdGgyID0gc2VnLl9pbnRlcnNlY3Rpb24uX3NlZ21lbnQuX3BhdGg7XG5cdFx0XHRcdGlmIChwYXRoMS5jb21wYXJlKHBhdGgyKSkge1xuXHRcdFx0XHRcdGlmIChwYXRoMS5nZXRBcmVhKCkpXG5cdFx0XHRcdFx0XHRwYXRocy5wdXNoKHBhdGgxLmNsb25lKGZhbHNlKSk7XG5cdFx0XHRcdFx0dmlzaXRQYXRoKHBhdGgxKTtcblx0XHRcdFx0XHR2aXNpdFBhdGgocGF0aDIpO1xuXHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlICh2YWxpZCkge1xuXHRcdFx0XHR2YXIgZmlyc3QgPSAhcGF0aCxcblx0XHRcdFx0XHRjcm9zc2luZ3MgPSBnZXRDcm9zc2luZ1NlZ21lbnRzKHNlZywgZmlyc3QpLFxuXHRcdFx0XHRcdG90aGVyID0gY3Jvc3NpbmdzLnNoaWZ0KCksXG5cdFx0XHRcdFx0ZmluaXNoZWQgPSAhZmlyc3QgJiYgKGlzU3RhcnQoc2VnKSB8fCBpc1N0YXJ0KG90aGVyKSksXG5cdFx0XHRcdFx0Y3Jvc3MgPSAhZmluaXNoZWQgJiYgb3RoZXI7XG5cdFx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRcdHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRcdFx0YnJhbmNoID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmluaXNoZWQpIHtcblx0XHRcdFx0XHRpZiAoc2VnLmlzRmlyc3QoKSB8fCBzZWcuaXNMYXN0KCkpXG5cdFx0XHRcdFx0XHRjbG9zZWQgPSBzZWcuX3BhdGguX2Nsb3NlZDtcblx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjcm9zcyAmJiBicmFuY2gpIHtcblx0XHRcdFx0XHRicmFuY2hlcy5wdXNoKGJyYW5jaCk7XG5cdFx0XHRcdFx0YnJhbmNoID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWJyYW5jaCkge1xuXHRcdFx0XHRcdGlmIChjcm9zcylcblx0XHRcdFx0XHRcdGNyb3NzaW5ncy5wdXNoKHNlZyk7XG5cdFx0XHRcdFx0YnJhbmNoID0ge1xuXHRcdFx0XHRcdFx0c3RhcnQ6IHBhdGguX3NlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0XHRcdGNyb3NzaW5nczogY3Jvc3NpbmdzLFxuXHRcdFx0XHRcdFx0dmlzaXRlZDogdmlzaXRlZCA9IFtdLFxuXHRcdFx0XHRcdFx0aGFuZGxlSW46IGhhbmRsZUluXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3Jvc3MpXG5cdFx0XHRcdFx0c2VnID0gb3RoZXI7XG5cdFx0XHRcdGlmICghaXNWYWxpZChzZWcpKSB7XG5cdFx0XHRcdFx0cGF0aC5yZW1vdmVTZWdtZW50cyhicmFuY2guc3RhcnQpO1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBrID0gdmlzaXRlZC5sZW5ndGg7IGogPCBrOyBqKyspIHtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbal0uX3Zpc2l0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmlzaXRlZC5sZW5ndGggPSAwO1xuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdHNlZyA9IGJyYW5jaCAmJiBicmFuY2guY3Jvc3NpbmdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRpZiAoIXNlZyB8fCAhc2VnLl9wYXRoKSB7XG5cdFx0XHRcdFx0XHRcdHNlZyA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGJyYW5jaCA9IGJyYW5jaGVzLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYnJhbmNoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmlzaXRlZCA9IGJyYW5jaC52aXNpdGVkO1xuXHRcdFx0XHRcdFx0XHRcdGhhbmRsZUluID0gYnJhbmNoLmhhbmRsZUluO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSB3aGlsZSAoYnJhbmNoICYmICFpc1ZhbGlkKHNlZykpO1xuXHRcdFx0XHRcdGlmICghc2VnKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIG5leHQgPSBzZWcuZ2V0TmV4dCgpO1xuXHRcdFx0XHRwYXRoLmFkZChuZXcgU2VnbWVudChzZWcuX3BvaW50LCBoYW5kbGVJbixcblx0XHRcdFx0XHRcdG5leHQgJiYgc2VnLl9oYW5kbGVPdXQpKTtcblx0XHRcdFx0c2VnLl92aXNpdGVkID0gdHJ1ZTtcblx0XHRcdFx0dmlzaXRlZC5wdXNoKHNlZyk7XG5cdFx0XHRcdHNlZyA9IG5leHQgfHwgc2VnLl9wYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0XHRoYW5kbGVJbiA9IG5leHQgJiYgbmV4dC5faGFuZGxlSW47XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmluaXNoZWQpIHtcblx0XHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRcdHBhdGguZ2V0Rmlyc3RTZWdtZW50KCkuc2V0SGFuZGxlSW4oaGFuZGxlSW4pO1xuXHRcdFx0XHRcdHBhdGguc2V0Q2xvc2VkKGNsb3NlZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhdGguZ2V0QXJlYSgpICE9PSAwKSB7XG5cdFx0XHRcdFx0cGF0aHMucHVzaChwYXRoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9nZXRXaW5kaW5nOiBmdW5jdGlvbihwb2ludCwgZGlyLCBjbG9zZWQpIHtcblx0XHRcdHJldHVybiBnZXRXaW5kaW5nKHBvaW50LCB0aGlzLmdldEN1cnZlcygpLCBkaXIsIGNsb3NlZCk7XG5cdFx0fSxcblxuXHRcdHVuaXRlOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICd1bml0ZScsIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ2ludGVyc2VjdCcsIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnc3VidHJhY3QnLCBvcHRpb25zKTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnZXhjbHVkZScsIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBvcHRpb25zICYmIChvcHRpb25zLnRyYWNlID09IGZhbHNlIHx8IG9wdGlvbnMuc3Ryb2tlKVxuXHRcdFx0XHRcdD8gc3BsaXRCb29sZWFuKHRoaXMsIHBhdGgsICdkaXZpZGUnKVxuXHRcdFx0XHRcdDogY3JlYXRlUmVzdWx0KFtcblx0XHRcdFx0XHRcdHRoaXMuc3VidHJhY3QocGF0aCwgb3B0aW9ucyksXG5cdFx0XHRcdFx0XHR0aGlzLmludGVyc2VjdChwYXRoLCBvcHRpb25zKVxuXHRcdFx0XHRcdF0sIHRydWUsIHRoaXMsIHBhdGgsIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRyZXNvbHZlQ3Jvc3NpbmdzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0XHRwYXRocyA9IGNoaWxkcmVuIHx8IFt0aGlzXTtcblxuXHRcdFx0ZnVuY3Rpb24gaGFzT3ZlcmxhcChzZWcsIHBhdGgpIHtcblx0XHRcdFx0dmFyIGludGVyID0gc2VnICYmIHNlZy5faW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRyZXR1cm4gaW50ZXIgJiYgaW50ZXIuX292ZXJsYXAgJiYgaW50ZXIuX3BhdGggPT09IHBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoYXNPdmVybGFwcyA9IGZhbHNlLFxuXHRcdFx0XHRoYXNDcm9zc2luZ3MgPSBmYWxzZSxcblx0XHRcdFx0aW50ZXJzZWN0aW9ucyA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9ucyhudWxsLCBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0XHRcdHJldHVybiBpbnRlci5oYXNPdmVybGFwKCkgJiYgKGhhc092ZXJsYXBzID0gdHJ1ZSkgfHxcblx0XHRcdFx0XHRcdFx0aW50ZXIuaXNDcm9zc2luZygpICYmIChoYXNDcm9zc2luZ3MgPSB0cnVlKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdGNsZWFyQ3VydmVzID0gaGFzT3ZlcmxhcHMgJiYgaGFzQ3Jvc3NpbmdzICYmIFtdO1xuXHRcdFx0aW50ZXJzZWN0aW9ucyA9IEN1cnZlTG9jYXRpb24uZXhwYW5kKGludGVyc2VjdGlvbnMpO1xuXHRcdFx0aWYgKGhhc092ZXJsYXBzKSB7XG5cdFx0XHRcdHZhciBvdmVybGFwcyA9IGRpdmlkZUxvY2F0aW9ucyhpbnRlcnNlY3Rpb25zLCBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0XHRcdHJldHVybiBpbnRlci5oYXNPdmVybGFwKCk7XG5cdFx0XHRcdH0sIGNsZWFyQ3VydmVzKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IG92ZXJsYXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0dmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXSxcblx0XHRcdFx0XHRcdHBhdGggPSBvdmVybGFwLl9wYXRoLFxuXHRcdFx0XHRcdFx0c2VnID0gb3ZlcmxhcC5fc2VnbWVudCxcblx0XHRcdFx0XHRcdHByZXYgPSBzZWcuZ2V0UHJldmlvdXMoKSxcblx0XHRcdFx0XHRcdG5leHQgPSBzZWcuZ2V0TmV4dCgpO1xuXHRcdFx0XHRcdGlmIChoYXNPdmVybGFwKHByZXYsIHBhdGgpICYmIGhhc092ZXJsYXAobmV4dCwgcGF0aCkpIHtcblx0XHRcdFx0XHRcdHNlZy5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdHByZXYuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXHRcdFx0XHRcdFx0bmV4dC5faGFuZGxlSW4uX3NldCgwLCAwKTtcblx0XHRcdFx0XHRcdGlmIChwcmV2ICE9PSBzZWcgJiYgIXByZXYuZ2V0Q3VydmUoKS5oYXNMZW5ndGgoKSkge1xuXHRcdFx0XHRcdFx0XHRuZXh0Ll9oYW5kbGVJbi5zZXQocHJldi5faGFuZGxlSW4pO1xuXHRcdFx0XHRcdFx0XHRwcmV2LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0Nyb3NzaW5ncykge1xuXHRcdFx0XHRkaXZpZGVMb2NhdGlvbnMoaW50ZXJzZWN0aW9ucywgaGFzT3ZlcmxhcHMgJiYgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdFx0XHR2YXIgY3VydmUxID0gaW50ZXIuZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRcdHNlZzEgPSBpbnRlci5nZXRTZWdtZW50KCksXG5cdFx0XHRcdFx0XHRvdGhlciA9IGludGVyLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdFx0XHRjdXJ2ZTIgPSBvdGhlci5fY3VydmUsXG5cdFx0XHRcdFx0XHRzZWcyID0gb3RoZXIuX3NlZ21lbnQ7XG5cdFx0XHRcdFx0aWYgKGN1cnZlMSAmJiBjdXJ2ZTIgJiYgY3VydmUxLl9wYXRoICYmIGN1cnZlMi5fcGF0aClcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdGlmIChzZWcxKVxuXHRcdFx0XHRcdFx0c2VnMS5faW50ZXJzZWN0aW9uID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoc2VnMilcblx0XHRcdFx0XHRcdHNlZzIuX2ludGVyc2VjdGlvbiA9IG51bGw7XG5cdFx0XHRcdH0sIGNsZWFyQ3VydmVzKTtcblx0XHRcdFx0aWYgKGNsZWFyQ3VydmVzKVxuXHRcdFx0XHRcdGNsZWFyQ3VydmVIYW5kbGVzKGNsZWFyQ3VydmVzKTtcblx0XHRcdFx0cGF0aHMgPSB0cmFjZVBhdGhzKEJhc2UuZWFjaChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0XHRcdHRoaXMucHVzaC5hcHBseSh0aGlzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdH0sIFtdKSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuXHRcdFx0XHRpdGVtO1xuXHRcdFx0aWYgKGxlbmd0aCA+IDEgJiYgY2hpbGRyZW4pIHtcblx0XHRcdFx0aWYgKHBhdGhzICE9PSBjaGlsZHJlbilcblx0XHRcdFx0XHR0aGlzLnNldENoaWxkcmVuKHBhdGhzKTtcblx0XHRcdFx0aXRlbSA9IHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMSAmJiAhY2hpbGRyZW4pIHtcblx0XHRcdFx0aWYgKHBhdGhzWzBdICE9PSB0aGlzKVxuXHRcdFx0XHRcdHRoaXMuc2V0U2VnbWVudHMocGF0aHNbMF0ucmVtb3ZlU2VnbWVudHMoKSk7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFpdGVtKSB7XG5cdFx0XHRcdGl0ZW0gPSBuZXcgQ29tcG91bmRQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0aXRlbS5hZGRDaGlsZHJlbihwYXRocyk7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtLnJlZHVjZSgpO1xuXHRcdFx0XHRpdGVtLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdFx0XHR0aGlzLnJlcGxhY2VXaXRoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSxcblxuXHRcdHJlb3JpZW50OiBmdW5jdGlvbihub25aZXJvLCBjbG9ja3dpc2UpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnNldENoaWxkcmVuKHJlb3JpZW50UGF0aHModGhpcy5yZW1vdmVDaGlsZHJlbigpLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24odykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gISEobm9uWmVybyA/IHcgOiB3ICYgMSk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0Y2xvY2t3aXNlKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvY2t3aXNlKGNsb2Nrd2lzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Z2V0SW50ZXJpb3JQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdFx0cG9pbnQgPSBib3VuZHMuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0aWYgKCF0aGlzLmNvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdFx0XHRpbnRlcmNlcHRzID0gW10sXG5cdFx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHYgPSBjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCksXG5cdFx0XHRcdFx0XHRvMCA9IHZbMV0sXG5cdFx0XHRcdFx0XHRvMSA9IHZbM10sXG5cdFx0XHRcdFx0XHRvMiA9IHZbNV0sXG5cdFx0XHRcdFx0XHRvMyA9IHZbN107XG5cdFx0XHRcdFx0aWYgKHkgPj0gbWluKG8wLCBvMSwgbzIsIG8zKSAmJiB5IDw9IG1heChvMCwgbzEsIG8yLCBvMykpIHtcblx0XHRcdFx0XHRcdHZhciBtb25vQ3VydmVzID0gQ3VydmUuZ2V0TW9ub0N1cnZlcyh2KTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBtID0gbW9ub0N1cnZlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIG12ID0gbW9ub0N1cnZlc1tqXSxcblx0XHRcdFx0XHRcdFx0XHRtbzAgPSBtdlsxXSxcblx0XHRcdFx0XHRcdFx0XHRtbzMgPSBtdls3XTtcblx0XHRcdFx0XHRcdFx0aWYgKChtbzAgIT09IG1vMykgJiZcblx0XHRcdFx0XHRcdFx0XHQoeSA+PSBtbzAgJiYgeSA8PSBtbzMgfHwgeSA+PSBtbzMgJiYgeSA8PSBtbzApKXtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeCA9IHkgPT09IG1vMCA/IG12WzBdXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHkgPT09IG1vMyA/IG12WzZdXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IEN1cnZlLnNvbHZlQ3ViaWMobXYsIDEsIHksIHJvb3RzLCAwLCAxKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ9PT0gMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ/IEN1cnZlLmdldFBvaW50KG12LCByb290c1swXSkueFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ6IChtdlswXSArIG12WzZdKSAvIDI7XG5cdFx0XHRcdFx0XHRcdFx0aW50ZXJjZXB0cy5wdXNoKHgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpbnRlcmNlcHRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRpbnRlcmNlcHRzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuXHRcdFx0XHRcdHBvaW50LnggPSAoaW50ZXJjZXB0c1swXSArIGludGVyY2VwdHNbMV0pIC8gMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBvaW50O1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgUGF0aEZsYXR0ZW5lciA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEZsYXR0ZW5lcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgZmxhdG5lc3MsIG1heFJlY3Vyc2lvbiwgaWdub3JlU3RyYWlnaHQsIG1hdHJpeCkge1xuXHRcdHZhciBjdXJ2ZXMgPSBbXSxcblx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRsZW5ndGggPSAwLFxuXHRcdFx0bWluU3BhbiA9IDEgLyAobWF4UmVjdXJzaW9uIHx8IDMyKSxcblx0XHRcdHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnRzWzBdLFxuXHRcdFx0c2VnbWVudDI7XG5cblx0XHRmdW5jdGlvbiBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFZhbHVlcyhzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCk7XG5cdFx0XHRjdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHRjb21wdXRlUGFydHMoY3VydmUsIHNlZ21lbnQxLl9pbmRleCwgMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZVBhcnRzKGN1cnZlLCBpbmRleCwgdDEsIHQyKSB7XG5cdFx0XHRpZiAoKHQyIC0gdDEpID4gbWluU3BhblxuXHRcdFx0XHRcdCYmICEoaWdub3JlU3RyYWlnaHQgJiYgQ3VydmUuaXNTdHJhaWdodChjdXJ2ZSkpXG5cdFx0XHRcdFx0JiYgIUN1cnZlLmlzRmxhdEVub3VnaChjdXJ2ZSwgZmxhdG5lc3MgfHwgMC4yNSkpIHtcblx0XHRcdFx0dmFyIGhhbHZlcyA9IEN1cnZlLnN1YmRpdmlkZShjdXJ2ZSwgMC41KSxcblx0XHRcdFx0XHR0TWlkID0gKHQxICsgdDIpIC8gMjtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKGhhbHZlc1swXSwgaW5kZXgsIHQxLCB0TWlkKTtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKGhhbHZlc1sxXSwgaW5kZXgsIHRNaWQsIHQyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBkeCA9IGN1cnZlWzZdIC0gY3VydmVbMF0sXG5cdFx0XHRcdFx0ZHkgPSBjdXJ2ZVs3XSAtIGN1cnZlWzFdLFxuXHRcdFx0XHRcdGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdFx0XHRpZiAoZGlzdCA+IDApIHtcblx0XHRcdFx0XHRsZW5ndGggKz0gZGlzdDtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHtcblx0XHRcdFx0XHRcdG9mZnNldDogbGVuZ3RoLFxuXHRcdFx0XHRcdFx0Y3VydmU6IGN1cnZlLFxuXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0XHRcdFx0dGltZTogdDIsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnbWVudDIgPSBzZWdtZW50c1tpXTtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnQyO1xuXHRcdH1cblx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblx0XHR0aGlzLmN1cnZlcyA9IGN1cnZlcztcblx0XHR0aGlzLnBhcnRzID0gcGFydHM7XG5cdFx0dGhpcy5sZW5ndGggPSBsZW5ndGg7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdH0sXG5cblx0X2dldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5wYXJ0cyxcblx0XHRcdGxlbmd0aCA9IHBhcnRzLmxlbmd0aCxcblx0XHRcdHN0YXJ0LFxuXHRcdFx0aSwgaiA9IHRoaXMuaW5kZXg7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0aSA9IGo7XG5cdFx0XHRpZiAoIWogfHwgcGFydHNbLS1qXS5vZmZzZXQgPCBvZmZzZXQpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdFx0aWYgKHBhcnQub2Zmc2V0ID49IG9mZnNldCkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gaTtcblx0XHRcdFx0dmFyIHByZXYgPSBwYXJ0c1tpIC0gMV0sXG5cdFx0XHRcdFx0cHJldlRpbWUgPSBwcmV2ICYmIHByZXYuaW5kZXggPT09IHBhcnQuaW5kZXggPyBwcmV2LnRpbWUgOiAwLFxuXHRcdFx0XHRcdHByZXZPZmZzZXQgPSBwcmV2ID8gcHJldi5vZmZzZXQgOiAwO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGluZGV4OiBwYXJ0LmluZGV4LFxuXHRcdFx0XHRcdHRpbWU6IHByZXZUaW1lICsgKHBhcnQudGltZSAtIHByZXZUaW1lKVxuXHRcdFx0XHRcdFx0KiAob2Zmc2V0IC0gcHJldk9mZnNldCkgLyAocGFydC5vZmZzZXQgLSBwcmV2T2Zmc2V0KVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0aW5kZXg6IHBhcnRzW2xlbmd0aCAtIDFdLmluZGV4LFxuXHRcdFx0dGltZTogMVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhd1BhcnQ6IGZ1bmN0aW9uKGN0eCwgZnJvbSwgdG8pIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLl9nZXQoZnJvbSksXG5cdFx0XHRlbmQgPSB0aGlzLl9nZXQodG8pO1xuXHRcdGZvciAodmFyIGkgPSBzdGFydC5pbmRleCwgbCA9IGVuZC5pbmRleDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFBhcnQodGhpcy5jdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0aSA9PT0gc3RhcnQuaW5kZXggPyBzdGFydC50aW1lIDogMCxcblx0XHRcdFx0XHRpID09PSBlbmQuaW5kZXggPyBlbmQudGltZSA6IDEpO1xuXHRcdFx0aWYgKGkgPT09IHN0YXJ0LmluZGV4KVxuXHRcdFx0XHRjdHgubW92ZVRvKGN1cnZlWzBdLCBjdXJ2ZVsxXSk7XG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGN1cnZlLnNsaWNlKDIpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHRcdHZhciBwYXJhbSA9IHRoaXMuX2dldChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuY3VydmVzW3BhcmFtLmluZGV4XSwgcGFyYW0udGltZSk7XG5cdFx0fTtcblx0fSwge30pXG4pO1xuXG52YXIgUGF0aEZpdHRlciA9IEJhc2UuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdGNsb3NlZCA9IHBhdGguX2Nsb3NlZDtcblx0XHRmb3IgKHZhciBpID0gMCwgcHJldiwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudHNbaV0ucG9pbnQ7XG5cdFx0XHRpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwcmV2ID0gcG9pbnQuY2xvbmUoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdHBvaW50cy51bnNoaWZ0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzFdKTtcblx0XHR9XG5cdFx0dGhpcy5jbG9zZWQgPSBjbG9zZWQ7XG5cdH0sXG5cblx0Zml0OiBmdW5jdGlvbihlcnJvcikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcblx0XHRcdGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG5cdFx0XHRzZWdtZW50cyA9IG51bGw7XG5cdFx0aWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdHNlZ21lbnRzID0gW25ldyBTZWdtZW50KHBvaW50c1swXSldO1xuXHRcdFx0aWYgKGxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIDAsIGxlbmd0aCAtIDEsXG5cdFx0XHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKSxcblx0XHRcdFx0XHRcdHBvaW50c1tsZW5ndGggLSAyXS5zdWJ0cmFjdChwb2ludHNbbGVuZ3RoIC0gMV0pKTtcblx0XHRcdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRcdFx0c2VnbWVudHMuc2hpZnQoKTtcblx0XHRcdFx0XHRzZWdtZW50cy5wb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gc2VnbWVudHM7XG5cdH0sXG5cblx0Zml0Q3ViaWM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBlcnJvciwgZmlyc3QsIGxhc3QsIHRhbjEsIHRhbjIpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0aWYgKGxhc3QgLSBmaXJzdCA9PT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHBvaW50c1tmaXJzdF0sXG5cdFx0XHRcdHB0MiA9IHBvaW50c1tsYXN0XSxcblx0XHRcdFx0ZGlzdCA9IHB0MS5nZXREaXN0YW5jZShwdDIpIC8gMztcblx0XHRcdHRoaXMuYWRkQ3VydmUoc2VnbWVudHMsIFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heChlcnJvciwgZXJyb3IgKiBlcnJvciksXG5cdFx0XHRzcGxpdCxcblx0XHRcdHBhcmFtZXRlcnNJbk9yZGVyID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IGVycm9yICYmIHBhcmFtZXRlcnNJbk9yZGVyKSB7XG5cdFx0XHRcdHRoaXMuYWRkQ3VydmUoc2VnbWVudHMsIGN1cnZlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3BsaXQgPSBtYXguaW5kZXg7XG5cdFx0XHRpZiAobWF4LmVycm9yID49IG1heEVycm9yKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHBhcmFtZXRlcnNJbk9yZGVyID0gdGhpcy5yZXBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCwgdVByaW1lLCBjdXJ2ZSk7XG5cdFx0XHRtYXhFcnJvciA9IG1heC5lcnJvcjtcblx0XHR9XG5cdFx0dmFyIHRhbkNlbnRlciA9IHBvaW50c1tzcGxpdCAtIDFdLnN1YnRyYWN0KHBvaW50c1tzcGxpdCArIDFdKTtcblx0XHR0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgZmlyc3QsIHNwbGl0LCB0YW4xLCB0YW5DZW50ZXIpO1xuXHRcdHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCBzcGxpdCwgbGFzdCwgdGFuQ2VudGVyLm5lZ2F0ZSgpLCB0YW4yKTtcblx0fSxcblxuXHRhZGRDdXJ2ZTogZnVuY3Rpb24oc2VnbWVudHMsIGN1cnZlKSB7XG5cdFx0dmFyIHByZXYgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0XHRwcmV2LnNldEhhbmRsZU91dChjdXJ2ZVsxXS5zdWJ0cmFjdChjdXJ2ZVswXSkpO1xuXHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQoY3VydmVbM10sIGN1cnZlWzJdLnN1YnRyYWN0KGN1cnZlWzNdKSkpO1xuXHR9LFxuXG5cdGdlbmVyYXRlQmV6aWVyOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS0xMixcblx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0cG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRwdDEgPSBwb2ludHNbZmlyc3RdLFxuXHRcdFx0cHQyID0gcG9pbnRzW2xhc3RdLFxuXHRcdFx0QyA9IFtbMCwgMF0sIFswLCAwXV0sXG5cdFx0XHRYID0gWzAsIDBdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXN0IC0gZmlyc3QgKyAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdSA9IHVQcmltZVtpXSxcblx0XHRcdFx0dCA9IDEgLSB1LFxuXHRcdFx0XHRiID0gMyAqIHUgKiB0LFxuXHRcdFx0XHRiMCA9IHQgKiB0ICogdCxcblx0XHRcdFx0YjEgPSBiICogdCxcblx0XHRcdFx0YjIgPSBiICogdSxcblx0XHRcdFx0YjMgPSB1ICogdSAqIHUsXG5cdFx0XHRcdGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuXHRcdFx0XHRhMiA9IHRhbjIubm9ybWFsaXplKGIyKSxcblx0XHRcdFx0dG1wID0gcG9pbnRzW2ZpcnN0ICsgaV1cblx0XHRcdFx0XHQuc3VidHJhY3QocHQxLm11bHRpcGx5KGIwICsgYjEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDIubXVsdGlwbHkoYjIgKyBiMykpO1xuXHRcdFx0Q1swXVswXSArPSBhMS5kb3QoYTEpO1xuXHRcdFx0Q1swXVsxXSArPSBhMS5kb3QoYTIpO1xuXHRcdFx0Q1sxXVswXSA9IENbMF1bMV07XG5cdFx0XHRDWzFdWzFdICs9IGEyLmRvdChhMik7XG5cdFx0XHRYWzBdICs9IGExLmRvdCh0bXApO1xuXHRcdFx0WFsxXSArPSBhMi5kb3QodG1wKTtcblx0XHR9XG5cblx0XHR2YXIgZGV0QzBDMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV0sXG5cdFx0XHRhbHBoYTEsXG5cdFx0XHRhbHBoYTI7XG5cdFx0aWYgKGFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcblx0XHRcdHZhciBkZXRDMFggPSBDWzBdWzBdICogWFsxXSAgICAtIENbMV1bMF0gKiBYWzBdLFxuXHRcdFx0XHRkZXRYQzEgPSBYWzBdICAgICogQ1sxXVsxXSAtIFhbMV0gICAgKiBDWzBdWzFdO1xuXHRcdFx0YWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcblx0XHRcdGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuXHRcdFx0XHRjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuXHRcdFx0YWxwaGExID0gYWxwaGEyID0gYWJzKGMwKSA+IGVwc2lsb24gPyBYWzBdIC8gYzBcblx0XHRcdFx0XHRcdFx0OiBhYnMoYzEpID4gZXBzaWxvbiA/IFhbMV0gLyBjMVxuXHRcdFx0XHRcdFx0XHQ6IDA7XG5cdFx0fVxuXG5cdFx0dmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpLFxuXHRcdFx0ZXBzID0gZXBzaWxvbiAqIHNlZ0xlbmd0aCxcblx0XHRcdGhhbmRsZTEsXG5cdFx0XHRoYW5kbGUyO1xuXHRcdGlmIChhbHBoYTEgPCBlcHMgfHwgYWxwaGEyIDwgZXBzKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGluZSA9IHB0Mi5zdWJ0cmFjdChwdDEpO1xuXHRcdFx0aGFuZGxlMSA9IHRhbjEubm9ybWFsaXplKGFscGhhMSk7XG5cdFx0XHRoYW5kbGUyID0gdGFuMi5ub3JtYWxpemUoYWxwaGEyKTtcblx0XHRcdGlmIChoYW5kbGUxLmRvdChsaW5lKSAtIGhhbmRsZTIuZG90KGxpbmUpID4gc2VnTGVuZ3RoICogc2VnTGVuZ3RoKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0XHRcdGhhbmRsZTEgPSBoYW5kbGUyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gW3B0MSxcblx0XHRcdFx0cHQxLmFkZChoYW5kbGUxIHx8IHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKGhhbmRsZTIgfHwgdGFuMi5ub3JtYWxpemUoYWxwaGEyKSksXG5cdFx0XHRcdHB0Ml07XG5cdH0sXG5cblx0cmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodVtpXSA8PSB1W2kgLSAxXSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRmaW5kUm9vdDogZnVuY3Rpb24oY3VydmUsIHBvaW50LCB1KSB7XG5cdFx0dmFyIGN1cnZlMSA9IFtdLFxuXHRcdFx0Y3VydmUyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0XHRcdGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG5cdFx0XHRwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG5cdFx0XHRwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG5cdFx0XHRkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuXHRcdFx0ZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKGRmKSA/IHUgOiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y29udGVudDogbnVsbFxuXHR9LFxuXHRfYm91bmRzT3B0aW9uczogeyBzdHJva2U6IGZhbHNlLCBoYW5kbGU6IGZhbHNlIH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVGV4dEl0ZW0oYXJnKSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnO1xuXHRcdHRoaXMuX2xpbmVzID0gW107XG5cdFx0dmFyIGhhc1Byb3BzID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdCYmIGFyZy54ID09PSB1bmRlZmluZWQgJiYgYXJnLnkgPT09IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9pbml0aWFsaXplKGhhc1Byb3BzICYmIGFyZywgIWhhc1Byb3BzICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50ID09PSBpdGVtLl9jb250ZW50O1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR0aGlzLnNldENvbnRlbnQoc291cmNlLl9jb250ZW50KTtcblx0fSxcblxuXHRnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcblx0XHR0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblx0XHR0aGlzLl9jaGFuZ2VkKDI2NSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuXG5cdGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50VGV4dCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuXHRcdFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHR2YXIgbGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG5cdFx0Y3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcblx0XHRjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcblx0XHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG5cdFx0XHRqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG5cdFx0XHR4ID0gMDtcblx0XHRpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuXHRcdFx0eCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh4LFxuXHRcdFx0XHRcdG51bUxpbmVzID8gLSAwLjc1ICogbGVhZGluZyA6IDAsXG5cdFx0XHRcdFx0d2lkdGgsIG51bUxpbmVzICogbGVhZGluZyk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpIDogcmVjdDtcblx0fVxufSk7XG5cbnZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHR5cGVzID0ge1xuXHRcdGdyYXk6IFsnZ3JheSddLFxuXHRcdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRcdGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG5cdFx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRcdGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuXHR9O1xuXG5cdHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG5cdFx0Y29sb3JDYWNoZSA9IHt9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhcXHd7MSwyfSkoXFx3ezEsMn0pKFxcd3sxLDJ9KSQvKSxcblx0XHRcdGNvbXBvbmVudHM7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRjb21wb25lbnRzID0gWzAsIDAsIDBdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDFcblx0XHRcdFx0XHRcdD8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXnJnYmE/XFwoKC4qKVxcKSQvKSkge1xuXHRcdFx0Y29tcG9uZW50cyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICtjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gaSA8IDMgPyB2YWx1ZSAvIDI1NSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAod2luZG93KSB7XG5cdFx0XHR2YXIgY2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddO1xuXHRcdFx0aWYgKCFjYWNoZWQpIHtcblx0XHRcdFx0aWYgKCFjb2xvckN0eCkge1xuXHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ10gPSBbXG5cdFx0XHRcdFx0ZGF0YVswXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMl0gLyAyNTVcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjYWNoZWQuc2xpY2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29tcG9uZW50cyA9IFswLCAwLCAwXTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHR2YXIgaHNiSW5kaWNlcyA9IFtcblx0XHRbMCwgMywgMV0sXG5cdFx0WzIsIDAsIDFdLFxuXHRcdFsxLCAwLCAzXSxcblx0XHRbMSwgMiwgMF0sXG5cdFx0WzMsIDEsIDBdLFxuXHRcdFswLCAxLCAyXVxuXHRdO1xuXG5cdHZhciBjb252ZXJ0ZXJzID0ge1xuXHRcdCdyZ2ItaHNiJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGggPSBkZWx0YSA9PT0gMCA/IDBcblx0XHRcdFx0XHQ6ICAgKCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDogICAgICAgICAgICAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwO1xuXHRcdFx0cmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG5cdFx0fSxcblxuXHRcdCdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuXHRcdFx0aCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihoKSxcblx0XHRcdFx0ZiA9IGggLSBpLFxuXHRcdFx0XHRpID0gaHNiSW5kaWNlc1tpXSxcblx0XHRcdFx0diA9IFtcblx0XHRcdFx0XHRiLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiBmKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogKDEgLSBmKSlcblx0XHRcdFx0XTtcblx0XHRcdHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG5cdFx0fSxcblxuXHRcdCdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcblx0XHRcdFx0aCA9IGFjaHJvbWF0aWMgPyAwXG5cdFx0XHRcdFx0OiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCxcblx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMixcblx0XHRcdFx0cyA9IGFjaHJvbWF0aWMgPyAwIDogbCA8IDAuNVxuXHRcdFx0XHRcdFx0PyBkZWx0YSAvIChtYXggKyBtaW4pXG5cdFx0XHRcdFx0XHQ6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHRcdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0XHR9LFxuXG5cdFx0J2hzbC1yZ2InOiBmdW5jdGlvbihoLCBzLCBsKSB7XG5cdFx0XHRoID0gKCgoaCAvIDM2MCkgJSAxKSArIDEpICUgMTtcblx0XHRcdGlmIChzID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdFx0dmFyIHQzcyA9IFsgaCArIDEgLyAzLCBoLCBoIC0gMSAvIDMgXSxcblx0XHRcdFx0dDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxuXHRcdFx0XHR0MSA9IDIgKiBsIC0gdDIsXG5cdFx0XHRcdGMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB0MyA9IHQzc1tpXTtcblx0XHRcdFx0aWYgKHQzIDwgMCkgdDMgKz0gMTtcblx0XHRcdFx0aWYgKHQzID4gMSkgdDMgLT0gMTtcblx0XHRcdFx0Y1tpXSA9IDYgKiB0MyA8IDFcblx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzXG5cdFx0XHRcdFx0OiAyICogdDMgPCAxXG5cdFx0XHRcdFx0XHQ/IHQyXG5cdFx0XHRcdFx0XHQ6IDMgKiB0MyA8IDJcblx0XHRcdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDMpICogNlxuXHRcdFx0XHRcdFx0XHQ6IHQxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JheSc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHJldHVybiBbciAqIDAuMjk4OSArIGcgKiAwLjU4NyArIGIgKiAwLjExNF07XG5cdFx0fSxcblxuXHRcdCdncmF5LXJnYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbZywgZywgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzbCc6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmFkaWVudC1yZ2InOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmFkaWVudCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2godHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0XHRjb21wb25lbnRQYXJzZXJzW3R5cGVdID0gW107XG5cdFx0QmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0aGFzT3ZlcmxhcCA9IC9eKGh1ZXxzYXR1cmF0aW9uKSQvLnRlc3QobmFtZSksXG5cdFx0XHRcdHBhcnNlciA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV1baW5kZXhdID0gbmFtZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdD8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29tcG9uZW50c1swXTtcblx0XHRcdFx0XHRcdHZhbHVlID0gR3JhZGllbnQucmVhZChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0OiBhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5fcmVtb3ZlT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0PyBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gMCA6IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0fHwgaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50c1tpbmRleF1cblx0XHRcdFx0XHRcdDogdGhpcy5fY29udmVydCh0eXBlKVtpbmRleF07XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gdHlwZVxuXHRcdFx0XHRcdFx0JiYgIShoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdH07XG5cdFx0fSwgdGhpcyk7XG5cdH0sIHtcblx0XHRfY2xhc3M6ICdDb2xvcicsXG5cdFx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbG9yKGFyZykge1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcblx0XHRcdFx0cmVhZCA9IDAsXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMsXG5cdFx0XHRcdGFscGhhLFxuXHRcdFx0XHR2YWx1ZXM7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMF07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmc7XG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgJiYgYXJnIGluIHR5cGVzKSB7XG5cdFx0XHRcdHR5cGUgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnO1xuXHRcdFx0XHRcdGFscGhhID0gYXJnc1syXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0XHRcdGFyZ3MgPSBCYXNlLnNsaWNlKGFyZ3MsIDEpO1xuXHRcdFx0XHRcdGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gYXJnc1xuXHRcdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBhcmdcblx0XHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRcdFx0aWYgKCF0eXBlKVxuXHRcdFx0XHRcdFx0dHlwZSA9IHZhbHVlcy5sZW5ndGggPj0gM1xuXHRcdFx0XHRcdFx0XHRcdD8gJ3JnYidcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5Jztcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gdHlwZXNbdHlwZV0ubGVuZ3RoO1xuXHRcdFx0XHRcdGFscGhhID0gdmFsdWVzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKHJlYWRpbmcpIHtcblx0XHRcdFx0XHRcdHJlYWQgKz0gdmFsdWVzID09PSBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0PyBsZW5ndGggKyAoYWxwaGEgIT0gbnVsbCA/IDEgOiAwKVxuXHRcdFx0XHRcdFx0XHQ6IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKVxuXHRcdFx0XHRcdFx0dmFsdWVzID0gQmFzZS5zbGljZSh2YWx1ZXMsIDAsIGxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0eXBlID0gJ3JnYic7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGZyb21DU1MoYXJnKTtcblx0XHRcdFx0XHRpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdGFscGhhID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSBhcmcuX3R5cGU7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5fYWxwaGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBHcmFkaWVudCkge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdncmFkaWVudCc7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBhcmdzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2h1ZScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdD8gJ2xpZ2h0bmVzcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnaHNsJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2hzYidcblx0XHRcdFx0XHRcdFx0OiAnZ3JhZGllbnQnIGluIGFyZyB8fCAnc3RvcHMnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0fHwgJ3JhZGlhbCcgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICdncmF5J1xuXHRcdFx0XHRcdFx0XHRcdFx0OiAncmdiJztcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV0sXG5cdFx0XHRcdFx0XHRcdHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuXHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gYXJnW3Byb3BlcnRpZXNbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaSAmJiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiAnc3RvcHMnIGluIGFyZykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RvcHM6IGFyZy5zdG9wcyxcblx0XHRcdFx0XHRcdFx0XHRcdHJhZGlhbDogYXJnLnJhZGlhbFxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5hbHBoYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlYWRpbmcgJiYgdHlwZSlcblx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8ICdyZ2InO1xuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRzZXQ6ICcjaW5pdGlhbGl6ZScsXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFxuXHRcdFx0XHRcdC9eKGdyYXl8cmdiKSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0OiBbdGhpcy5fdHlwZV0uY29uY2F0KGNvbXBvbmVudHMpLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0sXG5cblx0XHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0XHR9LFxuXG5cdFx0X2NvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb252ZXJ0ZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG5cdFx0XHRcdFx0OiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pXG5cdFx0XHRcdFx0XHQ/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0OiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzKSk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuXHRcdH0sXG5cblx0XHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH0sXG5cblx0XHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0XHR9LFxuXG5cdFx0Z2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG5cdFx0fSxcblxuXHRcdHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fSxcblxuXHRcdGhhc0FscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHR2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpXG5cdFx0XHRcdFx0PyBDb2xvci5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0XHQ6IGNvbG9yO1xuXHRcdFx0cmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3Ncblx0XHRcdFx0XHQmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGVcblx0XHRcdFx0XHQmJiB0aGlzLmdldEFscGhhKCkgPT09IGNvbC5nZXRBbHBoYSgpXG5cdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG5cdFx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRcdGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuXHRcdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG5cdFx0XHRcdFx0XHRcdCsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcblx0XHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdFx0fSxcblxuXHRcdHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG5cdFx0XHRcdGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cdFx0XHRmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IFtcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzBdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzFdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzJdKVxuXHRcdFx0XTtcblx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGhleFxuXHRcdFx0XHRcdD8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KVxuXHRcdFx0XHRcdFx0KyAoY29tcG9uZW50c1sxXSA8PCA4KVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSlcblx0XHRcdFx0XHQ6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJylcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fY2FudmFzU3R5bGUpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZTtcblx0XHRcdGlmICh0aGlzLl90eXBlICE9PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSB0aGlzLnRvQ1NTKCk7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGdyYWRpZW50ID0gY29tcG9uZW50c1swXSxcblx0XHRcdFx0c3RvcHMgPSBncmFkaWVudC5fc3RvcHMsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbXBvbmVudHNbMV0sXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29tcG9uZW50c1syXSxcblx0XHRcdFx0aGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXSxcblx0XHRcdFx0aW52ZXJzZSA9IG1hdHJpeCAmJiBtYXRyaXguaW52ZXJ0ZWQoKSxcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQ7XG5cdFx0XHRpZiAoaW52ZXJzZSkge1xuXHRcdFx0XHRvcmlnaW4gPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChvcmlnaW4pO1xuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGludmVyc2UuX3RyYW5zZm9ybVBvaW50KGRlc3RpbmF0aW9uKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodClcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChoaWdobGlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbik7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG5cdFx0XHRcdFx0aWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcblx0XHRcdFx0XHRcdGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuXHRcdFx0XHRcdFx0MCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LFxuXHRcdFx0XHRcdFx0ZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldLFxuXHRcdFx0XHRcdG9mZnNldCA9IHN0b3AuX29mZnNldDtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuXHRcdFx0XHRcdFx0b2Zmc2V0ID09IG51bGwgPyBpIC8gKGwgLSAxKSA6IG9mZnNldCxcblx0XHRcdFx0XHRcdHN0b3AuX2NvbG9yLnRvQ2FudmFzU3R5bGUoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSBjYW52YXNHcmFkaWVudDtcblx0XHR9LFxuXG5cdFx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0X3R5cGVzOiB0eXBlcyxcblxuXHRcdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKHJhbmRvbSgpLCByYW5kb20oKSwgcmFuZG9tKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdGFkZDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKyBiO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKiBiO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC8gYjtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uKG9wZXJhdG9yLCBuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0Y29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRjb21wb25lbnRzMiA9IGNvbG9yLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzMS5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNvbXBvbmVudHMyW2ldID0gb3BlcmF0b3IoY29tcG9uZW50czFbaV0sIGNvbXBvbmVudHMyW2ldKTtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50czIsXG5cdFx0XHRcdFx0dGhpcy5fYWxwaGEgIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IG9wZXJhdG9yKHRoaXMuX2FscGhhLCBjb2xvci5nZXRBbHBoYSgpKVxuXHRcdFx0XHRcdFx0XHQ6IG51bGwpO1xuXHRcdH07XG5cdH0sIHtcblx0fSk7XG59KTtcblxudmFyIEdyYWRpZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnQoc3RvcHMsIHJhZGlhbCkge1xuXHRcdHRoaXMuX2lkID0gVUlELmdldCgpO1xuXHRcdGlmIChzdG9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3Qoc3RvcHMpKSB7XG5cdFx0XHR0aGlzLnNldChzdG9wcyk7XG5cdFx0XHRzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9zdG9wcyA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9yYWRpYWwgPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5zZXRSYWRpYWwodHlwZW9mIHJhZGlhbCA9PT0gJ3N0cmluZycgJiYgcmFkaWFsID09PSAncmFkaWFsJ1xuXHRcdFx0XHRcdHx8IHJhZGlhbCB8fCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX3N0b3BzLCB0aGlzLl9yYWRpYWxdLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX293bmVycyAmJiB0aGlzLl9vd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9vd25lcnNbaV0uX2NoYW5nZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZE93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdGlmICghdGhpcy5fb3duZXJzKVxuXHRcdFx0dGhpcy5fb3duZXJzID0gW107XG5cdFx0dGhpcy5fb3duZXJzLnB1c2goY29sb3IpO1xuXHR9LFxuXG5cdF9yZW1vdmVPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9vd25lcnMgPyB0aGlzLl9vd25lcnMuaW5kZXhPZihjb2xvcikgOiAtMTtcblx0XHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHRcdHRoaXMuX293bmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0aWYgKCF0aGlzLl9vd25lcnMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLl9vd25lcnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RvcHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c3RvcHNbaV0gPSB0aGlzLl9zdG9wc1tpXS5jbG9uZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50KHN0b3BzLCB0aGlzLl9yYWRpYWwpO1xuXHR9LFxuXG5cdGdldFN0b3BzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RvcHM7XG5cdH0sXG5cblx0c2V0U3RvcHM6IGZ1bmN0aW9uKHN0b3BzKSB7XG5cdFx0aWYgKHN0b3BzLmxlbmd0aCA8IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnR3JhZGllbnQgc3RvcCBsaXN0IG5lZWRzIHRvIGNvbnRhaW4gYXQgbGVhc3QgdHdvIHN0b3BzLicpO1xuXHRcdH1cblx0XHR2YXIgX3N0b3BzID0gdGhpcy5fc3RvcHM7XG5cdFx0aWYgKF9zdG9wcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBfc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRfc3RvcHNbaV0uX293bmVyID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRfc3RvcHMgPSB0aGlzLl9zdG9wcyA9IEdyYWRpZW50U3RvcC5yZWFkTGlzdChzdG9wcywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IF9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRfc3RvcHNbaV0uX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0UmFkaWFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsO1xuXHR9LFxuXG5cdHNldFJhZGlhbDogZnVuY3Rpb24ocmFkaWFsKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG5cdFx0aWYgKGdyYWRpZW50ID09PSB0aGlzKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWYgKGdyYWRpZW50ICYmIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3MpIHtcblx0XHRcdHZhciBzdG9wczEgPSB0aGlzLl9zdG9wcyxcblx0XHRcdFx0c3RvcHMyID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRsZW5ndGggPSBzdG9wczEubGVuZ3RoO1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gc3RvcHMyLmxlbmd0aCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCFzdG9wczFbaV0uZXF1YWxzKHN0b3BzMltpXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBHcmFkaWVudFN0b3AgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50U3RvcCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgY29sb3IgPSBhcmcwLFxuXHRcdFx0b2Zmc2V0ID0gYXJnMTtcblx0XHRpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnICYmIGFyZzEgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkgJiYgdHlwZW9mIGFyZzBbMF0gIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMFswXTtcblx0XHRcdFx0b2Zmc2V0ID0gYXJnMFsxXTtcblx0XHRcdH0gZWxzZSBpZiAoJ2NvbG9yJyBpbiBhcmcwIHx8ICdvZmZzZXQnIGluIGFyZzBcblx0XHRcdFx0XHR8fCAncmFtcFBvaW50JyBpbiBhcmcwKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMC5jb2xvcjtcblx0XHRcdFx0b2Zmc2V0ID0gYXJnMC5vZmZzZXQgfHwgYXJnMC5yYW1wUG9pbnQgfHwgMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0dGhpcy5zZXRPZmZzZXQob2Zmc2V0KTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fb2Zmc2V0KTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIGNvbG9yID0gdGhpcy5fY29sb3IsXG5cdFx0XHRvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKG9mZnNldCA9PSBudWxsID8gW2NvbG9yXSA6IFtjb2xvciwgb2Zmc2V0XSxcblx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vZmZzZXQ7XG5cdH0sXG5cblx0c2V0T2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogJyNnZXRPZmZzZXQnLFxuXHRzZXRSYW1wUG9pbnQ6ICcjc2V0T2Zmc2V0JyxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcblx0XHRpZiAoY29sb3IpXG5cdFx0XHRjb2xvci5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NvbG9yID0gY29sb3I7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3RvcCkge1xuXHRcdHJldHVybiBzdG9wID09PSB0aGlzIHx8IHN0b3AgJiYgdGhpcy5fY2xhc3MgPT09IHN0b3AuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX2NvbG9yLmVxdWFscyhzdG9wLl9jb2xvcilcblx0XHRcdFx0JiYgdGhpcy5fb2Zmc2V0ID09IHN0b3AuX29mZnNldFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBTdHlsZSA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGl0ZW1EZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cdFx0ZmlsbFJ1bGU6ICdub256ZXJvJyxcblx0XHRzdHJva2VDb2xvcjogbnVsbCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHNoYWRvd0NvbG9yOiBudWxsLFxuXHRcdHNoYWRvd0JsdXI6IDAsXG5cdFx0c2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcblx0XHRzZWxlY3RlZENvbG9yOiBudWxsXG5cdH0sXG5cdGdyb3VwRGVmYXVsdHMgPSBCYXNlLnNldCh7fSwgaXRlbURlZmF1bHRzLCB7XG5cdFx0Zm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuXHRcdGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuXHRcdGZvbnRTaXplOiAxMixcblx0XHRsZWFkaW5nOiBudWxsLFxuXHRcdGp1c3RpZmljYXRpb246ICdsZWZ0J1xuXHR9KSxcblx0dGV4dERlZmF1bHRzID0gQmFzZS5zZXQoe30sIGdyb3VwRGVmYXVsdHMsIHtcblx0XHRmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG5cdH0pLFxuXHRmbGFncyA9IHtcblx0XHRzdHJva2VXaWR0aDogOTcsXG5cdFx0c3Ryb2tlQ2FwOiA5Nyxcblx0XHRzdHJva2VKb2luOiA5Nyxcblx0XHRzdHJva2VTY2FsaW5nOiAxMDUsXG5cdFx0bWl0ZXJMaW1pdDogOTcsXG5cdFx0Zm9udEZhbWlseTogOSxcblx0XHRmb250V2VpZ2h0OiA5LFxuXHRcdGZvbnRTaXplOiA5LFxuXHRcdGZvbnQ6IDksXG5cdFx0bGVhZGluZzogOSxcblx0XHRqdXN0aWZpY2F0aW9uOiA5XG5cdH0sXG5cdGl0ZW0gPSB7XG5cdFx0YmVhbnM6IHRydWVcblx0fSxcblx0ZmllbGRzID0ge1xuXHRcdF9jbGFzczogJ1N0eWxlJyxcblx0XHRiZWFuczogdHJ1ZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN0eWxlKHN0eWxlLCBfb3duZXIsIF9wcm9qZWN0KSB7XG5cdFx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHRcdHRoaXMuX293bmVyID0gX293bmVyO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IF9vd25lciAmJiBfb3duZXIuX3Byb2plY3QgfHwgX3Byb2plY3Rcblx0XHRcdFx0XHR8fCBwYXBlci5wcm9qZWN0O1xuXHRcdFx0dGhpcy5fZGVmYXVsdHMgPSAhX293bmVyIHx8IF9vd25lciBpbnN0YW5jZW9mIEdyb3VwID8gZ3JvdXBEZWZhdWx0c1xuXHRcdFx0XHRcdDogX293bmVyIGluc3RhbmNlb2YgVGV4dEl0ZW0gPyB0ZXh0RGVmYXVsdHNcblx0XHRcdFx0XHQ6IGl0ZW1EZWZhdWx0cztcblx0XHRcdGlmIChzdHlsZSlcblx0XHRcdFx0dGhpcy5zZXQoc3R5bGUpO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goZ3JvdXBEZWZhdWx0cywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdHZhciBpc0NvbG9yID0gL0NvbG9yJC8udGVzdChrZXkpLFxuXHRcdFx0aXNQb2ludCA9IGtleSA9PT0gJ3NoYWRvd09mZnNldCcsXG5cdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRmbGFnID0gZmxhZ3Nba2V5XSxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydCxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydDtcblxuXHRcdGZpZWxkc1tzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbjtcblx0XHRcdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPiAwXG5cdFx0XHRcdFx0JiYgIShvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0Y2hpbGRyZW5baV0uX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0dmFyIG9sZCA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAob2xkICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChpc0NvbG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICYmIG9sZC5fb3duZXIgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdFx0b2xkLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLl9vd25lcilcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChvd25lcilcblx0XHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgNjUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZpZWxkc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMgJiYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoXG5cdFx0XHRcdFx0fHwgX2RvbnRNZXJnZSB8fCBvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jbG9uZSlcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcblx0XHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBpc0NvbG9yKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkcmVuW2ldLl9zdHlsZVtnZXRdKCk7XG5cdFx0XHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGNoaWxkVmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEJhc2UuZWFjaCh7XG5cdFx0Rm9udDogJ0ZvbnRGYW1pbHknLFxuXHRcdFdpbmRpbmdSdWxlOiAnRmlsbFJ1bGUnXG5cdH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgZ2V0ID0gJ2dldCcgKyBrZXksXG5cdFx0XHRzZXQgPSAnc2V0JyArIGtleTtcblx0XHRmaWVsZHNbZ2V0XSA9IGl0ZW1bZ2V0XSA9ICcjZ2V0JyArIHZhbHVlO1xuXHRcdGZpZWxkc1tzZXRdID0gaXRlbVtzZXRdID0gJyNzZXQnICsgdmFsdWU7XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRmdW5jdGlvbiBjb21wYXJlKHN0eWxlMSwgc3R5bGUyLCBzZWNvbmRhcnkpIHtcblx0XHRcdHZhciB2YWx1ZXMxID0gc3R5bGUxLl92YWx1ZXMsXG5cdFx0XHRcdHZhbHVlczIgPSBzdHlsZTIuX3ZhbHVlcyxcblx0XHRcdFx0ZGVmYXVsdHMyID0gc3R5bGUyLl9kZWZhdWx0cztcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMxKSB7XG5cdFx0XHRcdHZhciB2YWx1ZTEgPSB2YWx1ZXMxW2tleV0sXG5cdFx0XHRcdFx0dmFsdWUyID0gdmFsdWVzMltrZXldO1xuXHRcdFx0XHRpZiAoIShzZWNvbmRhcnkgJiYga2V5IGluIHZhbHVlczIpICYmICFCYXNlLmVxdWFscyh2YWx1ZTEsXG5cdFx0XHRcdFx0XHR2YWx1ZTIgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzMltrZXldIDogdmFsdWUyKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBjb21wYXJlKHRoaXMsIHN0eWxlKVxuXHRcdFx0XHQmJiBjb21wYXJlKHN0eWxlLCB0aGlzLCB0cnVlKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sb3IgPSB0aGlzLmdldEZpbGxDb2xvcigpO1xuXHRcdHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMDtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U3Ryb2tlQ29sb3IoKTtcblx0XHRyZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U2hhZG93Q29sb3IoKTtcblx0XHRyZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgKHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMFxuXHRcdFx0XHR8fCAhdGhpcy5nZXRTaGFkb3dPZmZzZXQoKS5pc1plcm8oKSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpXG5cdFx0XHRcdCsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKVxuXHRcdFx0XHQrIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuXHR9LFxuXG5cdGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG5cdHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cblx0Z2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcblx0XHR2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0aWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSlcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcblx0XHRyZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuXHR9XG5cbn0pO1xuXG52YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gWycnLCAnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbyddLFxuXHRcdFx0c3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcblx0XHRcdFx0a2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblx0XHRcdGlmIChrZXkgaW4gZWwpIHtcblx0XHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldFN0eWxlczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcblx0XHRcdFx0dmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRyZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG5cdFx0XHRcdHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblx0XHRcdGlmICghdmlld3BvcnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRcdHggKz0gdmlldy5wYWdlWE9mZnNldCB8fCBodG1sLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHR5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldFZpZXdwb3J0Qm91bmRzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdHZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCxcblx0XHRcdFx0dmlldy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsXG5cdFx0XHRcdHZpZXcuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHRcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldE9mZnNldDogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuXHRcdH0sXG5cblx0XHRnZXRTaXplOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKS5nZXRTaXplKCk7XG5cdFx0fSxcblxuXHRcdGlzSW52aXNpYmxlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0U2l6ZShlbCkuZXF1YWxzKG5ldyBTaXplKDAsIDApKTtcblx0XHR9LFxuXG5cdFx0aXNJblZpZXc6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpXG5cdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCk7XG5cdFx0fSxcblxuXHRcdGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsICYmIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpXG5cdFx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG52YXIgRG9tRXZlbnQgPSB7XG5cdGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwb3MgPSBldmVudC50YXJnZXRUb3VjaGVzXG5cdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGhcblx0XHRcdFx0XHQ/IGV2ZW50LnRhcmdldFRvdWNoZXNbMF1cblx0XHRcdFx0XHQ6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdXG5cdFx0XHRcdDogZXZlbnQ7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdHBvcy5wYWdlWCB8fCBwb3MuY2xpZW50WCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuXHRcdFx0cG9zLnBhZ2VZIHx8IHBvcy5jbGllbnRZICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0VGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudDtcblx0fSxcblxuXHRnZXRSZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRvRWxlbWVudDtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGV2ZW50LCB0YXJnZXQpIHtcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0UG9pbnQoZXZlbnQpLnN1YnRyYWN0KERvbUVsZW1lbnQuZ2V0T2Zmc2V0KFxuXHRcdFx0XHR0YXJnZXQgfHwgRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KSkpO1xuXHR9XG59O1xuXG5Eb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBuYXRpdmVSZXF1ZXN0ID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcblx0XHRyZXF1ZXN0ZWQgPSBmYWxzZSxcblx0XHRjYWxsYmFja3MgPSBbXSxcblx0XHR0aW1lcjtcblxuXHRmdW5jdGlvbiBoYW5kbGVDYWxsYmFja3MoKSB7XG5cdFx0dmFyIGZ1bmN0aW9ucyA9IGNhbGxiYWNrcztcblx0XHRjYWxsYmFja3MgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGZ1bmN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRmdW5jdGlvbnNbaV0oKTtcblx0XHRyZXF1ZXN0ZWQgPSBuYXRpdmVSZXF1ZXN0ICYmIGNhbGxiYWNrcy5sZW5ndGg7XG5cdFx0aWYgKHJlcXVlc3RlZClcblx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKCFyZXF1ZXN0ZWQpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0XHRyZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIXRpbWVyKSB7XG5cdFx0XHR0aW1lciA9IHNldEludGVydmFsKGhhbmRsZUNhbGxiYWNrcywgMTAwMCAvIDYwKTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgVmlldyA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0X2NsYXNzOiAnVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVmlldyhwcm9qZWN0LCBlbGVtZW50KSB7XG5cblx0XHRmdW5jdGlvbiBnZXRTaXplKG5hbWUpIHtcblx0XHRcdHJldHVybiBlbGVtZW50W25hbWVdIHx8IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpLCAxMCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q2FudmFzU2l6ZSgpIHtcblx0XHRcdHZhciBzaXplID0gRG9tRWxlbWVudC5nZXRTaXplKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIHNpemUuaXNOYU4oKSB8fCBzaXplLmlzWmVybygpXG5cdFx0XHRcdFx0PyBuZXcgU2l6ZShnZXRTaXplKCd3aWR0aCcpLCBnZXRTaXplKCdoZWlnaHQnKSlcblx0XHRcdFx0XHQ6IHNpemU7XG5cdFx0fVxuXG5cdFx0dmFyIHNpemU7XG5cdFx0aWYgKHdpbmRvdyAmJiBlbGVtZW50KSB7XG5cdFx0XHR0aGlzLl9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRcdFx0aWYgKHRoaXMuX2lkID09IG51bGwpXG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKyspO1xuXHRcdFx0RG9tRXZlbnQuYWRkKGVsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdFx0dmFyIG5vbmUgPSAnbm9uZSc7XG5cdFx0XHREb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdFx0dXNlckRyYWc6IG5vbmUsXG5cdFx0XHRcdHVzZXJTZWxlY3Q6IG5vbmUsXG5cdFx0XHRcdHRvdWNoQ2FsbG91dDogbm9uZSxcblx0XHRcdFx0Y29udGVudFpvb21pbmc6IG5vbmUsXG5cdFx0XHRcdHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzID0ge1xuXHRcdFx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGF0LnNldFZpZXdTaXplKGdldENhbnZhc1NpemUoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0c2l6ZSA9IGdldENhbnZhc1NpemUoKTtcblxuXHRcdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpXG5cdFx0XHRcdFx0JiYgdHlwZW9mIFN0YXRzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aGlzLl9zdGF0cyA9IG5ldyBTdGF0cygpO1xuXHRcdFx0XHR2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuXHRcdFx0XHRcdHN0eWxlID0gc3RhdHMuc3R5bGUsXG5cdFx0XHRcdFx0b2Zmc2V0ID0gRG9tRWxlbWVudC5nZXRPZmZzZXQoZWxlbWVudCk7XG5cdFx0XHRcdHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdFx0c3R5bGUubGVmdCA9IG9mZnNldC54ICsgJ3B4Jztcblx0XHRcdFx0c3R5bGUudG9wID0gb2Zmc2V0LnkgKyAncHgnO1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGVsZW1lbnQpO1xuXHRcdFx0ZWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXHRcdHRoaXMuX3NldEVsZW1lbnRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHR0aGlzLl92aWV3U2l6ZSA9IHNpemU7XG5cdFx0Vmlldy5fdmlld3MucHVzaCh0aGlzKTtcblx0XHRWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcblx0XHQodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuXHRcdGlmICghVmlldy5fZm9jdXNlZClcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0aGlzO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5faXRlbUV2ZW50cyA9IHsgbmF0aXZlOiB7fSwgdmlydHVhbDoge30gfTtcblx0XHR0aGlzLl9hdXRvVXBkYXRlID0gIXBhcGVyLmFnZW50Lm5vZGU7XG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJvamVjdClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAoVmlldy5fZm9jdXNlZCA9PT0gdGhpcylcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSBudWxsO1xuXHRcdFZpZXcuX3ZpZXdzLnNwbGljZShWaWV3Ll92aWV3cy5pbmRleE9mKHRoaXMpLCAxKTtcblx0XHRkZWxldGUgVmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXTtcblx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKHByb2plY3QuX3ZpZXcgPT09IHRoaXMpXG5cdFx0XHRwcm9qZWN0Ll92aWV3ID0gbnVsbDtcblx0XHREb21FdmVudC5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcblx0XHR0aGlzLl9lbGVtZW50ID0gdGhpcy5fcHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5vZmYoJ2ZyYW1lJyk7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZXZlbnRzOiBCYXNlLmVhY2goXG5cdFx0SXRlbS5faXRlbUhhbmRsZXJzLmNvbmNhdChbJ29uUmVzaXplJywgJ29uS2V5RG93bicsICdvbktleVVwJ10pLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB7fTtcblx0XHR9LCB7XG5cdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMucGxheSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHQpLFxuXG5cdF9hbmltYXRlOiBmYWxzZSxcblx0X3RpbWU6IDAsXG5cdF9jb3VudDogMCxcblxuXHRnZXRBdXRvVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcblx0fSxcblxuXHRzZXRBdXRvVXBkYXRlOiBmdW5jdGlvbihhdXRvVXBkYXRlKSB7XG5cdFx0dGhpcy5fYXV0b1VwZGF0ZSA9IGF1dG9VcGRhdGU7XG5cdFx0aWYgKGF1dG9VcGRhdGUpXG5cdFx0XHR0aGlzLnJlcXVlc3RVcGRhdGUoKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0cmVxdWVzdFVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9yZXF1ZXN0ZWQpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdERvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5fcmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHRcdGlmICh0aGF0Ll9hbmltYXRlKSB7XG5cdFx0XHRcdFx0dGhhdC5yZXF1ZXN0VXBkYXRlKCk7XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGF0Ll9lbGVtZW50O1xuXHRcdFx0XHRcdGlmICgoIURvbUVsZW1lbnQuZ2V0UHJlZml4ZWQoZG9jdW1lbnQsICdoaWRkZW4nKVxuXHRcdFx0XHRcdFx0XHR8fCBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShlbGVtZW50LCAna2VlcGFsaXZlJylcblx0XHRcdFx0XHRcdFx0XHQ9PT0gJ3RydWUnKSAmJiBEb21FbGVtZW50LmlzSW5WaWV3KGVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0XHR0aGF0Ll9oYW5kbGVGcmFtZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhhdC5fYXV0b1VwZGF0ZSlcblx0XHRcdFx0XHR0aGF0LnVwZGF0ZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gdHJ1ZTtcblx0XHR0aGlzLnJlcXVlc3RVcGRhdGUoKTtcblx0fSxcblxuXHRwYXVzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDAsXG5cdFx0XHRkZWx0YSA9IHRoaXMuX2xhc3QgPyBub3cgLSB0aGlzLl9sYXN0IDogMDtcblx0XHR0aGlzLl9sYXN0ID0gbm93O1xuXHRcdHRoaXMuZW1pdCgnZnJhbWUnLCBuZXcgQmFzZSh7XG5cdFx0XHRkZWx0YTogZGVsdGEsXG5cdFx0XHR0aW1lOiB0aGlzLl90aW1lICs9IGRlbHRhLFxuXHRcdFx0Y291bnQ6IHRoaXMuX2NvdW50Kytcblx0XHR9KSk7XG5cdFx0aWYgKHRoaXMuX3N0YXRzKVxuXHRcdFx0dGhpcy5fc3RhdHMudXBkYXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGVJdGVtOiBmdW5jdGlvbihpdGVtLCBhbmltYXRlKSB7XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fZnJhbWVJdGVtcztcblx0XHRpZiAoYW5pbWF0ZSkge1xuXHRcdFx0aXRlbXNbaXRlbS5faWRdID0ge1xuXHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHR0aW1lOiAwLFxuXHRcdFx0XHRjb3VudDogMFxuXHRcdFx0fTtcblx0XHRcdGlmICgrK3RoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAxKVxuXHRcdFx0XHR0aGlzLm9uKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgaXRlbXNbaXRlbS5faWRdO1xuXHRcdFx0aWYgKC0tdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDApIHtcblx0XHRcdFx0dGhpcy5vZmYoJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZUl0ZW1zOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fZnJhbWVJdGVtcykge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZnJhbWVJdGVtc1tpXTtcblx0XHRcdGVudHJ5Lml0ZW0uZW1pdCgnZnJhbWUnLCBuZXcgQmFzZShldmVudCwge1xuXHRcdFx0XHR0aW1lOiBlbnRyeS50aW1lICs9IGV2ZW50LmRlbHRhLFxuXHRcdFx0XHRjb3VudDogZW50cnkuY291bnQrK1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5fY2hhbmdlZCgyMDQ5KTtcblx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9kZWNvbXBvc2VkID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHR9LFxuXG5cdGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG5cdH0sXG5cblx0Z2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcblx0fSxcblxuXHRzZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG5cdFx0aWYgKGRlbHRhLmlzWmVybygpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3NldEVsZW1lbnRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHR0aGlzLl92aWV3U2l6ZS5zZXQoc2l6ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHRoaXMuZW1pdCgncmVzaXplJywgeyBzaXplOiBzaXplLCBkZWx0YTogZGVsdGEgfSk7XG5cdFx0aWYgKHRoaXMuX2F1dG9VcGRhdGUpIHtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRFbGVtZW50U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0aWYgKGVsZW1lbnQud2lkdGggIT09IHdpZHRoKVxuXHRcdFx0XHRlbGVtZW50LndpZHRoID0gd2lkdGg7XG5cdFx0XHRpZiAoZWxlbWVudC5oZWlnaHQgIT09IGhlaWdodClcblx0XHRcdFx0ZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9tYXRyaXguaW52ZXJ0ZWQoKS5fdHJhbnNmb3JtQm91bmRzKFxuXHRcdFx0XHRcdG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIHRoaXMuX3ZpZXdTaXplKSk7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRTaXplKCk7XG5cdH0sXG5cblx0aXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRG9tRWxlbWVudC5pc0luVmlldyh0aGlzLl9lbGVtZW50KTtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRG9tRWxlbWVudC5pc0luc2VydGVkKHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdGdldFBpeGVsU2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcblx0XHRcdHBpeGVscztcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSxcblx0XHRcdFx0dGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0dGVtcC5zdHlsZS5mb250U2l6ZSA9IHNpemU7XG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQodGVtcCk7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KERvbUVsZW1lbnQuZ2V0U3R5bGVzKHRlbXApLmZvbnRTaXplKTtcblx0XHRcdHBhcmVudC5yZW1vdmVDaGlsZCh0ZW1wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChwaXhlbHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWxzO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxufSwgQmFzZS5lYWNoKFsncm90YXRlJywgJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciByb3RhdGUgPSBrZXkgPT09ICdyb3RhdGUnO1xuXHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSAocm90YXRlID8gQmFzZSA6IFBvaW50KS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW2tleV0odmFsdWUsXG5cdFx0XHRcdGNlbnRlciB8fCB0aGlzLmdldENlbnRlcih0cnVlKSkpO1xuXHR9O1xufSwge1xuXHRfZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVjb21wb3NlZCB8fCAodGhpcy5fZGVjb21wb3NlZCA9IHRoaXMuX21hdHJpeC5kZWNvbXBvc2UoKSk7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbXggPSBuZXcgTWF0cml4KCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcblx0fSxcblxuXHRzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy50cmFuc2xhdGUodGhpcy5nZXRDZW50ZXIoKS5zdWJ0cmFjdChjZW50ZXIpKTtcblx0fSxcblxuXHRnZXRab29tOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZSgpLFxuXHRcdFx0c2NhbGluZyA9IGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nO1xuXHRcdHJldHVybiBzY2FsaW5nID8gKHNjYWxpbmcueCArIHNjYWxpbmcueSkgLyAyIDogMDtcblx0fSxcblxuXHRzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG5cdFx0dGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnNjYWxlKHpvb20gLyB0aGlzLmdldFpvb20oKSxcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnJvdGF0aW9uO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKSxcblx0XHRcdHNjYWxpbmcgPSBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZztcblx0XHRyZXR1cm4gc2NhbGluZ1xuXHRcdFx0XHQ/IG5ldyBMaW5rZWRQb2ludChzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKVxuXHRcdFx0XHQ6IHVuZGVmaW5lZDtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuXHRcdFx0c2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY3VycmVudCAmJiBzY2FsaW5nKSB7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRtYXRyaXguaW5pdGlhbGl6ZS5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguYXBwZW5kKG1hdHJpeCk7XG5cdH0sXG5cblx0c2Nyb2xsQnk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5uZWdhdGUoKSk7XG5cdH1cbn0pLCB7XG5cblx0cHJvamVjdFRvVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHR2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0RXZlbnRQb2ludDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdGhpcy5fZWxlbWVudCkpO1xuXHR9LFxuXG59LCB7XG5cdHN0YXRpY3M6IHtcblx0XHRfdmlld3M6IFtdLFxuXHRcdF92aWV3c0J5SWQ6IHt9LFxuXHRcdF9pZDogMCxcblxuXHRcdGNyZWF0ZTogZnVuY3Rpb24ocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdFx0aWYgKGRvY3VtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXHRcdFx0dmFyIGN0b3IgPSB3aW5kb3cgPyBDYW52YXNWaWV3IDogVmlldztcblx0XHRcdHJldHVybiBuZXcgY3Rvcihwcm9qZWN0LCBlbGVtZW50KTtcblx0XHR9XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGlmICghd2luZG93KVxuXHRcdHJldHVybjtcblx0dmFyIHByZXZGb2N1cyxcblx0XHR0ZW1wRm9jdXMsXG5cdFx0ZHJhZ2dpbmcgPSBmYWxzZSxcblx0XHRtb3VzZURvd24gPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBnZXRWaWV3KGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldCA9IERvbUV2ZW50LmdldFRhcmdldChldmVudCk7XG5cdFx0cmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgVmlldy5fdmlld3NCeUlkW1xuXHRcdFx0XHR0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIXZpZXcgfHwgIXZpZXcuaXNWaXNpYmxlKCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gVmlldy5fdmlld3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICgodmlldyA9IFZpZXcuX3ZpZXdzW2ldKS5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCBwb2ludCkge1xuXHRcdHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCk7XG5cdH1cblxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblx0XHRtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cDtcblx0aWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuXHRcdG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcblx0XHRtb3VzZW1vdmUgPSAncG9pbnRlcm1vdmUgTVNQb2ludGVyTW92ZSc7XG5cdFx0bW91c2V1cCA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuXHR9IGVsc2Uge1xuXHRcdG1vdXNlZG93biA9ICd0b3VjaHN0YXJ0Jztcblx0XHRtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcblx0XHRtb3VzZXVwID0gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJztcblx0XHRpZiAoISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcblx0XHRcdFx0L21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kpKSkge1xuXHRcdFx0bW91c2Vkb3duICs9ICcgbW91c2Vkb3duJztcblx0XHRcdG1vdXNlbW92ZSArPSAnIG1vdXNlbW92ZSc7XG5cdFx0XHRtb3VzZXVwICs9ICcgbW91c2V1cCc7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHZpZXdFdmVudHMgPSB7fSxcblx0XHRkb2NFdmVudHMgPSB7XG5cdFx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuXHRcdFx0XHRcdHRhcmdldCA9IERvbUV2ZW50LmdldFJlbGF0ZWRUYXJnZXQoZXZlbnQpO1xuXHRcdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpIHtcblx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gRG9tRXZlbnQuZ2V0T2Zmc2V0KGV2ZW50LCB2aWV3Ll9lbGVtZW50KSxcblx0XHRcdFx0XHRcdHggPSBvZmZzZXQueCxcblx0XHRcdFx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRcdFx0YXggPSBhYnMoeCksXG5cdFx0XHRcdFx0XHRtYXggPSAxIDw8IDI1LFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGF4IC0gbWF4O1xuXHRcdFx0XHRcdG9mZnNldC54ID0gYWJzKGRpZmYpIDwgYXggPyBkaWZmICogKHggPCAwID8gLTEgOiAxKSA6IHg7XG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCB2aWV3LnZpZXdUb1Byb2plY3Qob2Zmc2V0KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHNjcm9sbDogdXBkYXRlRm9jdXNcblx0XHR9O1xuXG5cdHZpZXdFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gZ2V0VmlldyhldmVudCk7XG5cdFx0aWYgKCFkcmFnZ2luZykge1xuXHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0dmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2Vkb3duJywgZXZlbnQpO1xuXHRcdH1cblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2Vtb3ZlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghbW91c2VEb3duKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0XHRpZiAodmlldylcblx0XHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCk7XG5cdFx0XHRcdFx0aWYgKCFwcmV2Rm9jdXMpXG5cdFx0XHRcdFx0XHRwcmV2Rm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRlbXBGb2N1cyAmJiB0ZW1wRm9jdXMgPT09IHZpZXcpIHtcblx0XHRcdFx0aWYgKHByZXZGb2N1cyAmJiAhcHJldkZvY3VzLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0XHRwcmV2Rm9jdXMgPSBudWxsO1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcblx0XHRcdFx0cHJldkZvY3VzID0gbnVsbDtcblx0XHRcdFx0dXBkYXRlRm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZpZXcpXG5cdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQpO1xuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oKSB7XG5cdFx0bW91c2VEb3duID0gdHJ1ZTtcblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2V1cF0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAodmlldyAmJiBkcmFnZ2luZylcblx0XHRcdHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNldXAnLCBldmVudCk7XG5cdFx0bW91c2VEb3duID0gZHJhZ2dpbmcgPSBmYWxzZTtcblx0fTtcblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIGRvY0V2ZW50cyk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGxvYWQ6IHVwZGF0ZUZvY3VzXG5cdH0pO1xuXG5cdHZhciBjYWxsZWQgPSBmYWxzZSxcblx0XHRwcmV2ZW50ZWQgPSBmYWxzZSxcblx0XHRmYWxsYmFja3MgPSB7XG5cdFx0XHRkb3VibGVjbGljazogJ2NsaWNrJyxcblx0XHRcdG1vdXNlZHJhZzogJ21vdXNlbW92ZSdcblx0XHR9LFxuXHRcdHdhc0luVmlldyA9IGZhbHNlLFxuXHRcdG92ZXJWaWV3LFxuXHRcdGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0ZG93bkl0ZW0sXG5cdFx0b3Zlckl0ZW0sXG5cdFx0ZHJhZ0l0ZW0sXG5cdFx0Y2xpY2tJdGVtLFxuXHRcdGNsaWNrVGltZSxcblx0XHRkYmxDbGljaztcblxuXHRmdW5jdGlvbiBlbWl0TW91c2VFdmVudChvYmosIHRhcmdldCwgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQsXG5cdFx0XHRzdG9wSXRlbSkge1xuXHRcdHZhciBzdG9wcGVkID0gZmFsc2UsXG5cdFx0XHRtb3VzZUV2ZW50O1xuXG5cdFx0ZnVuY3Rpb24gZW1pdChvYmosIHR5cGUpIHtcblx0XHRcdGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdFx0aWYgKCFtb3VzZUV2ZW50KSB7XG5cdFx0XHRcdFx0bW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0IHx8IG9iaixcblx0XHRcdFx0XHRcdFx0cHJldlBvaW50ID8gcG9pbnQuc3VidHJhY3QocHJldlBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSkge1xuXHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKG1vdXNlRXZlbnQucHJldmVudGVkKVxuXHRcdFx0XHRcdFx0cHJldmVudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAobW91c2VFdmVudC5zdG9wcGVkKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbdHlwZV07XG5cdFx0XHRcdGlmIChmYWxsYmFjaylcblx0XHRcdFx0XHRyZXR1cm4gZW1pdChvYmosIGZhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAob2JqICYmIG9iaiAhPT0gc3RvcEl0ZW0pIHtcblx0XHRcdGlmIChlbWl0KG9iaiwgdHlwZSkpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0b2JqID0gb2JqLl9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBzdG9wcGVkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW1pdE1vdXNlRXZlbnRzKHZpZXcsIGhpdEl0ZW0sIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50KSB7XG5cdFx0dmlldy5fcHJvamVjdC5yZW1vdmVPbih0eXBlKTtcblx0XHRwcmV2ZW50ZWQgPSBjYWxsZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gKGRyYWdJdGVtICYmIGVtaXRNb3VzZUV2ZW50KGRyYWdJdGVtLCBudWxsLCB0eXBlLCBldmVudCxcblx0XHRcdFx0XHRwb2ludCwgcHJldlBvaW50KVxuXHRcdFx0fHwgaGl0SXRlbSAmJiBoaXRJdGVtICE9PSBkcmFnSXRlbVxuXHRcdFx0XHQmJiAhaGl0SXRlbS5pc0Rlc2NlbmRhbnQoZHJhZ0l0ZW0pXG5cdFx0XHRcdCYmIGVtaXRNb3VzZUV2ZW50KGhpdEl0ZW0sIG51bGwsIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50LFxuXHRcdFx0XHRcdGRyYWdJdGVtKVxuXHRcdFx0fHwgZW1pdE1vdXNlRXZlbnQodmlldywgZHJhZ0l0ZW0gfHwgaGl0SXRlbSB8fCB2aWV3LCB0eXBlLCBldmVudCxcblx0XHRcdFx0XHRwb2ludCwgcHJldlBvaW50KSk7XG5cdH1cblxuXHR2YXIgaXRlbUV2ZW50c01hcCA9IHtcblx0XHRtb3VzZWRvd246IHtcblx0XHRcdG1vdXNlZG93bjogMSxcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHR9LFxuXHRcdG1vdXNldXA6IHtcblx0XHRcdG1vdXNldXA6IDEsXG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRjbGljazogMSxcblx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0fSxcblx0XHRtb3VzZW1vdmU6IHtcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdG1vdXNlbW92ZTogMSxcblx0XHRcdG1vdXNlZW50ZXI6IDEsXG5cdFx0XHRtb3VzZWxlYXZlOiAxXG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0X3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG5cblx0XHRfaGFuZGxlTW91c2VFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQsIHBvaW50KSB7XG5cdFx0XHR2YXIgaXRlbUV2ZW50cyA9IHRoaXMuX2l0ZW1FdmVudHMsXG5cdFx0XHRcdGhpdEl0ZW1zID0gaXRlbUV2ZW50cy5uYXRpdmVbdHlwZV0sXG5cdFx0XHRcdG5hdGl2ZU1vdmUgPSB0eXBlID09PSAnbW91c2Vtb3ZlJyxcblx0XHRcdFx0dG9vbCA9IHRoaXMuX3Njb3BlLnRvb2wsXG5cdFx0XHRcdHZpZXcgPSB0aGlzO1xuXG5cdFx0XHRmdW5jdGlvbiByZXNwb25kcyh0eXBlKSB7XG5cdFx0XHRcdHJldHVybiBpdGVtRXZlbnRzLnZpcnR1YWxbdHlwZV0gfHwgdmlldy5yZXNwb25kcyh0eXBlKVxuXHRcdFx0XHRcdFx0fHwgdG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmF0aXZlTW92ZSAmJiBkcmFnZ2luZyAmJiByZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdHR5cGUgPSAnbW91c2VkcmFnJztcblx0XHRcdGlmICghcG9pbnQpXG5cdFx0XHRcdHBvaW50ID0gdGhpcy5nZXRFdmVudFBvaW50KGV2ZW50KTtcblxuXHRcdFx0dmFyIGluVmlldyA9IHRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQpLFxuXHRcdFx0XHRoaXQgPSBoaXRJdGVtcyAmJiBpblZpZXcgJiYgdmlldy5fcHJvamVjdC5oaXRUZXN0KHBvaW50LCB7XG5cdFx0XHRcdFx0dG9sZXJhbmNlOiAwLFxuXHRcdFx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRcdFx0c3Ryb2tlOiB0cnVlXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRoaXRJdGVtID0gaGl0ICYmIGhpdC5pdGVtIHx8IG51bGwsXG5cdFx0XHRcdGhhbmRsZSA9IGZhbHNlLFxuXHRcdFx0XHRtb3VzZSA9IHt9O1xuXHRcdFx0bW91c2VbdHlwZS5zdWJzdHIoNSldID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGhpdEl0ZW1zICYmIGhpdEl0ZW0gIT09IG92ZXJJdGVtKSB7XG5cdFx0XHRcdGlmIChvdmVySXRlbSkge1xuXHRcdFx0XHRcdGVtaXRNb3VzZUV2ZW50KG92ZXJJdGVtLCBudWxsLCAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhpdEl0ZW0pIHtcblx0XHRcdFx0XHRlbWl0TW91c2VFdmVudChoaXRJdGVtLCBudWxsLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3Zlckl0ZW0gPSBoaXRJdGVtO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHdhc0luVmlldyBeIGluVmlldykge1xuXHRcdFx0XHRlbWl0TW91c2VFdmVudCh0aGlzLCBudWxsLCBpblZpZXcgPyAnbW91c2VlbnRlcicgOiAnbW91c2VsZWF2ZScsXG5cdFx0XHRcdFx0XHRldmVudCwgcG9pbnQpO1xuXHRcdFx0XHRvdmVyVmlldyA9IGluVmlldyA/IHRoaXMgOiBudWxsO1xuXHRcdFx0XHRoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChpblZpZXcgfHwgbW91c2UuZHJhZykgJiYgIXBvaW50LmVxdWFscyhsYXN0UG9pbnQpKSB7XG5cdFx0XHRcdGVtaXRNb3VzZUV2ZW50cyh0aGlzLCBoaXRJdGVtLCBuYXRpdmVNb3ZlID8gdHlwZSA6ICdtb3VzZW1vdmUnLFxuXHRcdFx0XHRcdFx0ZXZlbnQsIHBvaW50LCBsYXN0UG9pbnQpO1xuXHRcdFx0XHRoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0d2FzSW5WaWV3ID0gaW5WaWV3O1xuXHRcdFx0aWYgKG1vdXNlLmRvd24gJiYgaW5WaWV3IHx8IG1vdXNlLnVwICYmIGRvd25Qb2ludCkge1xuXHRcdFx0XHRlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgdHlwZSwgZXZlbnQsIHBvaW50LCBkb3duUG9pbnQpO1xuXHRcdFx0XHRpZiAobW91c2UuZG93bikge1xuXHRcdFx0XHRcdGRibENsaWNrID0gaGl0SXRlbSA9PT0gY2xpY2tJdGVtXG5cdFx0XHRcdFx0XHQmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG5cdFx0XHRcdFx0ZG93bkl0ZW0gPSBjbGlja0l0ZW0gPSBoaXRJdGVtO1xuXHRcdFx0XHRcdGlmICghcHJldmVudGVkICYmIGhpdEl0ZW0pIHtcblx0XHRcdFx0XHRcdHZhciBpdGVtID0gaGl0SXRlbTtcblx0XHRcdFx0XHRcdHdoaWxlIChpdGVtICYmICFpdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0XHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHRcdFx0XHRcdGlmIChpdGVtKVxuXHRcdFx0XHRcdFx0XHRkcmFnSXRlbSA9IGhpdEl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvd25Qb2ludCA9IHBvaW50O1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1vdXNlLnVwKSB7XG5cdFx0XHRcdFx0aWYgKCFwcmV2ZW50ZWQgJiYgaGl0SXRlbSA9PT0gZG93bkl0ZW0pIHtcblx0XHRcdFx0XHRcdGNsaWNrVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0XHRlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgZGJsQ2xpY2sgPyAnZG91YmxlY2xpY2snXG5cdFx0XHRcdFx0XHRcdFx0OiAnY2xpY2snLCBldmVudCwgcG9pbnQsIGRvd25Qb2ludCk7XG5cdFx0XHRcdFx0XHRkYmxDbGljayA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb3duSXRlbSA9IGRyYWdJdGVtID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3YXNJblZpZXcgPSBmYWxzZTtcblx0XHRcdFx0aGFuZGxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGxhc3RQb2ludCA9IHBvaW50O1xuXHRcdFx0aWYgKGhhbmRsZSAmJiB0b29sKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRvb2wuX2hhbmRsZU1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCBtb3VzZSlcblx0XHRcdFx0XHR8fCBjYWxsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWxsZWQgJiYgIW1vdXNlLm1vdmUgfHwgbW91c2UuZG93biAmJiByZXNwb25kcygnbW91c2V1cCcpKVxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0sXG5cblx0XHRfaGFuZGxlS2V5RXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBrZXksIGNoYXJhY3Rlcikge1xuXHRcdFx0dmFyIHNjb3BlID0gdGhpcy5fc2NvcGUsXG5cdFx0XHRcdHRvb2wgPSBzY29wZS50b29sLFxuXHRcdFx0XHRrZXlFdmVudDtcblxuXHRcdFx0ZnVuY3Rpb24gZW1pdChvYmopIHtcblx0XHRcdFx0aWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHRcdFx0b2JqLmVtaXQodHlwZSwga2V5RXZlbnQgPSBrZXlFdmVudFxuXHRcdFx0XHRcdFx0XHR8fCBuZXcgS2V5RXZlbnQodHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0ZW1pdCh0aGlzKTtcblx0XHRcdFx0aWYgKHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKSlcblx0XHRcdFx0XHRlbWl0KHRvb2wpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfY291bnRJdGVtRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHNpZ24pIHtcblx0XHRcdHZhciBpdGVtRXZlbnRzID0gdGhpcy5faXRlbUV2ZW50cyxcblx0XHRcdFx0bmF0aXZlID0gaXRlbUV2ZW50cy5uYXRpdmUsXG5cdFx0XHRcdHZpcnR1YWwgPSBpdGVtRXZlbnRzLnZpcnR1YWw7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gaXRlbUV2ZW50c01hcCkge1xuXHRcdFx0XHRuYXRpdmVba2V5XSA9IChuYXRpdmVba2V5XSB8fCAwKVxuXHRcdFx0XHRcdFx0KyAoaXRlbUV2ZW50c01hcFtrZXldW3R5cGVdIHx8IDApICogc2lnbjtcblx0XHRcdH1cblx0XHRcdHZpcnR1YWxbdHlwZV0gPSAodmlydHVhbFt0eXBlXSB8fCAwKSArIHNpZ247XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQpKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdFx0aWYgKHNpemUuaXNaZXJvKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICdcblx0XHRcdFx0XHRcdCsgQmFzZS5zbGljZShhcmd1bWVudHMsIDEpKTtcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcblx0XHR9XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGlmICghL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG5cdFx0XHR2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQoY3R4LFxuXHRcdFx0XHRcdFx0J2JhY2tpbmdTdG9yZVBpeGVsUmF0aW8nKSB8fCAxO1xuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdFx0fVxuXHRcdFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuXHRcdHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHR0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKTtcblx0fSxcblxuXHRfc2V0RWxlbWVudFNpemU6IGZ1bmN0aW9uIF9zZXRFbGVtZW50U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvO1xuXHRcdF9zZXRFbGVtZW50U2l6ZS5iYXNlLmNhbGwodGhpcywgd2lkdGggKiBwaXhlbFJhdGlvLCBoZWlnaHQgKiBwaXhlbFJhdGlvKTtcblx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuXHRcdFx0XHRjdHggPSB0aGlzLl9jb250ZXh0O1xuXHRcdFx0aWYgKCFQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbiBnZXRQaXhlbFNpemUoc2l6ZSkge1xuXHRcdHZhciBhZ2VudCA9IHBhcGVyLmFnZW50LFxuXHRcdFx0cGl4ZWxzO1xuXHRcdGlmIChhZ2VudCAmJiBhZ2VudC5maXJlZm94KSB7XG5cdFx0XHRwaXhlbHMgPSBnZXRQaXhlbFNpemUuYmFzZS5jYWxsKHRoaXMsIHNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdFx0cHJldkZvbnQgPSBjdHguZm9udDtcblx0XHRcdGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChjdHguZm9udCk7XG5cdFx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWxzO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQsXG5cdFx0XHR3aWR0aCA9IDA7XG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX25lZWRzVXBkYXRlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcblx0XHRpZiAocHJvamVjdClcblx0XHRcdHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG5cdFx0dGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBFdmVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEV2ZW50KGV2ZW50KSB7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdHRoaXMudHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGU7XG5cdH0sXG5cblx0cHJldmVudGVkOiBmYWxzZSxcblx0c3RvcHBlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJldmVudGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR0aGlzLnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0Z2V0VGltZVN0YW1wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudC50aW1lU3RhbXA7XG5cdH0sXG5cblx0Z2V0TW9kaWZpZXJzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gS2V5Lm1vZGlmaWVycztcblx0fVxufSk7XG5cbnZhciBLZXlFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ0tleUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBLZXlFdmVudCh0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpIHtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0XHR0aGlzLmtleSA9IGtleTtcblx0XHR0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3Rlcjtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIGtleTogJ1wiICsgdGhpcy5rZXlcblx0XHRcdFx0KyBcIicsIGNoYXJhY3RlcjogJ1wiICsgdGhpcy5jaGFyYWN0ZXJcblx0XHRcdFx0KyBcIicsIG1vZGlmaWVyczogXCIgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgXCIgfVwiO1xuXHR9XG59KTtcblxudmFyIEtleSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGtleUxvb2t1cCA9IHtcblx0XHRcdCdcXHQnOiAndGFiJyxcblx0XHRcdCcgJzogJ3NwYWNlJyxcblx0XHRcdCdcXGInOiAnYmFja3NwYWNlJyxcblx0XHRcdCdcXHg3Zic6ICdkZWxldGUnLFxuXHRcdFx0J1NwYWNlYmFyJzogJ3NwYWNlJyxcblx0XHRcdCdEZWwnOiAnZGVsZXRlJyxcblx0XHRcdCdXaW4nOiAnbWV0YScsXG5cdFx0XHQnRXNjJzogJ2VzY2FwZSdcblx0XHR9LFxuXG5cdFx0Y2hhckxvb2t1cCA9IHtcblx0XHRcdCd0YWInOiAnXFx0Jyxcblx0XHRcdCdzcGFjZSc6ICcgJyxcblx0XHRcdCdlbnRlcic6ICdcXHInXG5cdFx0fSxcblxuXHRcdGtleU1hcCA9IHt9LFxuXHRcdGNoYXJNYXAgPSB7fSxcblx0XHRtZXRhRml4TWFwLFxuXHRcdGRvd25LZXksXG5cblx0XHRtb2RpZmllcnMgPSBuZXcgQmFzZSh7XG5cdFx0XHRzaGlmdDogZmFsc2UsXG5cdFx0XHRjb250cm9sOiBmYWxzZSxcblx0XHRcdGFsdDogZmFsc2UsXG5cdFx0XHRtZXRhOiBmYWxzZSxcblx0XHRcdGNhcHNMb2NrOiBmYWxzZSxcblx0XHRcdHNwYWNlOiBmYWxzZVxuXHRcdH0pLmluamVjdCh7XG5cdFx0XHRvcHRpb246IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hbHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGNvbW1hbmQ6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgYWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcblx0XHRcdFx0XHRyZXR1cm4gYWdlbnQgJiYgYWdlbnQubWFjID8gdGhpcy5tZXRhIDogdGhpcy5jb250cm9sO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0S2V5KGV2ZW50KSB7XG5cdFx0dmFyIGtleSA9IGV2ZW50LmtleSB8fCBldmVudC5rZXlJZGVudGlmaWVyO1xuXHRcdGtleSA9IC9eVVxcKy8udGVzdChrZXkpXG5cdFx0XHRcdD8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChrZXkuc3Vic3RyKDIpLCAxNikpXG5cdFx0XHRcdDogL15BcnJvd1tBLVpdLy50ZXN0KGtleSkgPyBrZXkuc3Vic3RyKDUpXG5cdFx0XHRcdDoga2V5ID09PSAnVW5pZGVudGlmaWVkJyAgfHwga2V5ID09PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSlcblx0XHRcdFx0XHQ6IGtleTtcblx0XHRyZXR1cm4ga2V5TG9va3VwW2tleV0gfHxcblx0XHRcdFx0KGtleS5sZW5ndGggPiAxID8gQmFzZS5oeXBoZW5hdGUoa2V5KSA6IGtleS50b0xvd2VyQ2FzZSgpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUtleShkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpIHtcblx0XHR2YXIgdHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLFxuXHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRuYW1lO1xuXHRcdGtleU1hcFtrZXldID0gZG93bjtcblx0XHRpZiAoZG93bikge1xuXHRcdFx0Y2hhck1hcFtrZXldID0gY2hhcmFjdGVyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgY2hhck1hcFtrZXldO1xuXHRcdH1cblx0XHRpZiAoa2V5Lmxlbmd0aCA+IDEgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKGtleSkpIGluIG1vZGlmaWVycykge1xuXHRcdFx0bW9kaWZpZXJzW25hbWVdID0gZG93bjtcblx0XHRcdHZhciBhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuXHRcdFx0aWYgKG5hbWUgPT09ICdtZXRhJyAmJiBhZ2VudCAmJiBhZ2VudC5tYWMpIHtcblx0XHRcdFx0aWYgKGRvd24pIHtcblx0XHRcdFx0XHRtZXRhRml4TWFwID0ge307XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBtZXRhRml4TWFwKSB7XG5cdFx0XHRcdFx0XHRpZiAoayBpbiBjaGFyTWFwKVxuXHRcdFx0XHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGssIG1ldGFGaXhNYXBba10sIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bWV0YUZpeE1hcCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRvd24gJiYgbWV0YUZpeE1hcCkge1xuXHRcdFx0bWV0YUZpeE1hcFtrZXldID0gY2hhcmFjdGVyO1xuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmlldy5faGFuZGxlS2V5RXZlbnQoZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsIGV2ZW50LCBrZXksXG5cdFx0XHRcdFx0Y2hhcmFjdGVyKTtcblx0XHR9XG5cdH1cblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIHtcblx0XHRrZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGtleSA9IGdldEtleShldmVudCksXG5cdFx0XHRcdGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG5cdFx0XHRpZiAoa2V5Lmxlbmd0aCA+IDEgfHwgYWdlbnQgJiYgKGFnZW50LmNocm9tZSAmJiAoZXZlbnQuYWx0S2V5XG5cdFx0XHRcdFx0XHR8fCBhZ2VudC5tYWMgJiYgZXZlbnQubWV0YUtleVxuXHRcdFx0XHRcdFx0fHwgIWFnZW50Lm1hYyAmJiBldmVudC5jdHJsS2V5KSkpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGtleSxcblx0XHRcdFx0XHRcdGNoYXJMb29rdXBba2V5XSB8fCAoa2V5Lmxlbmd0aCA+IDEgPyAnJyA6IGtleSksIGV2ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvd25LZXkgPSBrZXk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRvd25LZXkpIHtcblx0XHRcdFx0dmFyIGtleSA9IGdldEtleShldmVudCksXG5cdFx0XHRcdFx0Y29kZSA9IGV2ZW50LmNoYXJDb2RlLFxuXHRcdFx0XHRcdGNoYXJhY3RlciA9IGNvZGUgPj0gMzIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG5cdFx0XHRcdFx0XHQ6IGtleS5sZW5ndGggPiAxID8gJycgOiBrZXk7XG5cdFx0XHRcdGlmIChrZXkgIT09IGRvd25LZXkpIHtcblx0XHRcdFx0XHRrZXkgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KTtcblx0XHRcdFx0ZG93bktleSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGtleSA9IGdldEtleShldmVudCk7XG5cdFx0XHRpZiAoa2V5IGluIGNoYXJNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwga2V5LCBjaGFyTWFwW2tleV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRibHVyOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGNoYXJNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwga2V5LCBjaGFyTWFwW2tleV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0bW9kaWZpZXJzOiBtb2RpZmllcnMsXG5cblx0XHRpc0Rvd246IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0cmV0dXJuICEha2V5TWFwW2tleV07XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIE1vdXNlRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdNb3VzZUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHRcdHRoaXMucG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50XG5cdFx0XHRcdCsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXRcblx0XHRcdFx0KyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2xFdmVudCcsXG5cdF9pdGVtOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0X2Nob29zZVBvaW50OiBmdW5jdGlvbihwb2ludCwgdG9vbFBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0fSxcblxuXHRnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcblx0fSxcblxuXHRzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuXHRcdHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcblx0fSxcblxuXHRnZXREb3duUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcblx0fSxcblxuXHRzZXREb3duUG9pbnQ6IGZ1bmN0aW9uKGRvd25Qb2ludCkge1xuXHRcdHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcblx0fSxcblxuXHRnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcblx0fSxcblxuXHRzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24obWlkZGxlUG9pbnQpIHtcblx0XHR0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuXHR9LFxuXG5cdGdldERlbHRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50XG5cdFx0XHRcdD8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcblx0XHRcdFx0OiB0aGlzLl9kZWx0YTtcblx0fSxcblxuXHRzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLl9kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdGdldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSlcblx0XHRcdFx0PyAnX2Rvd25Db3VudCcgOiAnX21vdmVDb3VudCddO1xuXHR9LFxuXG5cdHNldENvdW50OiBmdW5jdGlvbihjb3VudCkge1xuXHRcdHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpID8gJ2Rvd25Db3VudCcgOiAnY291bnQnXVxuXHRcdFx0PSBjb3VudDtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2l0ZW0pIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnRvb2wuX3Njb3BlLnByb2plY3QuaGl0VGVzdCh0aGlzLmdldFBvaW50KCkpO1xuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHJlc3VsdC5pdGVtLFxuXHRcdFx0XHRcdHBhcmVudCA9IGl0ZW0uX3BhcmVudDtcblx0XHRcdFx0d2hpbGUgKC9eKEdyb3VwfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHBhcmVudDtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW07XG5cdH0sXG5cblx0c2V0SXRlbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3sgdHlwZTogJyArIHRoaXMudHlwZVxuXHRcdFx0XHQrICcsIHBvaW50OiAnICsgdGhpcy5nZXRQb2ludCgpXG5cdFx0XHRcdCsgJywgY291bnQ6ICcgKyB0aGlzLmdldENvdW50KClcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbCcsXG5cdF9saXN0OiAndG9vbHMnLFxuXHRfcmVmZXJlbmNlOiAndG9vbCcsXG5cdF9ldmVudHM6IFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJyxcblx0XHRcdCdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJywgJ29uS2V5RG93bicsXG5cdFx0XHQnb25LZXlVcCddLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX21vdmVDb3VudCA9IC0xO1xuXHRcdHRoaXMuX2Rvd25Db3VudCA9IC0xO1xuXHRcdHRoaXMuc2V0KHByb3BzKTtcblx0fSxcblxuXHRnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtaW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2Vcblx0XHRcdD8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuXHR9LFxuXG5cdHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSB0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHR9LFxuXG5cdF9oYW5kbGVNb3VzZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCwgcG9pbnQsIG1vdXNlKSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHRpZiAobW91c2UuZHJhZyAmJiAhdGhpcy5yZXNwb25kcyh0eXBlKSlcblx0XHRcdHR5cGUgPSAnbW91c2Vtb3ZlJztcblx0XHR2YXIgbW92ZSA9IG1vdXNlLm1vdmUgfHwgbW91c2UuZHJhZyxcblx0XHRcdHJlc3BvbmRzID0gdGhpcy5yZXNwb25kcyh0eXBlKSxcblx0XHRcdG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdG1heERpc3RhbmNlID0gdGhpcy5tYXhEaXN0YW5jZSxcblx0XHRcdGNhbGxlZCA9IGZhbHNlLFxuXHRcdFx0dG9vbCA9IHRoaXM7XG5cdFx0ZnVuY3Rpb24gdXBkYXRlKG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSkge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQsXG5cdFx0XHRcdHRvb2xQb2ludCA9IG1vdmUgPyB0b29sLl9wb2ludCA6ICh0b29sLl9kb3duUG9pbnQgfHwgcHQpO1xuXHRcdFx0aWYgKG1vdmUpIHtcblx0XHRcdFx0aWYgKHRvb2wuX21vdmVDb3VudCAmJiBwdC5lcXVhbHModG9vbFBvaW50KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG9vbFBvaW50ICYmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpKSB7XG5cdFx0XHRcdFx0dmFyIHZlY3RvciA9IHB0LnN1YnRyYWN0KHRvb2xQb2ludCksXG5cdFx0XHRcdFx0XHRkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPCAobWluRGlzdGFuY2UgfHwgMCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKG1heERpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRwdCA9IHRvb2xQb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShcblx0XHRcdFx0XHRcdFx0XHRNYXRoLm1pbihkaXN0YW5jZSwgbWF4RGlzdGFuY2UpKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRvb2wuX21vdmVDb3VudCsrO1xuXHRcdFx0fVxuXHRcdFx0dG9vbC5fcG9pbnQgPSBwdDtcblx0XHRcdHRvb2wuX2xhc3RQb2ludCA9IHRvb2xQb2ludCB8fCBwdDtcblx0XHRcdGlmIChtb3VzZS5kb3duKSB7XG5cdFx0XHRcdHRvb2wuX21vdmVDb3VudCA9IC0xO1xuXHRcdFx0XHR0b29sLl9kb3duUG9pbnQgPSBwdDtcblx0XHRcdFx0dG9vbC5fZG93bkNvdW50Kys7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbWl0KCkge1xuXHRcdFx0aWYgKHJlc3BvbmRzKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRvb2wuZW1pdCh0eXBlLCBuZXcgVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSlcblx0XHRcdFx0XHRcdHx8IGNhbGxlZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobW91c2UuZG93bikge1xuXHRcdFx0dXBkYXRlKCk7XG5cdFx0XHRlbWl0KCk7XG5cdFx0fSBlbHNlIGlmIChtb3VzZS51cCkge1xuXHRcdFx0dXBkYXRlKG51bGwsIG1heERpc3RhbmNlKTtcblx0XHRcdGVtaXQoKTtcblx0XHR9IGVsc2UgaWYgKHJlc3BvbmRzKSB7XG5cdFx0XHR3aGlsZSAodXBkYXRlKG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSkpXG5cdFx0XHRcdGVtaXQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNhbGxlZDtcblx0fVxuXG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgeGhyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR4aHIub3Blbigob3B0aW9ucy5tZXRob2QgfHwgJ2dldCcpLnRvVXBwZXJDYXNlKCksIG9wdGlvbnMudXJsLFxuXHRcdFx0XHRCYXNlLnBpY2sob3B0aW9ucy5hc3luYywgdHJ1ZSkpO1xuXHRcdGlmIChvcHRpb25zLm1pbWVUeXBlKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZSk7XG5cdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLm9uTG9hZCkge1xuXHRcdFx0XHRcdG9wdGlvbnMub25Mb2FkLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eGhyLm9uZXJyb3IoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1cyxcblx0XHRcdFx0bWVzc2FnZSA9ICdDb3VsZCBub3QgbG9hZCBcIicgKyBvcHRpb25zLnVybCArICdcIiAoU3RhdHVzOiAnXG5cdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJztcblx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3IpIHtcblx0XHRcdFx0b3B0aW9ucy5vbkVycm9yKG1lc3NhZ2UsIHN0YXR1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4geGhyLnNlbmQobnVsbCk7XG5cdH1cbn07XG5cbnZhciBDYW52YXNQcm92aWRlciA9IHtcblx0Y2FudmFzZXM6IFtdLFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICghd2luZG93KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdGNsZWFyID0gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoIWN0eCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW52YXMgJyArIGNhbnZhcyArXG5cdFx0XHRcdFx0JyBpcyB1bmFibGUgdG8gcHJvdmlkZSBhIDJEIGNvbnRleHQuJyk7XG5cdFx0fVxuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqICYmIG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXHRcdGlmIChjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcblx0XHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIEJsZW5kTW9kZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNyLCBzZywgc2IsIHNhLFxuXHRcdGJyLCBiZywgYmIsIGJhLFxuXHRcdGRyLCBkZywgZGI7XG5cblx0ZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG5cdFx0dmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuXHRcdGRyID0gciArIGQ7XG5cdFx0ZGcgPSBnICsgZDtcblx0XHRkYiA9IGIgKyBkO1xuXHRcdHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuXHRcdFx0bW4gPSBtaW4oZHIsIGRnLCBkYiksXG5cdFx0XHRteCA9IG1heChkciwgZGcsIGRiKTtcblx0XHRpZiAobW4gPCAwKSB7XG5cdFx0XHR2YXIgbG1uID0gbCAtIG1uO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuXHRcdH1cblx0XHRpZiAobXggPiAyNTUpIHtcblx0XHRcdHZhciBsbiA9IDI1NSAtIGwsXG5cdFx0XHRcdG14bCA9IG14IC0gbDtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuXHRcdHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuXHRcdHZhciBjb2wgPSBbciwgZywgYl0sXG5cdFx0XHRteCA9IG1heChyLCBnLCBiKSxcblx0XHRcdG1uID0gbWluKHIsIGcsIGIpLFxuXHRcdFx0bWQ7XG5cdFx0bW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuXHRcdG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcblx0XHRtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cdFx0aWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG5cdFx0XHRjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuXHRcdFx0Y29sW214XSA9IHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbFttZF0gPSBjb2xbbXhdID0gMDtcblx0XHR9XG5cdFx0Y29sW21uXSA9IDA7XG5cdFx0ZHIgPSBjb2xbMF07XG5cdFx0ZGcgPSBjb2xbMV07XG5cdFx0ZGIgPSBjb2xbMl07XG5cdH1cblxuXHR2YXIgbW9kZXMgPSB7XG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAqIHNyIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyAqIHNnIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiAqIHNiIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyIC0gKGJyICogc3IgLyAyNTUpO1xuXHRcdFx0ZGcgPSBiZyArIHNnIC0gKGJnICogc2cgLyAyNTUpO1xuXHRcdFx0ZGIgPSBiYiArIHNiIC0gKGJiICogc2IgLyAyNTUpO1xuXHRcdH0sXG5cblx0XHRvdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J3NvZnQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0ID0gc3IgKiBiciAvIDI1NTtcblx0XHRcdGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2cgKiBiZyAvIDI1NTtcblx0XHRcdGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2IgKiBiYiAvIDI1NTtcblx0XHRcdGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdoYXJkLWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcblx0XHRcdGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG5cdFx0XHRkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuXHRcdH0sXG5cblx0XHQnY29sb3ItYnVybic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG5cdFx0XHRkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcblx0XHRcdGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuXHRcdH0sXG5cblx0XHRkYXJrZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRsaWdodGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0ZGlmZmVyZW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIC0gc3I7XG5cdFx0XHRpZiAoZHIgPCAwKVxuXHRcdFx0XHRkciA9IC1kcjtcblx0XHRcdGRnID0gYmcgLSBzZztcblx0XHRcdGlmIChkZyA8IDApXG5cdFx0XHRcdGRnID0gLWRnO1xuXHRcdFx0ZGIgPSBiYiAtIHNiO1xuXHRcdFx0aWYgKGRiIDwgMClcblx0XHRcdFx0ZGIgPSAtZGI7XG5cdFx0fSxcblxuXHRcdGV4Y2x1c2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdGh1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRzYXR1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGx1bWlub3NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG5cdFx0fSxcblxuXHRcdGNvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcblx0XHRcdGRnID0gbWluKGJnICsgc2csIDI1NSk7XG5cdFx0XHRkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1heChiciAtIHNyLCAwKTtcblx0XHRcdGRnID0gbWF4KGJnIC0gc2csIDApO1xuXHRcdFx0ZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG5cdFx0fSxcblxuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAoYnIgKyBzcikgLyAyO1xuXHRcdFx0ZGcgPSAoYmcgKyBzZykgLyAyO1xuXHRcdFx0ZGIgPSAoYmIgKyBzYikgLyAyO1xuXHRcdH0sXG5cblx0XHRuZWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcblx0XHRcdGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuXHRcdFx0ZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goW1xuXHRcdCdzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsXG5cdFx0J2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0Jyxcblx0XHQnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvcidcblx0XSwgZnVuY3Rpb24obW9kZSkge1xuXHRcdHRoaXNbbW9kZV0gPSB0cnVlO1xuXHR9LCB7fSk7XG5cblx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdGlmIChjdHgpIHtcblx0XHRCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcblx0XHRcdHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0XHRpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRcdG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW5cblx0XHRcdFx0XHRcdFx0PyAxNzAgOiA1MTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuXHRcdH0pO1xuXHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0fVxuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcblx0XHR2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG5cdFx0XHRub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblx0XHRpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG5cdFx0XHRkc3RDb250ZXh0LnNhdmUoKTtcblx0XHRcdGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKCFub3JtYWwpXG5cdFx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHRcdGRzdENvbnRleHQucmVzdG9yZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKCFwcm9jZXNzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuXHRcdFx0XHRkc3QgPSBkc3REYXRhLmRhdGEsXG5cdFx0XHRcdHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KS5kYXRhO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkc3QubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHRcdHNyID0gc3JjW2ldO1xuXHRcdFx0XHRiciA9IGRzdFtpXTtcblx0XHRcdFx0c2cgPSBzcmNbaSArIDFdO1xuXHRcdFx0XHRiZyA9IGRzdFtpICsgMV07XG5cdFx0XHRcdHNiID0gc3JjW2kgKyAyXTtcblx0XHRcdFx0YmIgPSBkc3RbaSArIDJdO1xuXHRcdFx0XHRzYSA9IHNyY1tpICsgM107XG5cdFx0XHRcdGJhID0gZHN0W2kgKyAzXTtcblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHR2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuXHRcdFx0XHRcdGEyID0gMSAtIGExO1xuXHRcdFx0XHRkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcblx0XHRcdFx0ZHN0W2kgKyAxXSA9IGExICogZGcgKyBhMiAqIGJnO1xuXHRcdFx0XHRkc3RbaSArIDJdID0gYTEgKiBkYiArIGEyICogYmI7XG5cdFx0XHRcdGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcblx0XHRcdH1cblx0XHRcdGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFN2Z0VsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBzdmcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnLFxuXHRcdHhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHtcblx0XHRcdGhyZWY6IHhsaW5rLFxuXHRcdFx0eGxpbms6IHhtbG5zLFxuXHRcdFx0eG1sbnM6IHhtbG5zICsgJy8nLFxuXHRcdFx0J3htbG5zOnhsaW5rJzogeG1sbnMgKyAnLydcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZSh0YWcsIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcikge1xuXHRcdHJldHVybiBzZXQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2ZywgdGFnKSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldChub2RlLCBuYW1lKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZVtuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbnVsbCcgPyBudWxsIDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobm9kZSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBmb3JtYXR0ZXIpXG5cdFx0XHRcdHZhbHVlID0gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSk7XG5cdFx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdmc6IHN2Zyxcblx0XHR4bWxuczogeG1sbnMsXG5cdFx0eGxpbms6IHhsaW5rLFxuXG5cdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0Z2V0OiBnZXQsXG5cdFx0c2V0OiBzZXRcblx0fTtcbn07XG5cbnZhciBTdmdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRmaWxsUnVsZTogWydmaWxsLXJ1bGUnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuXHRzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG5cdHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcblx0c3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG5cdHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG5cdFx0dHJ1ZTogJ25vbmUnLFxuXHRcdGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuXHR9LCBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0JiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG5cdH1dLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0eWxlJ11cbn0sIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRsb29rdXAgPSBlbnRyeVsyXTtcblx0dGhpc1trZXldID0ge1xuXHRcdHR5cGU6IGVudHJ5WzFdLFxuXHRcdHByb3BlcnR5OiBrZXksXG5cdFx0YXR0cmlidXRlOiBlbnRyeVswXSxcblx0XHR0b1NWRzogbG9va3VwLFxuXHRcdGZyb21TVkc6IGxvb2t1cCAmJiBCYXNlLmVhY2gobG9va3VwLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0dGhpc1t2YWx1ZV0gPSBuYW1lO1xuXHRcdH0sIHt9KSxcblx0XHRleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuXHRcdGdldDogJ2dldCcgKyBwYXJ0LFxuXHRcdHNldDogJ3NldCcgKyBwYXJ0XG5cdH07XG59LCB7fSk7XG5cbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGZvcm1hdHRlcjtcblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG5cdFx0dmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcblx0XHRcdHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguX3NoaWZ0bGVzcygpO1xuXHRcdFx0dmFyIHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRyYW5zKTtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeCcgOiAneCddID0gcG9pbnQueDtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeScgOiAneSddID0gcG9pbnQueTtcblx0XHRcdHRyYW5zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRcdGlmIChkZWNvbXBvc2VkKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0XHRcdGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcblx0XHRcdFx0XHRzY2FsZSA9IGRlY29tcG9zZWQuc2NhbGluZyxcblx0XHRcdFx0XHRza2V3ID0gZGVjb21wb3NlZC5za2V3aW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmIChhbmdsZSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdyb3RhdGUoJyArIGZvcm1hdHRlci5udW1iZXIoYW5nbGUpICsgJyknKTtcblx0XHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKVxuXHRcdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsnKScpO1xuXHRcdFx0XHRpZiAoc2tldy54KVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NrZXdYKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueCkgKyAnKScpO1xuXHRcdFx0XHRpZiAoc2tldy55KVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NrZXdZKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueSkgKyAnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2NsaXBQYXRoJyk7XG5cdFx0XHRcdFx0Y2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHRcdHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG5cdFx0XHRcdFx0U3ZnRWxlbWVudC5zZXQobm9kZSwge1xuXHRcdFx0XHRcdFx0J2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKSxcblx0XHRcdGltYWdlID0gaXRlbS5nZXRJbWFnZSgpO1xuXHRcdGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG5cdFx0YXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG5cdFx0YXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGF0dHJzLmhyZWYgPSBvcHRpb25zLmVtYmVkSW1hZ2VzID09IGZhbHNlICYmIGltYWdlICYmIGltYWdlLnNyY1xuXHRcdFx0XHR8fCBpdGVtLnRvRGF0YVVSTCgpO1xuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgnaW1hZ2UnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBtYXRjaFNoYXBlcyA9IG9wdGlvbnMubWF0Y2hTaGFwZXM7XG5cdFx0aWYgKG1hdGNoU2hhcGVzKSB7XG5cdFx0XHR2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuXHRcdFx0aWYgKHNoYXBlKVxuXHRcdFx0XHRyZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHR2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHR5cGUsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdGlmIChtYXRjaFNoYXBlcyAmJiBsZW5ndGggPj0gMiAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcblx0XHRcdGlmIChsZW5ndGggPiAyKSB7XG5cdFx0XHRcdHR5cGUgPSBpdGVtLl9jbG9zZWQgPyAncG9seWdvbicgOiAncG9seWxpbmUnO1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBzdGFydCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRlbmQgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0XHRcdGF0dHJzLnNldCh7XG5cdFx0XHRcdFx0eDE6IHN0YXJ0LngsXG5cdFx0XHRcdFx0eTE6IHN0YXJ0LnksXG5cdFx0XHRcdFx0eDI6IGVuZC54LFxuXHRcdFx0XHRcdHkyOiBlbmQueVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0Jztcblx0XHRcdHZhciBzaXplID0gaXRlbS5fc2l6ZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGF0dHJzLnggLT0gd2lkdGggLyAyO1xuXHRcdFx0YXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuXHRcdFx0YXR0cnMud2lkdGggPSB3aWR0aDtcblx0XHRcdGF0dHJzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdHJhZGl1cyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRhdHRycy5yID0gcmFkaXVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMucnggPSByYWRpdXMud2lkdGg7XG5cdFx0XHRcdGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCdwYXRoJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTeW1ib2xJdGVtKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuXHRcdFx0bm9kZSA9IGdldERlZmluaXRpb24oZGVmaW5pdGlvbiwgJ3N5bWJvbCcpLFxuXHRcdFx0ZGVmaW5pdGlvbkl0ZW0gPSBkZWZpbml0aW9uLl9pdGVtLFxuXHRcdFx0Ym91bmRzID0gZGVmaW5pdGlvbkl0ZW0uZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N5bWJvbCcsIHtcblx0XHRcdFx0dmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG5cdFx0XHR9KTtcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb25JdGVtLCBvcHRpb25zKSk7XG5cdFx0XHRzZXREZWZpbml0aW9uKGRlZmluaXRpb24sIG5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIG5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gYm91bmRzLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG5cdFx0YXR0cnMub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCd1c2UnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG5cdFx0XHRcdFx0YXR0cnMuZnkgPSBoaWdobGlnaHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IG9yaWdpbi54LFxuXHRcdFx0XHRcdHkxOiBvcmlnaW4ueSxcblx0XHRcdFx0XHR4MjogZGVzdGluYXRpb24ueCxcblx0XHRcdFx0XHR5MjogZGVzdGluYXRpb24ueVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0YXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG5cdFx0XHRncmFkaWVudE5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJylcblx0XHRcdFx0XHQrICdHcmFkaWVudCcsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHRcdFx0dmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcblx0XHRcdFx0XHRhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpLFxuXHRcdFx0XHRcdG9mZnNldCA9IHN0b3AuX29mZnNldDtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBvZmZzZXQgPT0gbnVsbCA/IGkgLyAobCAtIDEpIDogb2Zmc2V0XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChzdG9wQ29sb3IpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3BDb2xvci50b0NTUyh0cnVlKTtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0Z3JhZGllbnROb2RlLmFwcGVuZENoaWxkKFxuXHRcdFx0XHRcdFx0U3ZnRWxlbWVudC5jcmVhdGUoJ3N0b3AnLCBhdHRycywgZm9ybWF0dGVyKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuXHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdFx0Zm9ybWF0dGVyKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRTeW1ib2xJdGVtOiBleHBvcnRTeW1ib2xJdGVtLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIGF0dHJzID0ge30sXG5cdFx0XHRwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCksXG5cdFx0XHRzdHlsZSA9IFtdO1xuXG5cdFx0aWYgKGl0ZW0uX25hbWUgIT0gbnVsbClcblx0XHRcdGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcblxuXHRcdEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHR2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuXHRcdFx0XHR0eXBlID0gZW50cnkudHlwZSxcblx0XHRcdFx0dmFsdWUgPSBpdGVtW2dldF0oKTtcblx0XHRcdGlmIChlbnRyeS5leHBvcnRGaWx0ZXJcblx0XHRcdFx0XHQ/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSlcblx0XHRcdFx0XHQ6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHRcdHN0eWxlLnB1c2goZW50cnkuYXR0cmlidXRlICsgJzogJyArIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbCA/ICdub25lJ1xuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcicgPyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheScgPyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJyA/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoc3R5bGUubGVuZ3RoKVxuXHRcdFx0YXR0cnMuc3R5bGUgPSBzdHlsZS5qb2luKCc7Jyk7XG5cblx0XHRpZiAoYXR0cnMub3BhY2l0eSA9PT0gMSlcblx0XHRcdGRlbGV0ZSBhdHRycy5vcGFjaXR5O1xuXG5cdFx0aWYgKCFpdGVtLl92aXNpYmxlKVxuXHRcdFx0YXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuc2V0KG5vZGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zO1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7IGlkczoge30sIHN2Z3M6IHt9IH07XG5cdFx0cmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nXG5cdFx0XHRcdCsgKGl0ZW0uX2lkIHx8IGl0ZW0uX19pZCB8fCAoaXRlbS5fX2lkID0gVUlELmdldCgnc3ZnJykpKV07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciB0eXBlSWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcblx0XHRub2RlLmlkID0gdHlwZSArICctJyArIHR5cGVJZDtcblx0XHRkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyAoaXRlbS5faWQgfHwgaXRlbS5fX2lkKV0gPSBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBzdmcgPSBub2RlLFxuXHRcdFx0ZGVmcyA9IG51bGw7XG5cdFx0aWYgKGRlZmluaXRpb25zKSB7XG5cdFx0XHRzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcblx0XHRcdFx0aWYgKCFkZWZzKSB7XG5cdFx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRcdHN2ZyA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoU3ZnRWxlbWVudC5jcmVhdGUoJ2RlZnMnKSxcblx0XHRcdFx0XHRcdFx0c3ZnLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbml0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zLmFzU3RyaW5nXG5cdFx0XHRcdD8gbmV3IHNlbGYuWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcblx0XHRcdG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0dmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcblx0XHRcdGlmIChvbkV4cG9ydClcblx0XHRcdFx0bm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG5cdFx0XHR2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpXG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdFx0Ym91bmRzID0gQmFzZS5waWNrKG9wdGlvbnMuYm91bmRzLCAndmlldycpLFxuXHRcdFx0XHRteCA9IG9wdGlvbnMubWF0cml4IHx8IGJvdW5kcyA9PT0gJ3ZpZXcnICYmIHZpZXcuX21hdHJpeCxcblx0XHRcdFx0bWF0cml4ID0gbXggJiYgTWF0cml4LnJlYWQoW214XSksXG5cdFx0XHRcdHJlY3QgPSBib3VuZHMgPT09ICd2aWV3J1xuXHRcdFx0XHRcdD8gbmV3IFJlY3RhbmdsZShbMCwgMF0sIHZpZXcuZ2V0Vmlld1NpemUoKSlcblx0XHRcdFx0XHQ6IGJvdW5kcyA9PT0gJ2NvbnRlbnQnXG5cdFx0XHRcdFx0XHQ/IEl0ZW0uX2dldEJvdW5kcyhjaGlsZHJlbiwgbWF0cml4LCB7IHN0cm9rZTogdHJ1ZSB9KVxuXHRcdFx0XHRcdFx0XHQucmVjdFxuXHRcdFx0XHRcdFx0OiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSwgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6IFN2Z0VsZW1lbnQuc3ZnLFxuXHRcdFx0XHRcdCd4bWxuczp4bGluayc6IFN2Z0VsZW1lbnQueGxpbmssXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocmVjdCkge1xuXHRcdFx0XHRhdHRycy53aWR0aCA9IHJlY3Qud2lkdGg7XG5cdFx0XHRcdGF0dHJzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXHRcdFx0XHRpZiAocmVjdC54IHx8IHJlY3QueSlcblx0XHRcdFx0XHRhdHRycy52aWV3Qm94ID0gZm9ybWF0dGVyLnJlY3RhbmdsZShyZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N2ZycsIGF0dHJzLCBmb3JtYXR0ZXIpLFxuXHRcdFx0XHRwYXJlbnQgPSBub2RlO1xuXHRcdFx0aWYgKG1hdHJpeCAmJiAhbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0XHRwYXJlbnQgPSBub2RlLmFwcGVuZENoaWxkKFN2Z0VsZW1lbnQuY3JlYXRlKCdnJyxcblx0XHRcdFx0XHRcdGdldFRyYW5zZm9ybShtYXRyaXgpLCBmb3JtYXR0ZXIpKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChleHBvcnRTVkcoY2hpbGRyZW5baV0sIG9wdGlvbnMsIHRydWUpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBkZWZpbml0aW9ucyA9IHt9LFxuXHRcdHJvb3RTaXplO1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCkge1xuXHRcdHZhciB2YWx1ZSA9IFN2Z0VsZW1lbnQuZ2V0KG5vZGUsIG5hbWUpLFxuXHRcdFx0cmVzID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHQ/IGFsbG93TnVsbFxuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaXNTdHJpbmcgPyAnJyA6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdHJldHVybiAvJVxccyokLy50ZXN0KHZhbHVlKVxuXHRcdFx0PyAocmVzIC8gMTAwKSAqIChhbGxvd1BlcmNlbnQgPyAxXG5cdFx0XHRcdDogcm9vdFNpemVbL3h8XndpZHRoLy50ZXN0KG5hbWUpID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSlcblx0XHRcdDogcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpIHtcblx0XHR4ID0gZ2V0VmFsdWUobm9kZSwgeCB8fCAneCcsIGZhbHNlLCBhbGxvd051bGwsIGFsbG93UGVyY2VudCk7XG5cdFx0eSA9IGdldFZhbHVlKG5vZGUsIHkgfHwgJ3knLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNpemUobm9kZSwgdywgaCwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpIHtcblx0XHR3ID0gZ2V0VmFsdWUobm9kZSwgdyB8fCAnd2lkdGgnLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpO1xuXHRcdGggPSBnZXRWYWx1ZShub2RlLCBoIHx8ICdoZWlnaHQnLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHcgPT0gbnVsbCB8fCBoID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBTaXplKHcsIGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlLCB0eXBlLCBsb29rdXApIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdub25lJyA/IG51bGxcblx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodmFsdWUpXG5cdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5JyA/XG5cdFx0XHRcdFx0dmFsdWUgPyB2YWx1ZS5zcGxpdCgvW1xccyxdKy9nKS5tYXAocGFyc2VGbG9hdCkgOiBbXVxuXHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcicgPyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZVxuXHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnID8gbG9va3VwW3ZhbHVlXVxuXHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0aXNDbGlwID0gdHlwZSA9PT0gJ2NsaXBwYXRoJyxcblx0XHRcdGlzRGVmcyA9IHR5cGUgPT09ICdkZWZzJyxcblx0XHRcdGl0ZW0gPSBuZXcgR3JvdXAoKSxcblx0XHRcdHByb2plY3QgPSBpdGVtLl9wcm9qZWN0LFxuXHRcdFx0Y3VycmVudFN0eWxlID0gcHJvamVjdC5fY3VycmVudFN0eWxlLFxuXHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRpZiAoIWlzQ2xpcCAmJiAhaXNEZWZzKSB7XG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBpdGVtLl9zdHlsZS5jbG9uZSgpO1xuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHR2YXIgZGVmcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnZGVmcycpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkZWZzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbXBvcnROb2RlKGRlZnNbaV0sIG9wdGlvbnMsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBub2Rlc1tpXSxcblx0XHRcdFx0Y2hpbGQ7XG5cdFx0XHRpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxXG5cdFx0XHRcdFx0JiYgIS9eZGVmcyQvaS50ZXN0KGNoaWxkTm9kZS5ub2RlTmFtZSlcblx0XHRcdFx0XHQmJiAoY2hpbGQgPSBpbXBvcnROb2RlKGNoaWxkTm9kZSwgb3B0aW9ucywgZmFsc2UpKVxuXHRcdFx0XHRcdCYmICEoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2xEZWZpbml0aW9uKSlcblx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdFx0fVxuXHRcdGl0ZW0uYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdGlmIChpc0NsaXApXG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0ucmVkdWNlKCksIG5vZGUsIGlzUm9vdCk7XG5cdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlO1xuXHRcdGlmIChpc0NsaXAgfHwgaXNEZWZzKSB7XG5cdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0aXRlbSA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UG9seShub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5tYXRjaChcblx0XHRcdFx0XHQvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaV0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2kgKyAxXSkpKTtcblx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKHBvaW50cyk7XG5cdFx0aWYgKHR5cGUgPT09ICdwb2x5Z29uJylcblx0XHRcdHBhdGguY2xvc2VQYXRoKCk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQYXRoKG5vZGUpIHtcblx0XHRyZXR1cm4gUGF0aEl0ZW0uY3JlYXRlKG5vZGUuZ2V0QXR0cmlidXRlKCdkJykpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JhZGllbnQobm9kZSwgdHlwZSkge1xuXHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRyYWRpYWwgPSB0eXBlID09PSAncmFkaWFsZ3JhZGllbnQnLFxuXHRcdFx0Z3JhZGllbnQ7XG5cdFx0aWYgKGlkKSB7XG5cdFx0XHRncmFkaWVudCA9IGRlZmluaXRpb25zW2lkXS5nZXRHcmFkaWVudCgpO1xuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwgXiByYWRpYWwpIHtcblx0XHRcdFx0Z3JhZGllbnQgPSBncmFkaWVudC5jbG9uZSgpO1xuXHRcdFx0XHRncmFkaWVudC5fcmFkaWFsID0gcmFkaWFsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRcdHN0b3BzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKVxuXHRcdFx0XHRcdHN0b3BzLnB1c2goYXBwbHlBdHRyaWJ1dGVzKG5ldyBHcmFkaWVudFN0b3AoKSwgY2hpbGQpKTtcblx0XHRcdH1cblx0XHRcdGdyYWRpZW50ID0gbmV3IEdyYWRpZW50KHN0b3BzLCByYWRpYWwpO1xuXHRcdH1cblx0XHR2YXIgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0LFxuXHRcdFx0c2NhbGVUb0JvdW5kcyA9IGdldFZhbHVlKG5vZGUsICdncmFkaWVudFVuaXRzJywgdHJ1ZSkgIT09XG5cdFx0XHRcdCd1c2VyU3BhY2VPblVzZSc7XG5cdFx0aWYgKHJhZGlhbCkge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JywgZmFsc2UsIHNjYWxlVG9Cb3VuZHMpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKFxuXHRcdFx0XHRcdGdldFZhbHVlKG5vZGUsICdyJywgZmFsc2UsIGZhbHNlLCBzY2FsZVRvQm91bmRzKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlLCBzY2FsZVRvQm91bmRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJywgZmFsc2UsIHNjYWxlVG9Cb3VuZHMpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInLCBmYWxzZSwgc2NhbGVUb0JvdW5kcyk7XG5cdFx0fVxuXHRcdHZhciBjb2xvciA9IGFwcGx5QXR0cmlidXRlcyhcblx0XHRcdFx0bmV3IENvbG9yKGdyYWRpZW50LCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQpLCBub2RlKTtcblx0XHRjb2xvci5fc2NhbGVUb0JvdW5kcyA9IHNjYWxlVG9Cb3VuZHM7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaW1wb3J0ZXJzID0ge1xuXHRcdCcjZG9jdW1lbnQnOiBmdW5jdGlvbiAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBub2Rlc1tpXTtcblx0XHRcdFx0aWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKVxuXHRcdFx0XHRcdHJldHVybiBpbXBvcnROb2RlKGNoaWxkLCBvcHRpb25zLCBpc1Jvb3QpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZzogaW1wb3J0R3JvdXAsXG5cdFx0c3ZnOiBpbXBvcnRHcm91cCxcblx0XHRjbGlwcGF0aDogaW1wb3J0R3JvdXAsXG5cdFx0cG9seWdvbjogaW1wb3J0UG9seSxcblx0XHRwb2x5bGluZTogaW1wb3J0UG9seSxcblx0XHRwYXRoOiBpbXBvcnRQYXRoLFxuXHRcdGxpbmVhcmdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblx0XHRyYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cblx0XHRpbWFnZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkpO1xuXHRcdFx0cmFzdGVyLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzaXplID0gZ2V0U2l6ZShub2RlKTtcblx0XHRcdFx0dGhpcy5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0XHRcdGdldFBvaW50KG5vZGUpLmFkZChzaXplLmRpdmlkZSgyKSkpO1xuXHRcdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmFzdGVyO1xuXHRcdH0sXG5cblx0XHRzeW1ib2w6IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTeW1ib2xEZWZpbml0aW9uKFxuXHRcdFx0XHRcdGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuXHRcdH0sXG5cblx0XHRkZWZzOiBpbXBvcnRHcm91cCxcblxuXHRcdHVzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdFx0ZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2lkXSxcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChub2RlKTtcblx0XHRcdHJldHVybiBkZWZpbml0aW9uXG5cdFx0XHRcdFx0PyBkZWZpbml0aW9uIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvblxuXHRcdFx0XHRcdFx0PyBkZWZpbml0aW9uLnBsYWNlKHBvaW50KVxuXHRcdFx0XHRcdFx0OiBkZWZpbml0aW9uLmNsb25lKCkudHJhbnNsYXRlKHBvaW50KVxuXHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkNpcmNsZShcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicpKTtcblx0XHR9LFxuXG5cdFx0ZWxsaXBzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5FbGxpcHNlKHtcblx0XHRcdFx0Y2VudGVyOiBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0cmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0cmVjdDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShcblx0XHRcdFx0XHRcdGdldFBvaW50KG5vZGUpLFxuXHRcdFx0XHRcdFx0Z2V0U2l6ZShub2RlKVxuXHRcdFx0XHRcdCksIGdldFNpemUobm9kZSwgJ3J4JywgJ3J5JykpO1xuXHRcdFx0fSxcblxuXHRcdGxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgUGF0aC5MaW5lKFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4MScsICd5MScpLFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4MicsICd5MicpKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHRleHQgPSBuZXcgUG9pbnRUZXh0KGdldFBvaW50KG5vZGUpLmFkZChcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuXHRcdFx0dGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuXHRcdGlmIChpdGVtLnRyYW5zZm9ybSkge1xuXHRcdFx0dmFyIHRyYW5zZm9ybXMgPSAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgJycpLnNwbGl0KC9cXClcXHMqL2cpLFxuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW2ldO1xuXHRcdFx0XHRpZiAoIXRyYW5zZm9ybSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0dmFyIHBhcnRzID0gdHJhbnNmb3JtLnNwbGl0KC9cXChcXHMqLyksXG5cdFx0XHRcdFx0Y29tbWFuZCA9IHBhcnRzWzBdLFxuXHRcdFx0XHRcdHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSB2Lmxlbmd0aDsgaiA8IG07IGorKylcblx0XHRcdFx0XHR2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblx0XHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0bWF0cml4LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0bmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0bWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdLCB2WzJdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0bWF0cml4LnNjYWxlKHYpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdza2V3WCc6XG5cdFx0XHRcdFx0bWF0cml4LnNrZXcodlswXSwgMCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NrZXdZJzpcblx0XHRcdFx0XHRtYXRyaXguc2tldygwLCB2WzBdKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcblx0XHR2YXIga2V5ID0gbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJyA6ICdnZXRTdHJva2VDb2xvcicsXG5cdFx0XHRjb2xvciA9IGl0ZW1ba2V5XSAmJiBpdGVtW2tleV0oKTtcblx0XHRpZiAoY29sb3IpXG5cdFx0XHRjb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdH1cblxuXHR2YXIgYXR0cmlidXRlcyA9IEJhc2Uuc2V0KEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0dGhpc1tlbnRyeS5hdHRyaWJ1dGVdID0gZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtW2VudHJ5LnNldF0pIHtcblx0XHRcdFx0aXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXHRcdFx0XHRpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJykge1xuXHRcdFx0XHRcdHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXHRcdFx0XHRcdGlmIChjb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKGNvbG9yLl9zY2FsZVRvQm91bmRzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBib3VuZHMgPSBpdGVtLmdldEJvdW5kcygpO1xuXHRcdFx0XHRcdFx0XHRjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpXG5cdFx0XHRcdFx0XHRcdFx0LnRyYW5zbGF0ZShib3VuZHMuZ2V0UG9pbnQoKSlcblx0XHRcdFx0XHRcdFx0XHQuc2NhbGUoYm91bmRzLmdldFNpemUoKSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0sIHt9KSwge1xuXHRcdGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0ZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmIChpdGVtLnNldE5hbWUpXG5cdFx0XHRcdGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdjbGlwLXBhdGgnOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblx0XHRcdGlmIChjbGlwKSB7XG5cdFx0XHRcdGNsaXAgPSBjbGlwLmNsb25lKCk7XG5cdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0XHRpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXHRcdHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cblx0XHQnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXHRcdCdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuXHRcdHZpc2liaWxpdHk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRWaXNpYmxlKVxuXHRcdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG5cdFx0fSxcblxuXHRcdGRpc3BsYXk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRWaXNpYmxlKVxuXHRcdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1jb2xvcic6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRDb2xvcilcblx0XHRcdFx0aXRlbS5zZXRDb2xvcih2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uX2NvbG9yKVxuXHRcdFx0XHRpdGVtLl9jb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdG9mZnNldDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldE9mZnNldCkge1xuXHRcdFx0XHR2YXIgcGVyY2VudCA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcblx0XHRcdFx0aXRlbS5zZXRPZmZzZXQocGVyY2VudCA/IHBlcmNlbnRbMV0gLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcblx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSksXG5cdFx0XHRcdGdyb3VwLFxuXHRcdFx0XHRtYXRyaXg7XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IHNpemUgPyBzaXplLmRpdmlkZShyZWN0LmdldFNpemUoKSkgOiAxLFxuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpXG5cdFx0XHRcdFx0XHQudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKS5uZWdhdGUoKSk7XG5cdFx0XHRcdGdyb3VwID0gaXRlbTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb24pIHtcblx0XHRcdFx0aWYgKHNpemUpXG5cdFx0XHRcdFx0cmVjdC5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHRncm91cCA9IGl0ZW0uX2l0ZW07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZ3JvdXApICB7XG5cdFx0XHRcdGlmIChnZXRBdHRyaWJ1dGUobm9kZSwgJ292ZXJmbG93Jywgc3R5bGVzKSAhPT0gJ3Zpc2libGUnKSB7XG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpO1xuXHRcdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdFx0Z3JvdXAuYWRkQ2hpbGQoY2xpcCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1hdHJpeClcblx0XHRcdFx0XHRncm91cC50cmFuc2Zvcm0obWF0cml4KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpIHtcblx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuXHRcdGlmICghdmFsdWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IEJhc2UuY2FtZWxpemUobmFtZSk7XG5cdFx0XHR2YWx1ZSA9IG5vZGUuc3R5bGVbc3R5bGVdO1xuXHRcdFx0aWYgKCF2YWx1ZSAmJiBzdHlsZXMubm9kZVtzdHlsZV0gIT09IHN0eWxlcy5wYXJlbnRbc3R5bGVdKVxuXHRcdFx0XHR2YWx1ZSA9IHN0eWxlcy5ub2RlW3N0eWxlXTtcblx0XHR9XG5cdFx0cmV0dXJuICF2YWx1ZSA/IHVuZGVmaW5lZFxuXHRcdFx0XHQ6IHZhbHVlID09PSAnbm9uZScgPyBudWxsXG5cdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0aWYgKG5vZGUuc3R5bGUpIHtcblx0XHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXG5cdFx0XHRcdHN0eWxlcyA9IHtcblx0XHRcdFx0XHRub2RlOiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlKSB8fCB7fSxcblx0XHRcdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgIS9eZGVmcyQvaS50ZXN0KHBhcmVudC50YWdOYW1lKVxuXHRcdFx0XHRcdFx0XHQmJiBEb21FbGVtZW50LmdldFN0eWxlcyhwYXJlbnQpIHx8IHt9XG5cdFx0XHRcdH07XG5cdFx0XHRCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcyk7XG5cdFx0XHRcdGl0ZW0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHQmJiBhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB8fCBpdGVtO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzpbXCInI10qKShbXlwiJyldKykvKSxcblx0XHRcdG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXSxcblx0XHRcdHJlcyA9IG5hbWUgJiYgZGVmaW5pdGlvbnNbd2luZG93XG5cdFx0XHRcdFx0PyBuYW1lLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVswXSArICcjJywgJycpXG5cdFx0XHRcdFx0OiBuYW1lXTtcblx0XHRpZiAocmVzICYmIHJlcy5fc2NhbGVUb0JvdW5kcykge1xuXHRcdFx0cmVzID0gcmVzLmNsb25lKCk7XG5cdFx0XHRyZXMuX3NjYWxlVG9Cb3VuZHMgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0Tm9kZShub2RlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGlzRWxlbWVudCA9IHR5cGUgIT09ICcjZG9jdW1lbnQnLFxuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0XHRjb250YWluZXIsXG5cdFx0XHRwYXJlbnQsXG5cdFx0XHRuZXh0O1xuXHRcdGlmIChpc1Jvb3QgJiYgaXNFbGVtZW50KSB7XG5cdFx0XHRyb290U2l6ZSA9IHBhcGVyLmdldFZpZXcoKS5nZXRTaXplKCk7XG5cdFx0XHRyb290U2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSkgfHwgcm9vdFNpemU7XG5cdFx0XHRjb250YWluZXIgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywge1xuXHRcdFx0XHRzdHlsZTogJ3N0cm9rZS13aWR0aDogMXB4OyBzdHJva2UtbWl0ZXJsaW1pdDogMTAnXG5cdFx0XHR9KTtcblx0XHRcdHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdH1cblx0XHR2YXIgc2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncyxcblx0XHRcdGFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXgsXG5cdFx0XHRpbnNlcnRJdGVtcyA9IHNldHRpbmdzLmluc2VydEl0ZW1zO1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0c2V0dGluZ3MuaW5zZXJ0SXRlbXMgPSBmYWxzZTtcblx0XHR2YXIgaW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG5cdFx0XHRpdGVtID0gaW1wb3J0ZXIgJiYgaW1wb3J0ZXIobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB8fCBudWxsO1xuXHRcdHNldHRpbmdzLmluc2VydEl0ZW1zID0gaW5zZXJ0SXRlbXM7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKGlzRWxlbWVudCAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHZhciBvbkltcG9ydCA9IG9wdGlvbnMub25JbXBvcnQsXG5cdFx0XHRcdGRhdGEgPSBpc0VsZW1lbnQgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpO1xuXHRcdFx0aWYgKG9uSW1wb3J0KVxuXHRcdFx0XHRpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdGJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgb3B0aW9ucywgb3duZXIpIHtcblx0XHRpZiAoIXNvdXJjZSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IHsgb25Mb2FkOiBvcHRpb25zIH1cblx0XHRcdFx0OiBvcHRpb25zIHx8IHt9O1xuXHRcdHZhciBzY29wZSA9IHBhcGVyLFxuXHRcdFx0aXRlbSA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBvbkxvYWQoc3ZnKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBzdmcgPT09ICdvYmplY3QnID8gc3ZnIDogbmV3IHNlbGYuRE9NUGFyc2VyKClcblx0XHRcdFx0XHRcdC5wYXJzZUZyb21TdHJpbmcoc3ZnLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuXHRcdFx0XHRpZiAoIW5vZGUubm9kZU5hbWUpIHtcblx0XHRcdFx0XHRub2RlID0gbnVsbDtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHRcdGl0ZW0gPSBpbXBvcnROb2RlKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5pbnNlcnQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgb25Mb2FkID0gb3B0aW9ucy5vbkxvYWQ7XG5cdFx0XHRcdGlmIChvbkxvYWQpXG5cdFx0XHRcdFx0b25Mb2FkKGl0ZW0sIHN2Zyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25FcnJvcihtZXNzYWdlLCBzdGF0dXMpIHtcblx0XHRcdHZhciBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yO1xuXHRcdFx0aWYgKG9uRXJyb3IpIHtcblx0XHRcdFx0b25FcnJvcihtZXNzYWdlLCBzdGF0dXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL14uKjwvLnRlc3Qoc291cmNlKSkge1xuXHRcdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0b25Mb2FkKG5vZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0SHR0cC5yZXF1ZXN0KHtcblx0XHRcdFx0XHR1cmw6IHNvdXJjZSxcblx0XHRcdFx0XHRhc3luYzogdHJ1ZSxcblx0XHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0XHRvbkVycm9yOiBvbkVycm9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRvbkxvYWQocmVhZGVyLnJlc3VsdCk7XG5cdFx0XHR9O1xuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0b25FcnJvcihyZWFkZXIuZXJyb3IpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvbkxvYWQoc291cmNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdGhpcyk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5CYXNlLmV4cG9ydHMuUGFwZXJTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGdsb2JhbCA9IHRoaXMsXG5cdFx0YWNvcm4gPSBnbG9iYWwuYWNvcm47XG5cdGlmICghYWNvcm4gJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dHJ5IHsgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpOyB9IGNhdGNoKGUpIHt9XG5cdH1cblx0aWYgKCFhY29ybikge1xuXHRcdHZhciBleHBvcnRzLCBtb2R1bGU7XG5cdFx0YWNvcm4gPSBleHBvcnRzID0gbW9kdWxlID0ge307XG5cbihmdW5jdGlvbihyb290LCBtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSByZXR1cm4gbW9kKGV4cG9ydHMpO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgcmV0dXJuIGRlZmluZShbXCJleHBvcnRzXCJdLCBtb2QpO1xuICBtb2Qocm9vdC5hY29ybiB8fCAocm9vdC5hY29ybiA9IHt9KSk7XG59KSh0aGlzLCBmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9IFwiMC41LjBcIjtcblxuICB2YXIgb3B0aW9ucywgaW5wdXQsIGlucHV0TGVuLCBzb3VyY2VGaWxlO1xuXG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihpbnB0LCBvcHRzKSB7XG5cdGlucHV0ID0gU3RyaW5nKGlucHQpOyBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcblx0c2V0T3B0aW9ucyhvcHRzKTtcblx0aW5pdFRva2VuU3RhdGUoKTtcblx0cmV0dXJuIHBhcnNlVG9wTGV2ZWwob3B0aW9ucy5wcm9ncmFtKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuXHRlY21hVmVyc2lvbjogNSxcblx0c3RyaWN0U2VtaWNvbG9uczogZmFsc2UsXG5cdGFsbG93VHJhaWxpbmdDb21tYXM6IHRydWUsXG5cdGZvcmJpZFJlc2VydmVkOiBmYWxzZSxcblx0YWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuXHRsb2NhdGlvbnM6IGZhbHNlLFxuXHRvbkNvbW1lbnQ6IG51bGwsXG5cdHJhbmdlczogZmFsc2UsXG5cdHByb2dyYW06IG51bGwsXG5cdHNvdXJjZUZpbGU6IG51bGwsXG5cdGRpcmVjdFNvdXJjZUZpbGU6IG51bGxcbiAgfTtcblxuICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcblx0b3B0aW9ucyA9IG9wdHMgfHwge307XG5cdGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucykgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0KSlcblx0ICBvcHRpb25zW29wdF0gPSBkZWZhdWx0T3B0aW9uc1tvcHRdO1xuXHRzb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlIHx8IG51bGw7XG4gIH1cblxuICB2YXIgZ2V0TGluZUluZm8gPSBleHBvcnRzLmdldExpbmVJbmZvID0gZnVuY3Rpb24oaW5wdXQsIG9mZnNldCkge1xuXHRmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG5cdCAgbGluZUJyZWFrLmxhc3RJbmRleCA9IGN1cjtcblx0ICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCk7XG5cdCAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG5cdFx0KytsaW5lO1xuXHRcdGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHQgIH0gZWxzZSBicmVhaztcblx0fVxuXHRyZXR1cm4ge2xpbmU6IGxpbmUsIGNvbHVtbjogb2Zmc2V0IC0gY3VyfTtcbiAgfTtcblxuICBleHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24oaW5wdCwgb3B0cykge1xuXHRpbnB1dCA9IFN0cmluZyhpbnB0KTsgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG5cdHNldE9wdGlvbnMob3B0cyk7XG5cdGluaXRUb2tlblN0YXRlKCk7XG5cblx0dmFyIHQgPSB7fTtcblx0ZnVuY3Rpb24gZ2V0VG9rZW4oZm9yY2VSZWdleHApIHtcblx0ICBsYXN0RW5kID0gdG9rRW5kO1xuXHQgIHJlYWRUb2tlbihmb3JjZVJlZ2V4cCk7XG5cdCAgdC5zdGFydCA9IHRva1N0YXJ0OyB0LmVuZCA9IHRva0VuZDtcblx0ICB0LnN0YXJ0TG9jID0gdG9rU3RhcnRMb2M7IHQuZW5kTG9jID0gdG9rRW5kTG9jO1xuXHQgIHQudHlwZSA9IHRva1R5cGU7IHQudmFsdWUgPSB0b2tWYWw7XG5cdCAgcmV0dXJuIHQ7XG5cdH1cblx0Z2V0VG9rZW4uanVtcFRvID0gZnVuY3Rpb24ocG9zLCByZUFsbG93ZWQpIHtcblx0ICB0b2tQb3MgPSBwb3M7XG5cdCAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdFx0dG9rQ3VyTGluZSA9IDE7XG5cdFx0dG9rTGluZVN0YXJ0ID0gbGluZUJyZWFrLmxhc3RJbmRleCA9IDA7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgcG9zKSB7XG5cdFx0ICArK3Rva0N1ckxpbmU7XG5cdFx0ICB0b2tMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9XG5cdCAgfVxuXHQgIHRva1JlZ2V4cEFsbG93ZWQgPSByZUFsbG93ZWQ7XG5cdCAgc2tpcFNwYWNlKCk7XG5cdH07XG5cdHJldHVybiBnZXRUb2tlbjtcbiAgfTtcblxuICB2YXIgdG9rUG9zO1xuXG4gIHZhciB0b2tTdGFydCwgdG9rRW5kO1xuXG4gIHZhciB0b2tTdGFydExvYywgdG9rRW5kTG9jO1xuXG4gIHZhciB0b2tUeXBlLCB0b2tWYWw7XG5cbiAgdmFyIHRva1JlZ2V4cEFsbG93ZWQ7XG5cbiAgdmFyIHRva0N1ckxpbmUsIHRva0xpbmVTdGFydDtcblxuICB2YXIgbGFzdFN0YXJ0LCBsYXN0RW5kLCBsYXN0RW5kTG9jO1xuXG4gIHZhciBpbkZ1bmN0aW9uLCBsYWJlbHMsIHN0cmljdDtcblxuICBmdW5jdGlvbiByYWlzZShwb3MsIG1lc3NhZ2UpIHtcblx0dmFyIGxvYyA9IGdldExpbmVJbmZvKGlucHV0LCBwb3MpO1xuXHRtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG5cdHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG5cdGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRva1Bvcztcblx0dGhyb3cgZXJyO1xuICB9XG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgdmFyIF9udW0gPSB7dHlwZTogXCJudW1cIn0sIF9yZWdleHAgPSB7dHlwZTogXCJyZWdleHBcIn0sIF9zdHJpbmcgPSB7dHlwZTogXCJzdHJpbmdcIn07XG4gIHZhciBfbmFtZSA9IHt0eXBlOiBcIm5hbWVcIn0sIF9lb2YgPSB7dHlwZTogXCJlb2ZcIn07XG5cbiAgdmFyIF9icmVhayA9IHtrZXl3b3JkOiBcImJyZWFrXCJ9LCBfY2FzZSA9IHtrZXl3b3JkOiBcImNhc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9jYXRjaCA9IHtrZXl3b3JkOiBcImNhdGNoXCJ9O1xuICB2YXIgX2NvbnRpbnVlID0ge2tleXdvcmQ6IFwiY29udGludWVcIn0sIF9kZWJ1Z2dlciA9IHtrZXl3b3JkOiBcImRlYnVnZ2VyXCJ9LCBfZGVmYXVsdCA9IHtrZXl3b3JkOiBcImRlZmF1bHRcIn07XG4gIHZhciBfZG8gPSB7a2V5d29yZDogXCJkb1wiLCBpc0xvb3A6IHRydWV9LCBfZWxzZSA9IHtrZXl3b3JkOiBcImVsc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfZmluYWxseSA9IHtrZXl3b3JkOiBcImZpbmFsbHlcIn0sIF9mb3IgPSB7a2V5d29yZDogXCJmb3JcIiwgaXNMb29wOiB0cnVlfSwgX2Z1bmN0aW9uID0ge2tleXdvcmQ6IFwiZnVuY3Rpb25cIn07XG4gIHZhciBfaWYgPSB7a2V5d29yZDogXCJpZlwifSwgX3JldHVybiA9IHtrZXl3b3JkOiBcInJldHVyblwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3N3aXRjaCA9IHtrZXl3b3JkOiBcInN3aXRjaFwifTtcbiAgdmFyIF90aHJvdyA9IHtrZXl3b3JkOiBcInRocm93XCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfdHJ5ID0ge2tleXdvcmQ6IFwidHJ5XCJ9LCBfdmFyID0ge2tleXdvcmQ6IFwidmFyXCJ9O1xuICB2YXIgX3doaWxlID0ge2tleXdvcmQ6IFwid2hpbGVcIiwgaXNMb29wOiB0cnVlfSwgX3dpdGggPSB7a2V5d29yZDogXCJ3aXRoXCJ9LCBfbmV3ID0ge2tleXdvcmQ6IFwibmV3XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX3RoaXMgPSB7a2V5d29yZDogXCJ0aGlzXCJ9O1xuXG4gIHZhciBfbnVsbCA9IHtrZXl3b3JkOiBcIm51bGxcIiwgYXRvbVZhbHVlOiBudWxsfSwgX3RydWUgPSB7a2V5d29yZDogXCJ0cnVlXCIsIGF0b21WYWx1ZTogdHJ1ZX07XG4gIHZhciBfZmFsc2UgPSB7a2V5d29yZDogXCJmYWxzZVwiLCBhdG9tVmFsdWU6IGZhbHNlfTtcblxuICB2YXIgX2luID0ge2tleXdvcmQ6IFwiaW5cIiwgYmlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9O1xuXG4gIHZhciBrZXl3b3JkVHlwZXMgPSB7XCJicmVha1wiOiBfYnJlYWssIFwiY2FzZVwiOiBfY2FzZSwgXCJjYXRjaFwiOiBfY2F0Y2gsXG5cdFx0XHRcdFx0ICBcImNvbnRpbnVlXCI6IF9jb250aW51ZSwgXCJkZWJ1Z2dlclwiOiBfZGVidWdnZXIsIFwiZGVmYXVsdFwiOiBfZGVmYXVsdCxcblx0XHRcdFx0XHQgIFwiZG9cIjogX2RvLCBcImVsc2VcIjogX2Vsc2UsIFwiZmluYWxseVwiOiBfZmluYWxseSwgXCJmb3JcIjogX2Zvcixcblx0XHRcdFx0XHQgIFwiZnVuY3Rpb25cIjogX2Z1bmN0aW9uLCBcImlmXCI6IF9pZiwgXCJyZXR1cm5cIjogX3JldHVybiwgXCJzd2l0Y2hcIjogX3N3aXRjaCxcblx0XHRcdFx0XHQgIFwidGhyb3dcIjogX3Rocm93LCBcInRyeVwiOiBfdHJ5LCBcInZhclwiOiBfdmFyLCBcIndoaWxlXCI6IF93aGlsZSwgXCJ3aXRoXCI6IF93aXRoLFxuXHRcdFx0XHRcdCAgXCJudWxsXCI6IF9udWxsLCBcInRydWVcIjogX3RydWUsIFwiZmFsc2VcIjogX2ZhbHNlLCBcIm5ld1wiOiBfbmV3LCBcImluXCI6IF9pbixcblx0XHRcdFx0XHQgIFwiaW5zdGFuY2VvZlwiOiB7a2V5d29yZDogXCJpbnN0YW5jZW9mXCIsIGJpbm9wOiA3LCBiZWZvcmVFeHByOiB0cnVlfSwgXCJ0aGlzXCI6IF90aGlzLFxuXHRcdFx0XHRcdCAgXCJ0eXBlb2ZcIjoge2tleXdvcmQ6IFwidHlwZW9mXCIsIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0sXG5cdFx0XHRcdFx0ICBcInZvaWRcIjoge2tleXdvcmQ6IFwidm9pZFwiLCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9LFxuXHRcdFx0XHRcdCAgXCJkZWxldGVcIjoge2tleXdvcmQ6IFwiZGVsZXRlXCIsIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX19O1xuXG4gIHZhciBfYnJhY2tldEwgPSB7dHlwZTogXCJbXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfYnJhY2tldFIgPSB7dHlwZTogXCJdXCJ9LCBfYnJhY2VMID0ge3R5cGU6IFwie1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9icmFjZVIgPSB7dHlwZTogXCJ9XCJ9LCBfcGFyZW5MID0ge3R5cGU6IFwiKFwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3BhcmVuUiA9IHt0eXBlOiBcIilcIn07XG4gIHZhciBfY29tbWEgPSB7dHlwZTogXCIsXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfc2VtaSA9IHt0eXBlOiBcIjtcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfY29sb24gPSB7dHlwZTogXCI6XCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfZG90ID0ge3R5cGU6IFwiLlwifSwgX3F1ZXN0aW9uID0ge3R5cGU6IFwiP1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcblxuICB2YXIgX3NsYXNoID0ge2Jpbm9wOiAxMCwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9lcSA9IHtpc0Fzc2lnbjogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYXNzaWduID0ge2lzQXNzaWduOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9pbmNEZWMgPSB7cG9zdGZpeDogdHJ1ZSwgcHJlZml4OiB0cnVlLCBpc1VwZGF0ZTogdHJ1ZX0sIF9wcmVmaXggPSB7cHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9sb2dpY2FsT1IgPSB7Ymlub3A6IDEsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2xvZ2ljYWxBTkQgPSB7Ymlub3A6IDIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdHdpc2VPUiA9IHtiaW5vcDogMywgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZVhPUiA9IHtiaW5vcDogNCwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZUFORCA9IHtiaW5vcDogNSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfZXF1YWxpdHkgPSB7Ymlub3A6IDYsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX3JlbGF0aW9uYWwgPSB7Ymlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdFNoaWZ0ID0ge2Jpbm9wOiA4LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9wbHVzTWluID0ge2Jpbm9wOiA5LCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX211bHRpcGx5TW9kdWxvID0ge2Jpbm9wOiAxMCwgYmVmb3JlRXhwcjogdHJ1ZX07XG5cbiAgZXhwb3J0cy50b2tUeXBlcyA9IHticmFja2V0TDogX2JyYWNrZXRMLCBicmFja2V0UjogX2JyYWNrZXRSLCBicmFjZUw6IF9icmFjZUwsIGJyYWNlUjogX2JyYWNlUixcblx0XHRcdFx0XHQgIHBhcmVuTDogX3BhcmVuTCwgcGFyZW5SOiBfcGFyZW5SLCBjb21tYTogX2NvbW1hLCBzZW1pOiBfc2VtaSwgY29sb246IF9jb2xvbixcblx0XHRcdFx0XHQgIGRvdDogX2RvdCwgcXVlc3Rpb246IF9xdWVzdGlvbiwgc2xhc2g6IF9zbGFzaCwgZXE6IF9lcSwgbmFtZTogX25hbWUsIGVvZjogX2VvZixcblx0XHRcdFx0XHQgIG51bTogX251bSwgcmVnZXhwOiBfcmVnZXhwLCBzdHJpbmc6IF9zdHJpbmd9O1xuICBmb3IgKHZhciBrdyBpbiBrZXl3b3JkVHlwZXMpIGV4cG9ydHMudG9rVHlwZXNbXCJfXCIgKyBrd10gPSBrZXl3b3JkVHlwZXNba3ddO1xuXG4gIGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUod29yZHMpIHtcblx0d29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG5cdHZhciBmID0gXCJcIiwgY2F0cyA9IFtdO1xuXHRvdXQ6IGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcblx0ICBmb3IgKHZhciBqID0gMDsgaiA8IGNhdHMubGVuZ3RoOyArK2opXG5cdFx0aWYgKGNhdHNbal1bMF0ubGVuZ3RoID09IHdvcmRzW2ldLmxlbmd0aCkge1xuXHRcdCAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcblx0XHQgIGNvbnRpbnVlIG91dDtcblx0XHR9XG5cdCAgY2F0cy5wdXNoKFt3b3Jkc1tpXV0pO1xuXHR9XG5cdGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcblx0ICBpZiAoYXJyLmxlbmd0aCA9PSAxKSByZXR1cm4gZiArPSBcInJldHVybiBzdHIgPT09IFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyWzBdKSArIFwiO1wiO1xuXHQgIGYgKz0gXCJzd2l0Y2goc3RyKXtcIjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcImNhc2UgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbaV0pICsgXCI6XCI7XG5cdCAgZiArPSBcInJldHVybiB0cnVlfXJldHVybiBmYWxzZTtcIjtcblx0fVxuXG5cdGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcblx0ICBjYXRzLnNvcnQoZnVuY3Rpb24oYSwgYikge3JldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO30pO1xuXHQgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGNhdCA9IGNhdHNbaV07XG5cdFx0ZiArPSBcImNhc2UgXCIgKyBjYXRbMF0ubGVuZ3RoICsgXCI6XCI7XG5cdFx0Y29tcGFyZVRvKGNhdCk7XG5cdCAgfVxuXHQgIGYgKz0gXCJ9XCI7XG5cblx0fSBlbHNlIHtcblx0ICBjb21wYXJlVG8od29yZHMpO1xuXHR9XG5cdHJldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIiwgZik7XG4gIH1cblxuICB2YXIgaXNSZXNlcnZlZFdvcmQzID0gbWFrZVByZWRpY2F0ZShcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIik7XG5cbiAgdmFyIGlzUmVzZXJ2ZWRXb3JkNSA9IG1ha2VQcmVkaWNhdGUoXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiKTtcblxuICB2YXIgaXNTdHJpY3RSZXNlcnZlZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKTtcblxuICB2YXIgaXNTdHJpY3RCYWRJZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiZXZhbCBhcmd1bWVudHNcIik7XG5cbiAgdmFyIGlzS2V5d29yZCA9IG1ha2VQcmVkaWNhdGUoXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIik7XG5cbiAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICB2YXIgbmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG5cbiAgdmFyIGlzSWRlbnRpZmllclN0YXJ0ID0gZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcblx0aWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2O1xuXHRpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuXHRpZiAoY29kZSA8IDEyMylyZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9O1xuXG4gIHZhciBpc0lkZW50aWZpZXJDaGFyID0gZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuXHRpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG5cdGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuXHRpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG5cdGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuXHRpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG5cdGlmIChjb2RlIDwgMTIzKXJldHVybiB0cnVlO1xuXHRyZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGxpbmVfbG9jX3QoKSB7XG5cdHRoaXMubGluZSA9IHRva0N1ckxpbmU7XG5cdHRoaXMuY29sdW1uID0gdG9rUG9zIC0gdG9rTGluZVN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFRva2VuU3RhdGUoKSB7XG5cdHRva0N1ckxpbmUgPSAxO1xuXHR0b2tQb3MgPSB0b2tMaW5lU3RhcnQgPSAwO1xuXHR0b2tSZWdleHBBbGxvd2VkID0gdHJ1ZTtcblx0c2tpcFNwYWNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcblx0dG9rRW5kID0gdG9rUG9zO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva0VuZExvYyA9IG5ldyBsaW5lX2xvY190O1xuXHR0b2tUeXBlID0gdHlwZTtcblx0c2tpcFNwYWNlKCk7XG5cdHRva1ZhbCA9IHZhbDtcblx0dG9rUmVnZXhwQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBCbG9ja0NvbW1lbnQoKSB7XG5cdHZhciBzdGFydExvYyA9IG9wdGlvbnMub25Db21tZW50ICYmIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190O1xuXHR2YXIgc3RhcnQgPSB0b2tQb3MsIGVuZCA9IGlucHV0LmluZGV4T2YoXCIqL1wiLCB0b2tQb3MgKz0gMik7XG5cdGlmIChlbmQgPT09IC0xKSByYWlzZSh0b2tQb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpO1xuXHR0b2tQb3MgPSBlbmQgKyAyO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0ICBsaW5lQnJlYWsubGFzdEluZGV4ID0gc3RhcnQ7XG5cdCAgdmFyIG1hdGNoO1xuXHQgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdG9rUG9zKSB7XG5cdFx0Kyt0b2tDdXJMaW5lO1xuXHRcdHRva0xpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHQgIH1cblx0fVxuXHRpZiAob3B0aW9ucy5vbkNvbW1lbnQpXG5cdCAgb3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdG9rUG9zLFxuXHRcdFx0XHRcdFx0c3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBMaW5lQ29tbWVudCgpIHtcblx0dmFyIHN0YXJ0ID0gdG9rUG9zO1xuXHR2YXIgc3RhcnRMb2MgPSBvcHRpb25zLm9uQ29tbWVudCAmJiBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdDtcblx0dmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MrPTIpO1xuXHR3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4gJiYgY2ggIT09IDEwICYmIGNoICE9PSAxMyAmJiBjaCAhPT0gODIzMiAmJiBjaCAhPT0gODIzMykge1xuXHQgICsrdG9rUG9zO1xuXHQgIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHR9XG5cdGlmIChvcHRpb25zLm9uQ29tbWVudClcblx0ICBvcHRpb25zLm9uQ29tbWVudChmYWxzZSwgaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCB0b2tQb3MpLCBzdGFydCwgdG9rUG9zLFxuXHRcdFx0XHRcdFx0c3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBTcGFjZSgpIHtcblx0d2hpbGUgKHRva1BvcyA8IGlucHV0TGVuKSB7XG5cdCAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHQgIGlmIChjaCA9PT0gMzIpIHtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2UgaWYgKGNoID09PSAxMykge1xuXHRcdCsrdG9rUG9zO1xuXHRcdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHRcdGlmIChuZXh0ID09PSAxMCkge1xuXHRcdCAgKyt0b2tQb3M7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdCAgKyt0b2tDdXJMaW5lO1xuXHRcdCAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuXHRcdH1cblx0ICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuXHRcdCsrdG9rUG9zO1xuXHRcdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdCAgKyt0b2tDdXJMaW5lO1xuXHRcdCAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuXHRcdH1cblx0ICB9IGVsc2UgaWYgKGNoID4gOCAmJiBjaCA8IDE0KSB7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfSBlbHNlIGlmIChjaCA9PT0gNDcpIHtcblx0XHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdFx0aWYgKG5leHQgPT09IDQyKSB7XG5cdFx0ICBza2lwQmxvY2tDb21tZW50KCk7XG5cdFx0fSBlbHNlIGlmIChuZXh0ID09PSA0Nykge1xuXHRcdCAgc2tpcExpbmVDb21tZW50KCk7XG5cdFx0fSBlbHNlIGJyZWFrO1xuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDE2MCkge1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSBpZiAoY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2Uge1xuXHRcdGJyZWFrO1xuXHQgIH1cblx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2RvdCgpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSByZXR1cm4gcmVhZE51bWJlcih0cnVlKTtcblx0Kyt0b2tQb3M7XG5cdHJldHVybiBmaW5pc2hUb2tlbihfZG90KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9zbGFzaCgpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAodG9rUmVnZXhwQWxsb3dlZCkgeysrdG9rUG9zOyByZXR1cm4gcmVhZFJlZ2V4cCgpO31cblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfc2xhc2gsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX211bHRfbW9kdWxvKCkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoX211bHRpcGx5TW9kdWxvLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IGNvZGUpIHJldHVybiBmaW5pc2hPcChjb2RlID09PSAxMjQgPyBfbG9naWNhbE9SIDogX2xvZ2ljYWxBTkQsIDIpO1xuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9iaXR3aXNlT1IgOiBfYml0d2lzZUFORCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fY2FyZXQoKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfYml0d2lzZVhPUiwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fcGx1c19taW4oY29kZSkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSBjb2RlKSB7XG5cdCAgaWYgKG5leHQgPT0gNDUgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PSA2MiAmJlxuXHRcdCAgbmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1BvcykpKSB7XG5cdFx0dG9rUG9zICs9IDM7XG5cdFx0c2tpcExpbmVDb21tZW50KCk7XG5cdFx0c2tpcFNwYWNlKCk7XG5cdFx0cmV0dXJuIHJlYWRUb2tlbigpO1xuXHQgIH1cblx0ICByZXR1cm4gZmluaXNoT3AoX2luY0RlYywgMik7XG5cdH1cblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfcGx1c01pbiwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fbHRfZ3QoY29kZSkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdHZhciBzaXplID0gMTtcblx0aWYgKG5leHQgPT09IGNvZGUpIHtcblx0ICBzaXplID0gY29kZSA9PT0gNjIgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcblx0ICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyBzaXplKSA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCBzaXplICsgMSk7XG5cdCAgcmV0dXJuIGZpbmlzaE9wKF9iaXRTaGlmdCwgc2l6ZSk7XG5cdH1cblx0aWYgKG5leHQgPT0gMzMgJiYgY29kZSA9PSA2MCAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09IDQ1ICYmXG5cdFx0aW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAzKSA9PSA0NSkge1xuXHQgIHRva1BvcyArPSA0O1xuXHQgIHNraXBMaW5lQ29tbWVudCgpO1xuXHQgIHNraXBTcGFjZSgpO1xuXHQgIHJldHVybiByZWFkVG9rZW4oKTtcblx0fVxuXHRpZiAobmV4dCA9PT0gNjEpXG5cdCAgc2l6ZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDI7XG5cdHJldHVybiBmaW5pc2hPcChfcmVsYXRpb25hbCwgc2l6ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fZXFfZXhjbChjb2RlKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2VxdWFsaXR5LCBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDYxID8gX2VxIDogX3ByZWZpeCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcblx0c3dpdGNoKGNvZGUpIHtcblx0Y2FzZSA0Njpcblx0ICByZXR1cm4gcmVhZFRva2VuX2RvdCgpO1xuXG5cdGNhc2UgNDA6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuTCk7XG5cdGNhc2UgNDE6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuUik7XG5cdGNhc2UgNTk6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3NlbWkpO1xuXHRjYXNlIDQ0OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9jb21tYSk7XG5cdGNhc2UgOTE6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNrZXRMKTtcblx0Y2FzZSA5MzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldFIpO1xuXHRjYXNlIDEyMzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VMKTtcblx0Y2FzZSAxMjU6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNlUik7XG5cdGNhc2UgNTg6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2NvbG9uKTtcblx0Y2FzZSA2MzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfcXVlc3Rpb24pO1xuXG5cdGNhc2UgNDg6XG5cdCAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHQgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHJldHVybiByZWFkSGV4TnVtYmVyKCk7XG5cdGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6XG5cdCAgcmV0dXJuIHJlYWROdW1iZXIoZmFsc2UpO1xuXG5cdGNhc2UgMzQ6IGNhc2UgMzk6XG5cdCAgcmV0dXJuIHJlYWRTdHJpbmcoY29kZSk7XG5cblx0Y2FzZSA0Nzpcblx0ICByZXR1cm4gcmVhZFRva2VuX3NsYXNoKGNvZGUpO1xuXG5cdGNhc2UgMzc6IGNhc2UgNDI6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9tdWx0X21vZHVsbygpO1xuXG5cdGNhc2UgMTI0OiBjYXNlIDM4OlxuXHQgIHJldHVybiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG5cblx0Y2FzZSA5NDpcblx0ICByZXR1cm4gcmVhZFRva2VuX2NhcmV0KCk7XG5cblx0Y2FzZSA0MzogY2FzZSA0NTpcblx0ICByZXR1cm4gcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpO1xuXG5cdGNhc2UgNjA6IGNhc2UgNjI6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9sdF9ndChjb2RlKTtcblxuXHRjYXNlIDYxOiBjYXNlIDMzOlxuXHQgIHJldHVybiByZWFkVG9rZW5fZXFfZXhjbChjb2RlKTtcblxuXHRjYXNlIDEyNjpcblx0ICByZXR1cm4gZmluaXNoT3AoX3ByZWZpeCwgMSk7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4oZm9yY2VSZWdleHApIHtcblx0aWYgKCFmb3JjZVJlZ2V4cCkgdG9rU3RhcnQgPSB0b2tQb3M7XG5cdGVsc2UgdG9rUG9zID0gdG9rU3RhcnQgKyAxO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva1N0YXJ0TG9jID0gbmV3IGxpbmVfbG9jX3Q7XG5cdGlmIChmb3JjZVJlZ2V4cCkgcmV0dXJuIHJlYWRSZWdleHAoKTtcblx0aWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmV0dXJuIGZpbmlzaFRva2VuKF9lb2YpO1xuXG5cdHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHRpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkgfHwgY29kZSA9PT0gOTIgKSByZXR1cm4gcmVhZFdvcmQoKTtcblxuXHR2YXIgdG9rID0gZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcblxuXHRpZiAodG9rID09PSBmYWxzZSkge1xuXHQgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cdCAgaWYgKGNoID09PSBcIlxcXFxcIiB8fCBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KGNoKSkgcmV0dXJuIHJlYWRXb3JkKCk7XG5cdCAgcmFpc2UodG9rUG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuXHR9XG5cdHJldHVybiB0b2s7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG5cdHZhciBzdHIgPSBpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIHNpemUpO1xuXHR0b2tQb3MgKz0gc2l6ZTtcblx0ZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRSZWdleHAoKSB7XG5cdHZhciBjb250ZW50ID0gXCJcIiwgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0b2tQb3M7XG5cdGZvciAoOzspIHtcblx0ICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuXHQgIHZhciBjaCA9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuXHQgIGlmIChuZXdsaW5lLnRlc3QoY2gpKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuXHQgIGlmICghZXNjYXBlZCkge1xuXHRcdGlmIChjaCA9PT0gXCJbXCIpIGluQ2xhc3MgPSB0cnVlO1xuXHRcdGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSBpbkNsYXNzID0gZmFsc2U7XG5cdFx0ZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSBicmVhaztcblx0XHRlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuXHQgIH0gZWxzZSBlc2NhcGVkID0gZmFsc2U7XG5cdCAgKyt0b2tQb3M7XG5cdH1cblx0dmFyIGNvbnRlbnQgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcblx0Kyt0b2tQb3M7XG5cdHZhciBtb2RzID0gcmVhZFdvcmQxKCk7XG5cdGlmIChtb2RzICYmICEvXltnbXNpeV0qJC8udGVzdChtb2RzKSkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWdleHAgZmxhZ1wiKTtcblx0dHJ5IHtcblx0ICB2YXIgdmFsdWUgPSBuZXcgUmVnRXhwKGNvbnRlbnQsIG1vZHMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdCAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikgcmFpc2Uoc3RhcnQsIGUubWVzc2FnZSk7XG5cdCAgcmFpc2UoZSk7XG5cdH1cblx0cmV0dXJuIGZpbmlzaFRva2VuKF9yZWdleHAsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRJbnQocmFkaXgsIGxlbikge1xuXHR2YXIgc3RhcnQgPSB0b2tQb3MsIHRvdGFsID0gMDtcblx0Zm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG5cdCAgdmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyksIHZhbDtcblx0ICBpZiAoY29kZSA+PSA5NykgdmFsID0gY29kZSAtIDk3ICsgMTA7XG5cdCAgZWxzZSBpZiAoY29kZSA+PSA2NSkgdmFsID0gY29kZSAtIDY1ICsgMTA7XG5cdCAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB2YWwgPSBjb2RlIC0gNDg7XG5cdCAgZWxzZSB2YWwgPSBJbmZpbml0eTtcblx0ICBpZiAodmFsID49IHJhZGl4KSBicmVhaztcblx0ICArK3Rva1Bvcztcblx0ICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG5cdH1cblx0aWYgKHRva1BvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdG9rUG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG5cblx0cmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEhleE51bWJlcigpIHtcblx0dG9rUG9zICs9IDI7XG5cdHZhciB2YWwgPSByZWFkSW50KDE2KTtcblx0aWYgKHZhbCA9PSBudWxsKSByYWlzZSh0b2tTdGFydCArIDIsIFwiRXhwZWN0ZWQgaGV4YWRlY2ltYWwgbnVtYmVyXCIpO1xuXHRpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuXHRyZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuXHR2YXIgc3RhcnQgPSB0b2tQb3MsIGlzRmxvYXQgPSBmYWxzZSwgb2N0YWwgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ4O1xuXHRpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgcmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuXHRpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSA0Nikge1xuXHQgICsrdG9rUG9zO1xuXHQgIHJlYWRJbnQoMTApO1xuXHQgIGlzRmxvYXQgPSB0cnVlO1xuXHR9XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHRpZiAobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSB7XG5cdCAgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuXHQgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgKyt0b2tQb3M7XG5cdCAgaWYgKHJlYWRJbnQoMTApID09PSBudWxsKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcblx0ICBpc0Zsb2F0ID0gdHJ1ZTtcblx0fVxuXHRpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuXG5cdHZhciBzdHIgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKSwgdmFsO1xuXHRpZiAoaXNGbG9hdCkgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuXHRlbHNlIGlmICghb2N0YWwgfHwgc3RyLmxlbmd0aCA9PT0gMSkgdmFsID0gcGFyc2VJbnQoc3RyLCAxMCk7XG5cdGVsc2UgaWYgKC9bODldLy50ZXN0KHN0cikgfHwgc3RyaWN0KSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcblx0ZWxzZSB2YWwgPSBwYXJzZUludChzdHIsIDgpO1xuXHRyZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTdHJpbmcocXVvdGUpIHtcblx0dG9rUG9zKys7XG5cdHZhciBvdXQgPSBcIlwiO1xuXHRmb3IgKDs7KSB7XG5cdCAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcblx0ICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdCAgaWYgKGNoID09PSBxdW90ZSkge1xuXHRcdCsrdG9rUG9zO1xuXHRcdHJldHVybiBmaW5pc2hUb2tlbihfc3RyaW5nLCBvdXQpO1xuXHQgIH1cblx0ICBpZiAoY2ggPT09IDkyKSB7XG5cdFx0Y2ggPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcblx0XHR2YXIgb2N0YWwgPSAvXlswLTddKy8uZXhlYyhpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIDMpKTtcblx0XHRpZiAob2N0YWwpIG9jdGFsID0gb2N0YWxbMF07XG5cdFx0d2hpbGUgKG9jdGFsICYmIHBhcnNlSW50KG9jdGFsLCA4KSA+IDI1NSkgb2N0YWwgPSBvY3RhbC5zbGljZSgwLCAtMSk7XG5cdFx0aWYgKG9jdGFsID09PSBcIjBcIikgb2N0YWwgPSBudWxsO1xuXHRcdCsrdG9rUG9zO1xuXHRcdGlmIChvY3RhbCkge1xuXHRcdCAgaWYgKHN0cmljdCkgcmFpc2UodG9rUG9zIC0gMiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdCAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQob2N0YWwsIDgpKTtcblx0XHQgIHRva1BvcyArPSBvY3RhbC5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBzd2l0Y2ggKGNoKSB7XG5cdFx0ICBjYXNlIDExMDogb3V0ICs9IFwiXFxuXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTQ6IG91dCArPSBcIlxcclwiOyBicmVhaztcblx0XHQgIGNhc2UgMTIwOiBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcigyKSk7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTc6IG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDQpKTsgYnJlYWs7XG5cdFx0ICBjYXNlIDg1OiBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcig4KSk7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTY6IG91dCArPSBcIlxcdFwiOyBicmVhaztcblx0XHQgIGNhc2UgOTg6IG91dCArPSBcIlxcYlwiOyBicmVhaztcblx0XHQgIGNhc2UgMTE4OiBvdXQgKz0gXCJcXHUwMDBiXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMDI6IG91dCArPSBcIlxcZlwiOyBicmVhaztcblx0XHQgIGNhc2UgNDg6IG91dCArPSBcIlxcMFwiOyBicmVhaztcblx0XHQgIGNhc2UgMTM6IGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDEwKSArK3Rva1Bvcztcblx0XHQgIGNhc2UgMTA6XG5cdFx0XHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHsgdG9rTGluZVN0YXJ0ID0gdG9rUG9zOyArK3Rva0N1ckxpbmU7IH1cblx0XHRcdGJyZWFrO1xuXHRcdCAgZGVmYXVsdDogb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpOyBicmVhaztcblx0XHQgIH1cblx0XHR9XG5cdCAgfSBlbHNlIHtcblx0XHRpZiAoY2ggPT09IDEzIHx8IGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcblx0XHRvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfVxuXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSGV4Q2hhcihsZW4pIHtcblx0dmFyIG4gPSByZWFkSW50KDE2LCBsZW4pO1xuXHRpZiAobiA9PT0gbnVsbCkgcmFpc2UodG9rU3RhcnQsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7XG5cdHJldHVybiBuO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5zRXNjO1xuXG4gIGZ1bmN0aW9uIHJlYWRXb3JkMSgpIHtcblx0Y29udGFpbnNFc2MgPSBmYWxzZTtcblx0dmFyIHdvcmQsIGZpcnN0ID0gdHJ1ZSwgc3RhcnQgPSB0b2tQb3M7XG5cdGZvciAoOzspIHtcblx0ICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdCAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG5cdFx0aWYgKGNvbnRhaW5zRXNjKSB3b3JkICs9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG5cdFx0aWYgKCFjb250YWluc0VzYykgd29yZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuXHRcdGNvbnRhaW5zRXNjID0gdHJ1ZTtcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdCgrK3Rva1BvcykgIT0gMTE3KVxuXHRcdCAgcmFpc2UodG9rUG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG5cdFx0Kyt0b2tQb3M7XG5cdFx0dmFyIGVzYyA9IHJlYWRIZXhDaGFyKDQpO1xuXHRcdHZhciBlc2NTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzYyk7XG5cdFx0aWYgKCFlc2NTdHIpIHJhaXNlKHRva1BvcyAtIDEsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcblx0XHRpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0KGVzYykgOiBpc0lkZW50aWZpZXJDaGFyKGVzYykpKVxuXHRcdCAgcmFpc2UodG9rUG9zIC0gNCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuXHRcdHdvcmQgKz0gZXNjU3RyO1xuXHQgIH0gZWxzZSB7XG5cdFx0YnJlYWs7XG5cdCAgfVxuXHQgIGZpcnN0ID0gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zRXNjID8gd29yZCA6IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFdvcmQoKSB7XG5cdHZhciB3b3JkID0gcmVhZFdvcmQxKCk7XG5cdHZhciB0eXBlID0gX25hbWU7XG5cdGlmICghY29udGFpbnNFc2MgJiYgaXNLZXl3b3JkKHdvcmQpKVxuXHQgIHR5cGUgPSBrZXl3b3JkVHlwZXNbd29yZF07XG5cdHJldHVybiBmaW5pc2hUb2tlbih0eXBlLCB3b3JkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG5cdGxhc3RTdGFydCA9IHRva1N0YXJ0O1xuXHRsYXN0RW5kID0gdG9rRW5kO1xuXHRsYXN0RW5kTG9jID0gdG9rRW5kTG9jO1xuXHRyZWFkVG9rZW4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0cmljdChzdHJjdCkge1xuXHRzdHJpY3QgPSBzdHJjdDtcblx0dG9rUG9zID0gdG9rU3RhcnQ7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHQgIHdoaWxlICh0b2tQb3MgPCB0b2tMaW5lU3RhcnQpIHtcblx0XHR0b2tMaW5lU3RhcnQgPSBpbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCB0b2tMaW5lU3RhcnQgLSAyKSArIDE7XG5cdFx0LS10b2tDdXJMaW5lO1xuXHQgIH1cblx0fVxuXHRza2lwU3BhY2UoKTtcblx0cmVhZFRva2VuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBub2RlX3QoKSB7XG5cdHRoaXMudHlwZSA9IG51bGw7XG5cdHRoaXMuc3RhcnQgPSB0b2tTdGFydDtcblx0dGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9kZV9sb2NfdCgpIHtcblx0dGhpcy5zdGFydCA9IHRva1N0YXJ0TG9jO1xuXHR0aGlzLmVuZCA9IG51bGw7XG5cdGlmIChzb3VyY2VGaWxlICE9PSBudWxsKSB0aGlzLnNvdXJjZSA9IHNvdXJjZUZpbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydE5vZGUoKSB7XG5cdHZhciBub2RlID0gbmV3IG5vZGVfdCgpO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG5cdCAgbm9kZS5sb2MgPSBuZXcgbm9kZV9sb2NfdCgpO1xuXHRpZiAob3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuXHQgIG5vZGUuc291cmNlRmlsZSA9IG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTtcblx0aWYgKG9wdGlvbnMucmFuZ2VzKVxuXHQgIG5vZGUucmFuZ2UgPSBbdG9rU3RhcnQsIDBdO1xuXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0Tm9kZUZyb20ob3RoZXIpIHtcblx0dmFyIG5vZGUgPSBuZXcgbm9kZV90KCk7XG5cdG5vZGUuc3RhcnQgPSBvdGhlci5zdGFydDtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdCAgbm9kZS5sb2MgPSBuZXcgbm9kZV9sb2NfdCgpO1xuXHQgIG5vZGUubG9jLnN0YXJ0ID0gb3RoZXIubG9jLnN0YXJ0O1xuXHR9XG5cdGlmIChvcHRpb25zLnJhbmdlcylcblx0ICBub2RlLnJhbmdlID0gW290aGVyLnJhbmdlWzBdLCAwXTtcblxuXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuXHRub2RlLnR5cGUgPSB0eXBlO1xuXHRub2RlLmVuZCA9IGxhc3RFbmQ7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucylcblx0ICBub2RlLmxvYy5lbmQgPSBsYXN0RW5kTG9jO1xuXHRpZiAob3B0aW9ucy5yYW5nZXMpXG5cdCAgbm9kZS5yYW5nZVsxXSA9IGxhc3RFbmQ7XG5cdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVc2VTdHJpY3Qoc3RtdCkge1xuXHRyZXR1cm4gb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcblx0ICBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhdCh0eXBlKSB7XG5cdGlmICh0b2tUeXBlID09PSB0eXBlKSB7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiB0cnVlO1xuXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5JbnNlcnRTZW1pY29sb24oKSB7XG5cdHJldHVybiAhb3B0aW9ucy5zdHJpY3RTZW1pY29sb25zICYmXG5cdCAgKHRva1R5cGUgPT09IF9lb2YgfHwgdG9rVHlwZSA9PT0gX2JyYWNlUiB8fCBuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rU3RhcnQpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG5cdGlmICghZWF0KF9zZW1pKSAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh0eXBlKSB7XG5cdGlmICh0b2tUeXBlID09PSB0eXBlKSBuZXh0KCk7XG5cdGVsc2UgdW5leHBlY3RlZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5leHBlY3RlZCgpIHtcblx0cmFpc2UodG9rU3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTFZhbChleHByKSB7XG5cdGlmIChleHByLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGV4cHIudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpXG5cdCAgcmFpc2UoZXhwci5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuXHRpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXNTdHJpY3RCYWRJZFdvcmQoZXhwci5uYW1lKSlcblx0ICByYWlzZShleHByLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBcIiArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUb3BMZXZlbChwcm9ncmFtKSB7XG5cdGxhc3RTdGFydCA9IGxhc3RFbmQgPSB0b2tQb3M7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykgbGFzdEVuZExvYyA9IG5ldyBsaW5lX2xvY190O1xuXHRpbkZ1bmN0aW9uID0gc3RyaWN0ID0gbnVsbDtcblx0bGFiZWxzID0gW107XG5cdHJlYWRUb2tlbigpO1xuXG5cdHZhciBub2RlID0gcHJvZ3JhbSB8fCBzdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlO1xuXHRpZiAoIXByb2dyYW0pIG5vZGUuYm9keSA9IFtdO1xuXHR3aGlsZSAodG9rVHlwZSAhPT0gX2VvZikge1xuXHQgIHZhciBzdG10ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBub2RlLmJvZHkucHVzaChzdG10KTtcblx0ICBpZiAoZmlyc3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHNldFN0cmljdCh0cnVlKTtcblx0ICBmaXJzdCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbiAgfVxuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcblx0aWYgKHRva1R5cGUgPT09IF9zbGFzaCB8fCB0b2tUeXBlID09PSBfYXNzaWduICYmIHRva1ZhbCA9PSBcIi89XCIpXG5cdCAgcmVhZFRva2VuKHRydWUpO1xuXG5cdHZhciBzdGFydHR5cGUgPSB0b2tUeXBlLCBub2RlID0gc3RhcnROb2RlKCk7XG5cblx0c3dpdGNoIChzdGFydHR5cGUpIHtcblx0Y2FzZSBfYnJlYWs6IGNhc2UgX2NvbnRpbnVlOlxuXHQgIG5leHQoKTtcblx0ICB2YXIgaXNCcmVhayA9IHN0YXJ0dHlwZSA9PT0gX2JyZWFrO1xuXHQgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSBub2RlLmxhYmVsID0gbnVsbDtcblx0ICBlbHNlIGlmICh0b2tUeXBlICE9PSBfbmFtZSkgdW5leHBlY3RlZCgpO1xuXHQgIGVsc2Uge1xuXHRcdG5vZGUubGFiZWwgPSBwYXJzZUlkZW50KCk7XG5cdFx0c2VtaWNvbG9uKCk7XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgbGFiID0gbGFiZWxzW2ldO1xuXHRcdGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuXHRcdCAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgYnJlYWs7XG5cdFx0ICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcblx0XHR9XG5cdCAgfVxuXHQgIGlmIChpID09PSBsYWJlbHMubGVuZ3RoKSByYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsgc3RhcnR0eXBlLmtleXdvcmQpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2RlYnVnZ2VyOlxuXHQgIG5leHQoKTtcblx0ICBzZW1pY29sb24oKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2RvOlxuXHQgIG5leHQoKTtcblx0ICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXHQgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbGFiZWxzLnBvcCgpO1xuXHQgIGV4cGVjdChfd2hpbGUpO1xuXHQgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG5cdCAgc2VtaWNvbG9uKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2Zvcjpcblx0ICBuZXh0KCk7XG5cdCAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcblx0ICBleHBlY3QoX3BhcmVuTCk7XG5cdCAgaWYgKHRva1R5cGUgPT09IF9zZW1pKSByZXR1cm4gcGFyc2VGb3Iobm9kZSwgbnVsbCk7XG5cdCAgaWYgKHRva1R5cGUgPT09IF92YXIpIHtcblx0XHR2YXIgaW5pdCA9IHN0YXJ0Tm9kZSgpO1xuXHRcdG5leHQoKTtcblx0XHRwYXJzZVZhcihpbml0LCB0cnVlKTtcblx0XHRmaW5pc2hOb2RlKGluaXQsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcblx0XHRpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGVhdChfaW4pKVxuXHRcdCAgcmV0dXJuIHBhcnNlRm9ySW4obm9kZSwgaW5pdCk7XG5cdFx0cmV0dXJuIHBhcnNlRm9yKG5vZGUsIGluaXQpO1xuXHQgIH1cblx0ICB2YXIgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbihmYWxzZSwgdHJ1ZSk7XG5cdCAgaWYgKGVhdChfaW4pKSB7Y2hlY2tMVmFsKGluaXQpOyByZXR1cm4gcGFyc2VGb3JJbihub2RlLCBpbml0KTt9XG5cdCAgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIGluaXQpO1xuXG5cdGNhc2UgX2Z1bmN0aW9uOlxuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gcGFyc2VGdW5jdGlvbihub2RlLCB0cnVlKTtcblxuXHRjYXNlIF9pZjpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBub2RlLmNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIG5vZGUuYWx0ZXJuYXRlID0gZWF0KF9lbHNlKSA/IHBhcnNlU3RhdGVtZW50KCkgOiBudWxsO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfcmV0dXJuOlxuXHQgIGlmICghaW5GdW5jdGlvbiAmJiAhb3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcblx0XHRyYWlzZSh0b2tTdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuXHQgIG5leHQoKTtcblxuXHQgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSBub2RlLmFyZ3VtZW50ID0gbnVsbDtcblx0ICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpOyBzZW1pY29sb24oKTsgfVxuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3N3aXRjaDpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5kaXNjcmltaW5hbnQgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuXHQgIG5vZGUuY2FzZXMgPSBbXTtcblx0ICBleHBlY3QoX2JyYWNlTCk7XG5cdCAgbGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuXG5cdCAgZm9yICh2YXIgY3VyLCBzYXdEZWZhdWx0OyB0b2tUeXBlICE9IF9icmFjZVI7KSB7XG5cdFx0aWYgKHRva1R5cGUgPT09IF9jYXNlIHx8IHRva1R5cGUgPT09IF9kZWZhdWx0KSB7XG5cdFx0ICB2YXIgaXNDYXNlID0gdG9rVHlwZSA9PT0gX2Nhc2U7XG5cdFx0ICBpZiAoY3VyKSBmaW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuXHRcdCAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHN0YXJ0Tm9kZSgpKTtcblx0XHQgIGN1ci5jb25zZXF1ZW50ID0gW107XG5cdFx0ICBuZXh0KCk7XG5cdFx0ICBpZiAoaXNDYXNlKSBjdXIudGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHRcdCAgZWxzZSB7XG5cdFx0XHRpZiAoc2F3RGVmYXVsdCkgcmFpc2UobGFzdFN0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgc2F3RGVmYXVsdCA9IHRydWU7XG5cdFx0XHRjdXIudGVzdCA9IG51bGw7XG5cdFx0ICB9XG5cdFx0ICBleHBlY3QoX2NvbG9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcblx0XHQgIGN1ci5jb25zZXF1ZW50LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG5cdFx0fVxuXHQgIH1cblx0ICBpZiAoY3VyKSBmaW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuXHQgIG5leHQoKTtcblx0ICBsYWJlbHMucG9wKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfdGhyb3c6XG5cdCAgbmV4dCgpO1xuXHQgIGlmIChuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rU3RhcnQpKSlcblx0XHRyYWlzZShsYXN0RW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTtcblx0ICBub2RlLmFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgc2VtaWNvbG9uKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcblxuXHRjYXNlIF90cnk6XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUuYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cdCAgbm9kZS5oYW5kbGVyID0gbnVsbDtcblx0ICBpZiAodG9rVHlwZSA9PT0gX2NhdGNoKSB7XG5cdFx0dmFyIGNsYXVzZSA9IHN0YXJ0Tm9kZSgpO1xuXHRcdG5leHQoKTtcblx0XHRleHBlY3QoX3BhcmVuTCk7XG5cdFx0Y2xhdXNlLnBhcmFtID0gcGFyc2VJZGVudCgpO1xuXHRcdGlmIChzdHJpY3QgJiYgaXNTdHJpY3RCYWRJZFdvcmQoY2xhdXNlLnBhcmFtLm5hbWUpKVxuXHRcdCAgcmFpc2UoY2xhdXNlLnBhcmFtLnN0YXJ0LCBcIkJpbmRpbmcgXCIgKyBjbGF1c2UucGFyYW0ubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdGV4cGVjdChfcGFyZW5SKTtcblx0XHRjbGF1c2UuZ3VhcmQgPSBudWxsO1xuXHRcdGNsYXVzZS5ib2R5ID0gcGFyc2VCbG9jaygpO1xuXHRcdG5vZGUuaGFuZGxlciA9IGZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuXHQgIH1cblx0ICBub2RlLmd1YXJkZWRIYW5kbGVycyA9IGVtcHR5O1xuXHQgIG5vZGUuZmluYWxpemVyID0gZWF0KF9maW5hbGx5KSA/IHBhcnNlQmxvY2soKSA6IG51bGw7XG5cdCAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuXHRcdHJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF92YXI6XG5cdCAgbmV4dCgpO1xuXHQgIHBhcnNlVmFyKG5vZGUpO1xuXHQgIHNlbWljb2xvbigpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcblxuXHRjYXNlIF93aGlsZTpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXHQgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbGFiZWxzLnBvcCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfd2l0aDpcblx0ICBpZiAoc3RyaWN0KSByYWlzZSh0b2tTdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUub2JqZWN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9icmFjZUw6XG5cdCAgcmV0dXJuIHBhcnNlQmxvY2soKTtcblxuXHRjYXNlIF9zZW1pOlxuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpO1xuXG5cdGRlZmF1bHQ6XG5cdCAgdmFyIG1heWJlTmFtZSA9IHRva1ZhbCwgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgIGlmIChzdGFydHR5cGUgPT09IF9uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZWF0KF9jb2xvbikpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSlcblx0XHQgIGlmIChsYWJlbHNbaV0ubmFtZSA9PT0gbWF5YmVOYW1lKSByYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuXHRcdHZhciBraW5kID0gdG9rVHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRva1R5cGUgPT09IF9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcblx0XHRsYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kfSk7XG5cdFx0bm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0XHRsYWJlbHMucG9wKCk7XG5cdFx0bm9kZS5sYWJlbCA9IGV4cHI7XG5cdFx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuXHQgIH0gZWxzZSB7XG5cdFx0bm9kZS5leHByZXNzaW9uID0gZXhwcjtcblx0XHRzZW1pY29sb24oKTtcblx0XHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG5cdCAgfVxuXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBhcmVuRXhwcmVzc2lvbigpIHtcblx0ZXhwZWN0KF9wYXJlbkwpO1xuXHR2YXIgdmFsID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdGV4cGVjdChfcGFyZW5SKTtcblx0cmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQmxvY2soYWxsb3dTdHJpY3QpIHtcblx0dmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBzdHJpY3QgPSBmYWxzZSwgb2xkU3RyaWN0O1xuXHRub2RlLmJvZHkgPSBbXTtcblx0ZXhwZWN0KF9icmFjZUwpO1xuXHR3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuXHQgIHZhciBzdG10ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBub2RlLmJvZHkucHVzaChzdG10KTtcblx0ICBpZiAoZmlyc3QgJiYgYWxsb3dTdHJpY3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHtcblx0XHRvbGRTdHJpY3QgPSBzdHJpY3Q7XG5cdFx0c2V0U3RyaWN0KHN0cmljdCA9IHRydWUpO1xuXHQgIH1cblx0ICBmaXJzdCA9IGZhbHNlO1xuXHR9XG5cdGlmIChzdHJpY3QgJiYgIW9sZFN0cmljdCkgc2V0U3RyaWN0KGZhbHNlKTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yKG5vZGUsIGluaXQpIHtcblx0bm9kZS5pbml0ID0gaW5pdDtcblx0ZXhwZWN0KF9zZW1pKTtcblx0bm9kZS50ZXN0ID0gdG9rVHlwZSA9PT0gX3NlbWkgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG5cdGV4cGVjdChfc2VtaSk7XG5cdG5vZGUudXBkYXRlID0gdG9rVHlwZSA9PT0gX3BhcmVuUiA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcblx0ZXhwZWN0KF9wYXJlblIpO1xuXHRub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHRsYWJlbHMucG9wKCk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGb3JJbihub2RlLCBpbml0KSB7XG5cdG5vZGUubGVmdCA9IGluaXQ7XG5cdG5vZGUucmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ZXhwZWN0KF9wYXJlblIpO1xuXHRub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHRsYWJlbHMucG9wKCk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9ySW5TdGF0ZW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVZhcihub2RlLCBub0luKSB7XG5cdG5vZGUuZGVjbGFyYXRpb25zID0gW107XG5cdG5vZGUua2luZCA9IFwidmFyXCI7XG5cdGZvciAoOzspIHtcblx0ICB2YXIgZGVjbCA9IHN0YXJ0Tm9kZSgpO1xuXHQgIGRlY2wuaWQgPSBwYXJzZUlkZW50KCk7XG5cdCAgaWYgKHN0cmljdCAmJiBpc1N0cmljdEJhZElkV29yZChkZWNsLmlkLm5hbWUpKVxuXHRcdHJhaXNlKGRlY2wuaWQuc3RhcnQsIFwiQmluZGluZyBcIiArIGRlY2wuaWQubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuXHQgIGRlY2wuaW5pdCA9IGVhdChfZXEpID8gcGFyc2VFeHByZXNzaW9uKHRydWUsIG5vSW4pIDogbnVsbDtcblx0ICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKGZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuXHQgIGlmICghZWF0KF9jb21tYSkpIGJyZWFrO1xuXHR9XG5cdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKG5vQ29tbWEsIG5vSW4pIHtcblx0dmFyIGV4cHIgPSBwYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuXHRpZiAoIW5vQ29tbWEgJiYgdG9rVHlwZSA9PT0gX2NvbW1hKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuXHQgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cdCAgd2hpbGUgKGVhdChfY29tbWEpKSBub2RlLmV4cHJlc3Npb25zLnB1c2gocGFyc2VNYXliZUFzc2lnbihub0luKSk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlQXNzaWduKG5vSW4pIHtcblx0dmFyIGxlZnQgPSBwYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbik7XG5cdGlmICh0b2tUeXBlLmlzQXNzaWduKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuXHQgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdCAgbm9kZS5sZWZ0ID0gbGVmdDtcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5yaWdodCA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG5cdCAgY2hlY2tMVmFsKGxlZnQpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG5cdH1cblx0cmV0dXJuIGxlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbikge1xuXHR2YXIgZXhwciA9IHBhcnNlRXhwck9wcyhub0luKTtcblx0aWYgKGVhdChfcXVlc3Rpb24pKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuXHQgIG5vZGUudGVzdCA9IGV4cHI7XG5cdCAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VFeHByZXNzaW9uKHRydWUpO1xuXHQgIGV4cGVjdChfY29sb24pO1xuXHQgIG5vZGUuYWx0ZXJuYXRlID0gcGFyc2VFeHByZXNzaW9uKHRydWUsIG5vSW4pO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByT3BzKG5vSW4pIHtcblx0cmV0dXJuIHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCAtMSwgbm9Jbik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJPcChsZWZ0LCBtaW5QcmVjLCBub0luKSB7XG5cdHZhciBwcmVjID0gdG9rVHlwZS5iaW5vcDtcblx0aWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdG9rVHlwZSAhPT0gX2luKSkge1xuXHQgIGlmIChwcmVjID4gbWluUHJlYykge1xuXHRcdHZhciBub2RlID0gc3RhcnROb2RlRnJvbShsZWZ0KTtcblx0XHRub2RlLmxlZnQgPSBsZWZ0O1xuXHRcdG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdFx0dmFyIG9wID0gdG9rVHlwZTtcblx0XHRuZXh0KCk7XG5cdFx0bm9kZS5yaWdodCA9IHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCBwcmVjLCBub0luKTtcblx0XHR2YXIgZXhwck5vZGUgPSBmaW5pc2hOb2RlKG5vZGUsIChvcCA9PT0gX2xvZ2ljYWxPUiB8fCBvcCA9PT0gX2xvZ2ljYWxBTkQpID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpO1xuXHRcdHJldHVybiBwYXJzZUV4cHJPcChleHByTm9kZSwgbWluUHJlYywgbm9Jbik7XG5cdCAgfVxuXHR9XG5cdHJldHVybiBsZWZ0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNYXliZVVuYXJ5KCkge1xuXHRpZiAodG9rVHlwZS5wcmVmaXgpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0b2tUeXBlLmlzVXBkYXRlO1xuXHQgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdCAgbm9kZS5wcmVmaXggPSB0cnVlO1xuXHQgIHRva1JlZ2V4cEFsbG93ZWQgPSB0cnVlO1xuXHQgIG5leHQoKTtcblx0ICBub2RlLmFyZ3VtZW50ID0gcGFyc2VNYXliZVVuYXJ5KCk7XG5cdCAgaWYgKHVwZGF0ZSkgY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpO1xuXHQgIGVsc2UgaWYgKHN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG5cdFx0XHQgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuXHRcdHJhaXNlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcblx0fVxuXHR2YXIgZXhwciA9IHBhcnNlRXhwclN1YnNjcmlwdHMoKTtcblx0d2hpbGUgKHRva1R5cGUucG9zdGZpeCAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG5cdCAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcblx0ICBub2RlLnByZWZpeCA9IGZhbHNlO1xuXHQgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuXHQgIGNoZWNrTFZhbChleHByKTtcblx0ICBuZXh0KCk7XG5cdCAgZXhwciA9IGZpbmlzaE5vZGUobm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0cygpIHtcblx0cmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhwYXJzZUV4cHJBdG9tKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdWJzY3JpcHRzKGJhc2UsIG5vQ2FsbHMpIHtcblx0aWYgKGVhdChfZG90KSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcblx0ICBub2RlLm9iamVjdCA9IGJhc2U7XG5cdCAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlSWRlbnQodHJ1ZSk7XG5cdCAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuXHQgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuXHR9IGVsc2UgaWYgKGVhdChfYnJhY2tldEwpKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuXHQgIG5vZGUub2JqZWN0ID0gYmFzZTtcblx0ICBub2RlLnByb3BlcnR5ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgbm9kZS5jb21wdXRlZCA9IHRydWU7XG5cdCAgZXhwZWN0KF9icmFja2V0Uik7XG5cdCAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG5cdH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgZWF0KF9wYXJlbkwpKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuXHQgIG5vZGUuY2FsbGVlID0gYmFzZTtcblx0ICBub2RlLmFyZ3VtZW50cyA9IHBhcnNlRXhwckxpc3QoX3BhcmVuUiwgZmFsc2UpO1xuXHQgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcblx0fSBlbHNlIHJldHVybiBiYXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByQXRvbSgpIHtcblx0c3dpdGNoICh0b2tUeXBlKSB7XG5cdGNhc2UgX3RoaXM6XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKTtcblx0Y2FzZSBfbmFtZTpcblx0ICByZXR1cm4gcGFyc2VJZGVudCgpO1xuXHRjYXNlIF9udW06IGNhc2UgX3N0cmluZzogY2FzZSBfcmVnZXhwOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbm9kZS52YWx1ZSA9IHRva1ZhbDtcblx0ICBub2RlLnJhdyA9IGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpO1xuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cblx0Y2FzZSBfbnVsbDogY2FzZSBfdHJ1ZTogY2FzZSBfZmFsc2U6XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBub2RlLnZhbHVlID0gdG9rVHlwZS5hdG9tVmFsdWU7XG5cdCAgbm9kZS5yYXcgPSB0b2tUeXBlLmtleXdvcmQ7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuXHRjYXNlIF9wYXJlbkw6XG5cdCAgdmFyIHRva1N0YXJ0TG9jMSA9IHRva1N0YXJ0TG9jLCB0b2tTdGFydDEgPSB0b2tTdGFydDtcblx0ICBuZXh0KCk7XG5cdCAgdmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgIHZhbC5zdGFydCA9IHRva1N0YXJ0MTtcblx0ICB2YWwuZW5kID0gdG9rRW5kO1xuXHQgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdHZhbC5sb2Muc3RhcnQgPSB0b2tTdGFydExvYzE7XG5cdFx0dmFsLmxvYy5lbmQgPSB0b2tFbmRMb2M7XG5cdCAgfVxuXHQgIGlmIChvcHRpb25zLnJhbmdlcylcblx0XHR2YWwucmFuZ2UgPSBbdG9rU3RhcnQxLCB0b2tFbmRdO1xuXHQgIGV4cGVjdChfcGFyZW5SKTtcblx0ICByZXR1cm4gdmFsO1xuXG5cdGNhc2UgX2JyYWNrZXRMOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUuZWxlbWVudHMgPSBwYXJzZUV4cHJMaXN0KF9icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIik7XG5cblx0Y2FzZSBfYnJhY2VMOlxuXHQgIHJldHVybiBwYXJzZU9iaigpO1xuXG5cdGNhc2UgX2Z1bmN0aW9uOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKTtcblxuXHRjYXNlIF9uZXc6XG5cdCAgcmV0dXJuIHBhcnNlTmV3KCk7XG5cblx0ZGVmYXVsdDpcblx0ICB1bmV4cGVjdGVkKCk7XG5cdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTmV3KCkge1xuXHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHRuZXh0KCk7XG5cdG5vZGUuY2FsbGVlID0gcGFyc2VTdWJzY3JpcHRzKHBhcnNlRXhwckF0b20oKSwgdHJ1ZSk7XG5cdGlmIChlYXQoX3BhcmVuTCkpIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG5cdGVsc2Ugbm9kZS5hcmd1bWVudHMgPSBlbXB0eTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmooKSB7XG5cdHZhciBub2RlID0gc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgc2F3R2V0U2V0ID0gZmFsc2U7XG5cdG5vZGUucHJvcGVydGllcyA9IFtdO1xuXHRuZXh0KCk7XG5cdHdoaWxlICghZWF0KF9icmFjZVIpKSB7XG5cdCAgaWYgKCFmaXJzdCkge1xuXHRcdGV4cGVjdChfY29tbWEpO1xuXHRcdGlmIChvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KF9icmFjZVIpKSBicmVhaztcblx0ICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuXHQgIHZhciBwcm9wID0ge2tleTogcGFyc2VQcm9wZXJ0eU5hbWUoKX0sIGlzR2V0U2V0ID0gZmFsc2UsIGtpbmQ7XG5cdCAgaWYgKGVhdChfY29sb24pKSB7XG5cdFx0cHJvcC52YWx1ZSA9IHBhcnNlRXhwcmVzc2lvbih0cnVlKTtcblx0XHRraW5kID0gcHJvcC5raW5kID0gXCJpbml0XCI7XG5cdCAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcblx0XHRcdFx0IChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpKSB7XG5cdFx0aXNHZXRTZXQgPSBzYXdHZXRTZXQgPSB0cnVlO1xuXHRcdGtpbmQgPSBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuXHRcdHByb3Aua2V5ID0gcGFyc2VQcm9wZXJ0eU5hbWUoKTtcblx0XHRpZiAodG9rVHlwZSAhPT0gX3BhcmVuTCkgdW5leHBlY3RlZCgpO1xuXHRcdHByb3AudmFsdWUgPSBwYXJzZUZ1bmN0aW9uKHN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG5cdCAgfSBlbHNlIHVuZXhwZWN0ZWQoKTtcblxuXHQgIGlmIChwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAoc3RyaWN0IHx8IHNhd0dldFNldCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xuXHRcdCAgdmFyIG90aGVyID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuXHRcdCAgaWYgKG90aGVyLmtleS5uYW1lID09PSBwcm9wLmtleS5uYW1lKSB7XG5cdFx0XHR2YXIgY29uZmxpY3QgPSBraW5kID09IG90aGVyLmtpbmQgfHwgaXNHZXRTZXQgJiYgb3RoZXIua2luZCA9PT0gXCJpbml0XCIgfHxcblx0XHRcdCAga2luZCA9PT0gXCJpbml0XCIgJiYgKG90aGVyLmtpbmQgPT09IFwiZ2V0XCIgfHwgb3RoZXIua2luZCA9PT0gXCJzZXRcIik7XG5cdFx0XHRpZiAoY29uZmxpY3QgJiYgIXN0cmljdCAmJiBraW5kID09PSBcImluaXRcIiAmJiBvdGhlci5raW5kID09PSBcImluaXRcIikgY29uZmxpY3QgPSBmYWxzZTtcblx0XHRcdGlmIChjb25mbGljdCkgcmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpO1xuXHRcdCAgfVxuXHRcdH1cblx0ICB9XG5cdCAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG5cdH1cblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU5hbWUoKSB7XG5cdGlmICh0b2tUeXBlID09PSBfbnVtIHx8IHRva1R5cGUgPT09IF9zdHJpbmcpIHJldHVybiBwYXJzZUV4cHJBdG9tKCk7XG5cdHJldHVybiBwYXJzZUlkZW50KHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuXHRpZiAodG9rVHlwZSA9PT0gX25hbWUpIG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG5cdGVsc2UgaWYgKGlzU3RhdGVtZW50KSB1bmV4cGVjdGVkKCk7XG5cdGVsc2Ugbm9kZS5pZCA9IG51bGw7XG5cdG5vZGUucGFyYW1zID0gW107XG5cdHZhciBmaXJzdCA9IHRydWU7XG5cdGV4cGVjdChfcGFyZW5MKTtcblx0d2hpbGUgKCFlYXQoX3BhcmVuUikpIHtcblx0ICBpZiAoIWZpcnN0KSBleHBlY3QoX2NvbW1hKTsgZWxzZSBmaXJzdCA9IGZhbHNlO1xuXHQgIG5vZGUucGFyYW1zLnB1c2gocGFyc2VJZGVudCgpKTtcblx0fVxuXG5cdHZhciBvbGRJbkZ1bmMgPSBpbkZ1bmN0aW9uLCBvbGRMYWJlbHMgPSBsYWJlbHM7XG5cdGluRnVuY3Rpb24gPSB0cnVlOyBsYWJlbHMgPSBbXTtcblx0bm9kZS5ib2R5ID0gcGFyc2VCbG9jayh0cnVlKTtcblx0aW5GdW5jdGlvbiA9IG9sZEluRnVuYzsgbGFiZWxzID0gb2xkTGFiZWxzO1xuXG5cdGlmIChzdHJpY3QgfHwgbm9kZS5ib2R5LmJvZHkubGVuZ3RoICYmIGlzVXNlU3RyaWN0KG5vZGUuYm9keS5ib2R5WzBdKSkge1xuXHQgIGZvciAodmFyIGkgPSBub2RlLmlkID8gLTEgOiAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgaWQgPSBpIDwgMCA/IG5vZGUuaWQgOiBub2RlLnBhcmFtc1tpXTtcblx0XHRpZiAoaXNTdHJpY3RSZXNlcnZlZFdvcmQoaWQubmFtZSkgfHwgaXNTdHJpY3RCYWRJZFdvcmQoaWQubmFtZSkpXG5cdFx0ICByYWlzZShpZC5zdGFydCwgXCJEZWZpbmluZyAnXCIgKyBpZC5uYW1lICsgXCInIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdGlmIChpID49IDApIGZvciAodmFyIGogPSAwOyBqIDwgaTsgKytqKSBpZiAoaWQubmFtZSA9PT0gbm9kZS5wYXJhbXNbal0ubmFtZSlcblx0XHQgIHJhaXNlKGlkLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgfVxuXHR9XG5cblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByTGlzdChjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5KSB7XG5cdHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcblx0d2hpbGUgKCFlYXQoY2xvc2UpKSB7XG5cdCAgaWYgKCFmaXJzdCkge1xuXHRcdGV4cGVjdChfY29tbWEpO1xuXHRcdGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgb3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWFzICYmIGVhdChjbG9zZSkpIGJyZWFrO1xuXHQgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG5cdCAgaWYgKGFsbG93RW1wdHkgJiYgdG9rVHlwZSA9PT0gX2NvbW1hKSBlbHRzLnB1c2gobnVsbCk7XG5cdCAgZWxzZSBlbHRzLnB1c2gocGFyc2VFeHByZXNzaW9uKHRydWUpKTtcblx0fVxuXHRyZXR1cm4gZWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWRlbnQobGliZXJhbCkge1xuXHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHRpZiAobGliZXJhbCAmJiBvcHRpb25zLmZvcmJpZFJlc2VydmVkID09IFwiZXZlcnl3aGVyZVwiKSBsaWJlcmFsID0gZmFsc2U7XG5cdGlmICh0b2tUeXBlID09PSBfbmFtZSkge1xuXHQgIGlmICghbGliZXJhbCAmJlxuXHRcdCAgKG9wdGlvbnMuZm9yYmlkUmVzZXJ2ZWQgJiZcblx0XHQgICAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gMyA/IGlzUmVzZXJ2ZWRXb3JkMyA6IGlzUmVzZXJ2ZWRXb3JkNSkodG9rVmFsKSB8fFxuXHRcdCAgIHN0cmljdCAmJiBpc1N0cmljdFJlc2VydmVkV29yZCh0b2tWYWwpKSAmJlxuXHRcdCAgaW5wdXQuc2xpY2UodG9rU3RhcnQsIHRva0VuZCkuaW5kZXhPZihcIlxcXFxcIikgPT0gLTEpXG5cdFx0cmFpc2UodG9rU3RhcnQsIFwiVGhlIGtleXdvcmQgJ1wiICsgdG9rVmFsICsgXCInIGlzIHJlc2VydmVkXCIpO1xuXHQgIG5vZGUubmFtZSA9IHRva1ZhbDtcblx0fSBlbHNlIGlmIChsaWJlcmFsICYmIHRva1R5cGUua2V5d29yZCkge1xuXHQgIG5vZGUubmFtZSA9IHRva1R5cGUua2V5d29yZDtcblx0fSBlbHNlIHtcblx0ICB1bmV4cGVjdGVkKCk7XG5cdH1cblx0dG9rUmVnZXhwQWxsb3dlZCA9IGZhbHNlO1xuXHRuZXh0KCk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgfVxuXG59KTtcblxuXHRcdGlmICghYWNvcm4udmVyc2lvbilcblx0XHRcdGFjb3JuID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gKGdsb2JhbC5hY29ybiB8fCBhY29ybikucGFyc2UoY29kZSwgb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCcrJzogJ19fYWRkJyxcblx0XHQnLSc6ICdfX3N1YnRyYWN0Jyxcblx0XHQnKic6ICdfX211bHRpcGx5Jyxcblx0XHQnLyc6ICdfX2RpdmlkZScsXG5cdFx0JyUnOiAnX19tb2R1bG8nLFxuXHRcdCc9PSc6ICdfX2VxdWFscycsXG5cdFx0JyE9JzogJ19fZXF1YWxzJ1xuXHR9O1xuXG5cdHZhciB1bmFyeU9wZXJhdG9ycyA9IHtcblx0XHQnLSc6ICdfX25lZ2F0ZScsXG5cdFx0JysnOiAnX19zZWxmJ1xuXHR9O1xuXG5cdHZhciBmaWVsZHMgPSBCYXNlLmVhY2goXG5cdFx0WydhZGQnLCAnc3VidHJhY3QnLCAnbXVsdGlwbHknLCAnZGl2aWRlJywgJ21vZHVsbycsICdlcXVhbHMnLCAnbmVnYXRlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuXHRcdH0sXG5cdFx0e1xuXHRcdFx0X19zZWxmOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXHRQb2ludC5pbmplY3QoZmllbGRzKTtcblx0U2l6ZS5pbmplY3QoZmllbGRzKTtcblx0Q29sb3IuaW5qZWN0KGZpZWxkcyk7XG5cblx0ZnVuY3Rpb24gX18kX18obGVmdCwgb3BlcmF0b3IsIHJpZ2h0KSB7XG5cdFx0dmFyIGhhbmRsZXIgPSBiaW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmIChsZWZ0ICYmIGxlZnRbaGFuZGxlcl0pIHtcblx0XHRcdHZhciByZXMgPSBsZWZ0W2hhbmRsZXJdKHJpZ2h0KTtcblx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gJyE9JyA/ICFyZXMgOiByZXM7XG5cdFx0fVxuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuIGxlZnQgKyByaWdodDtcblx0XHRjYXNlICctJzogcmV0dXJuIGxlZnQgLSByaWdodDtcblx0XHRjYXNlICcqJzogcmV0dXJuIGxlZnQgKiByaWdodDtcblx0XHRjYXNlICcvJzogcmV0dXJuIGxlZnQgLyByaWdodDtcblx0XHRjYXNlICclJzogcmV0dXJuIGxlZnQgJSByaWdodDtcblx0XHRjYXNlICc9PSc6IHJldHVybiBsZWZ0ID09IHJpZ2h0O1xuXHRcdGNhc2UgJyE9JzogcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gJF9fKG9wZXJhdG9yLCB2YWx1ZSkge1xuXHRcdHZhciBoYW5kbGVyID0gdW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmICh2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSlcblx0XHRcdHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuICt2YWx1ZTtcblx0XHRjYXNlICctJzogcmV0dXJuIC12YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21waWxlKGNvZGUsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWNvZGUpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KG9mZnNldCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnNlcnRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaW5zZXJ0aW9uID0gaW5zZXJ0aW9uc1tpXTtcblx0XHRcdFx0aWYgKGluc2VydGlvblswXSA+PSBvZmZzZXQpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdG9mZnNldCArPSBpbnNlcnRpb25bMV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvZGUobm9kZSkge1xuXHRcdFx0cmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcblx0XHRcdFx0XHRnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEJldHdlZW4obGVmdCwgcmlnaHQpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobGVmdC5yYW5nZVsxXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KHJpZ2h0LnJhbmdlWzBdKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZUNvZGUobm9kZSwgc3RyKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdGVuZCA9IGdldE9mZnNldChub2RlLnJhbmdlWzFdKSxcblx0XHRcdFx0aW5zZXJ0ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSBpbnNlcnRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChzdGFydCA+IGluc2VydGlvbnNbaV1bMF0pIHtcblx0XHRcdFx0XHRpbnNlcnQgPSBpICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5zZXJ0aW9ucy5zcGxpY2UoaW5zZXJ0LCAwLCBbc3RhcnQsIHN0ci5sZW5ndGggLSBlbmQgKyBzdGFydF0pO1xuXHRcdFx0Y29kZSA9IGNvZGUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHN0ciArIGNvZGUuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2Fsa0FTVChub2RlLCBwYXJlbnQpIHtcblx0XHRcdGlmICghbm9kZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5vZGUpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3JhbmdlJyB8fCBrZXkgPT09ICdsb2MnKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlW2tleV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdFx0d2Fsa0FTVCh2YWx1ZVtpXSwgbm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHdhbGtBU1QodmFsdWUsIG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gdW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUuYXJndW1lbnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCk7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJyRfXyhcIicgKyBub2RlLm9wZXJhdG9yICsgJ1wiLCAnXG5cdFx0XHRcdFx0XHRcdCsgYXJnICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuXHRcdFx0XHRpZiAobm9kZS5vcGVyYXRvciBpbiBiaW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KSxcblx0XHRcdFx0XHRcdGJldHdlZW4gPSBnZXRCZXR3ZWVuKG5vZGUubGVmdCwgbm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9IG5vZGUub3BlcmF0b3I7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJ19fJF9fKCcgKyBsZWZ0ICsgJywnXG5cdFx0XHRcdFx0XHRcdCsgYmV0d2Vlbi5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwnICsgb3BlcmF0b3IpLFxuXHRcdFx0XHRcdFx0XHRcdCdcIicgKyBvcGVyYXRvciArICdcIicpXG5cdFx0XHRcdFx0XHRcdCsgJywgJyArIHJpZ2h0ICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuXHRcdFx0Y2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuXHRcdFx0XHR2YXIgcGFyZW50VHlwZSA9IHBhcmVudCAmJiBwYXJlbnQudHlwZTtcblx0XHRcdFx0aWYgKCEoXG5cdFx0XHRcdFx0XHRwYXJlbnRUeXBlID09PSAnRm9yU3RhdGVtZW50J1xuXHRcdFx0XHRcdFx0fHwgcGFyZW50VHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdCYmIC9eWz0hPD5dLy50ZXN0KHBhcmVudC5vcGVyYXRvcilcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBwYXJlbnQuY29tcHV0ZWRcblx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdGlmIChub2RlLnR5cGUgPT09ICdVcGRhdGVFeHByZXNzaW9uJykge1xuXHRcdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCksXG5cdFx0XHRcdFx0XHRcdGV4cCA9ICdfXyRfXygnICsgYXJnICsgJywgXCInICsgbm9kZS5vcGVyYXRvclswXVxuXHRcdFx0XHRcdFx0XHRcdFx0KyAnXCIsIDEpJyxcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJyA9ICcgKyBleHA7XG5cdFx0XHRcdFx0XHRpZiAoIW5vZGUucHJlZml4XG5cdFx0XHRcdFx0XHRcdFx0JiYgKHBhcmVudFR5cGUgPT09ICdBc3NpZ25tZW50RXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZ2V0Q29kZShwYXJlbnQubGVmdCB8fCBwYXJlbnQuaWQpID09PSBhcmcpXG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gZXhwO1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBhcmcgKyAnOyAnICsgc3RyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgc3RyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKC9eLj0kLy50ZXN0KG5vZGUub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHRcdFx0JiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRcdFx0ZXhwID0gbGVmdCArICcgPSBfXyRfXygnICsgbGVmdCArICcsIFwiJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KyBub2RlLm9wZXJhdG9yWzBdICsgJ1wiLCAnICsgcmlnaHQgKyAnKSc7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIC9eXFwoLipcXCkkLy50ZXN0KGdldENvZGUobm9kZSkpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICcoJyArIGV4cCArICcpJyA6IGV4cCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuY29kZVZMUSh2YWx1ZSkge1xuXHRcdFx0dmFyIHJlcyA9ICcnLFxuXHRcdFx0XHRiYXNlNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cdFx0XHR2YWx1ZSA9IChNYXRoLmFicyh2YWx1ZSkgPDwgMSkgKyAodmFsdWUgPCAwID8gMSA6IDApO1xuXHRcdFx0d2hpbGUgKHZhbHVlIHx8ICFyZXMpIHtcblx0XHRcdFx0dmFyIG5leHQgPSB2YWx1ZSAmICgzMiAtIDEpO1xuXHRcdFx0XHR2YWx1ZSA+Pj0gNTtcblx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdG5leHQgfD0gMzI7XG5cdFx0XHRcdHJlcyArPSBiYXNlNjRbbmV4dF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblxuXHRcdHZhciB1cmwgPSBvcHRpb25zLnVybCB8fCAnJyxcblx0XHRcdGFnZW50ID0gcGFwZXIuYWdlbnQsXG5cdFx0XHR2ZXJzaW9uID0gYWdlbnQudmVyc2lvbk51bWJlcixcblx0XHRcdG9mZnNldENvZGUgPSBmYWxzZSxcblx0XHRcdHNvdXJjZU1hcHMgPSBvcHRpb25zLnNvdXJjZU1hcHMsXG5cdFx0XHRzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSB8fCBjb2RlLFxuXHRcdFx0bGluZUJyZWFrcyA9IC9cXHJcXG58XFxufFxcci9tZyxcblx0XHRcdG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDAsXG5cdFx0XHRtYXA7XG5cdFx0aWYgKHNvdXJjZU1hcHMgJiYgKGFnZW50LmNocm9tZSAmJiB2ZXJzaW9uID49IDMwXG5cdFx0XHRcdHx8IGFnZW50LndlYmtpdCAmJiB2ZXJzaW9uID49IDUzNy43NlxuXHRcdFx0XHR8fCBhZ2VudC5maXJlZm94ICYmIHZlcnNpb24gPj0gMjNcblx0XHRcdFx0fHwgYWdlbnQubm9kZSkpIHtcblx0XHRcdGlmIChhZ2VudC5ub2RlKSB7XG5cdFx0XHRcdG9mZnNldCAtPSAyO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cgJiYgdXJsICYmICF3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKHVybCkpIHtcblx0XHRcdFx0dmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmlubmVySFRNTDtcblx0XHRcdFx0b2Zmc2V0ID0gaHRtbC5zdWJzdHIoMCwgaHRtbC5pbmRleE9mKGNvZGUpICsgMSkubWF0Y2goXG5cdFx0XHRcdFx0XHRsaW5lQnJlYWtzKS5sZW5ndGggKyAxO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0Q29kZSA9IG9mZnNldCA+IDAgJiYgIShcblx0XHRcdFx0XHRhZ2VudC5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzNiB8fFxuXHRcdFx0XHRcdGFnZW50LnNhZmFyaSAmJiB2ZXJzaW9uID49IDYwMCB8fFxuXHRcdFx0XHRcdGFnZW50LmZpcmVmb3ggJiYgdmVyc2lvbiA+PSA0MCB8fFxuXHRcdFx0XHRcdGFnZW50Lm5vZGUpO1xuXHRcdFx0dmFyIG1hcHBpbmdzID0gWydBQScgKyBlbmNvZGVWTFEob2Zmc2V0Q29kZSA/IDAgOiBvZmZzZXQpICsgJ0EnXTtcblx0XHRcdG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxXG5cdFx0XHRcdFx0KyAob2Zmc2V0Q29kZSA/IG9mZnNldCA6IDApO1xuXHRcdFx0bWFwID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0XHRmaWxlOiB1cmwsXG5cdFx0XHRcdG5hbWVzOltdLFxuXHRcdFx0XHRtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcblx0XHRcdFx0c291cmNlUm9vdDogJycsXG5cdFx0XHRcdHNvdXJjZXM6IFt1cmxdLFxuXHRcdFx0XHRzb3VyY2VzQ29udGVudDogW3NvdXJjZV1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHdhbGtBU1QocGFyc2UoY29kZSwgeyByYW5nZXM6IHRydWUsIHByZXNlcnZlUGFyZW5zOiB0cnVlIH0pKTtcblx0XHRpZiAobWFwKSB7XG5cdFx0XHRpZiAob2Zmc2V0Q29kZSkge1xuXHRcdFx0XHRjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZTtcblx0XHRcdH1cblx0XHRcdGlmICgvXihpbmxpbmV8Ym90aCkkLy50ZXN0KHNvdXJjZU1hcHMpKSB7XG5cdFx0XHRcdGNvZGUgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiXG5cdFx0XHRcdFx0XHQrIHNlbGYuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KG1hcCkpKSk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlICs9IFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArICh1cmwgfHwgJ3BhcGVyc2NyaXB0Jyk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHNvdXJjZTogc291cmNlLFxuXHRcdFx0Y29kZTogY29kZSxcblx0XHRcdG1hcDogbWFwXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4ZWN1dGUoY29kZSwgc2NvcGUsIG9wdGlvbnMpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXGJ0b29sXFwuXFx3K3xcXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiL1xuXHRcdFx0XHRcdC50ZXN0KGNvZGUpICYmICEvXFxibmV3XFxzK1Rvb2xcXGIvLnRlc3QoY29kZSlcblx0XHRcdFx0XHRcdD8gbmV3IFRvb2woKSA6IG51bGwsXG5cdFx0XHR0b29sSGFuZGxlcnMgPSB0b29sID8gdG9vbC5fZXZlbnRzIDogW10sXG5cdFx0XHRoYW5kbGVycyA9IFsnb25GcmFtZScsICdvblJlc2l6ZSddLmNvbmNhdCh0b29sSGFuZGxlcnMpLFxuXHRcdFx0cGFyYW1zID0gW10sXG5cdFx0XHRhcmdzID0gW10sXG5cdFx0XHRmdW5jLFxuXHRcdFx0Y29tcGlsZWQgPSB0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcgPyBjb2RlIDogY29tcGlsZShjb2RlLCBvcHRpb25zKTtcblx0XHRjb2RlID0gY29tcGlsZWQuY29kZTtcblx0XHRmdW5jdGlvbiBleHBvc2Uoc2NvcGUsIGhpZGRlbikge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNjb3BlKSB7XG5cdFx0XHRcdGlmICgoaGlkZGVuIHx8ICEvXl8vLnRlc3Qoa2V5KSkgJiYgbmV3IFJlZ0V4cCgnKFtcXFxcYlxcXFxzXFxcXFddfF4pJ1xuXHRcdFx0XHRcdFx0KyBrZXkucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0YXJncy5wdXNoKHNjb3BlW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4cG9zZSh7IF9fJF9fOiBfXyRfXywgJF9fOiAkX18sIHBhcGVyOiBzY29wZSwgdmlldzogdmlldywgdG9vbDogdG9vbCB9LFxuXHRcdFx0XHR0cnVlKTtcblx0XHRleHBvc2Uoc2NvcGUpO1xuXHRcdGhhbmRsZXJzID0gQmFzZS5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdGlmIChuZXcgUmVnRXhwKCdcXFxccysnICsga2V5ICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRwYXJhbXMucHVzaChrZXkpO1xuXHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArIGtleSk7XG5cdFx0XHR9XG5cdFx0fSwgW10pLmpvaW4oJywgJyk7XG5cdFx0aWYgKGhhbmRsZXJzKVxuXHRcdFx0Y29kZSArPSAnXFxucmV0dXJuIHsgJyArIGhhbmRsZXJzICsgJyB9Oyc7XG5cdFx0dmFyIGFnZW50ID0gcGFwZXIuYWdlbnQ7XG5cdFx0aWYgKGRvY3VtZW50ICYmIChhZ2VudC5jaHJvbWVcblx0XHRcdFx0fHwgYWdlbnQuZmlyZWZveCAmJiBhZ2VudC52ZXJzaW9uTnVtYmVyIDwgNDApKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG5cdFx0XHRcdGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdFx0XHRpZiAoYWdlbnQuZmlyZWZveClcblx0XHRcdFx0Y29kZSA9ICdcXG4nICsgY29kZTtcblx0XHRcdHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0J3BhcGVyLl9leGVjdXRlID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICsgY29kZSArICdcXG59J1xuXHRcdFx0KSk7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHRmdW5jID0gcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRkZWxldGUgcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZ1bmMgPSBGdW5jdGlvbihwYXJhbXMsIGNvZGUpO1xuXHRcdH1cblx0XHR2YXIgcmVzID0gZnVuYy5hcHBseShzY29wZSwgYXJncykgfHwge307XG5cdFx0QmFzZS5lYWNoKHRvb2xIYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSByZXNba2V5XTtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0dG9vbFtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdGlmIChyZXMub25SZXNpemUpXG5cdFx0XHRcdHZpZXcuc2V0T25SZXNpemUocmVzLm9uUmVzaXplKTtcblx0XHRcdHZpZXcuZW1pdCgncmVzaXplJywge1xuXHRcdFx0XHRzaXplOiB2aWV3LnNpemUsXG5cdFx0XHRcdGRlbHRhOiBuZXcgUG9pbnQoKVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocmVzLm9uRnJhbWUpXG5cdFx0XHRcdHZpZXcuc2V0T25GcmFtZShyZXMub25GcmFtZSk7XG5cdFx0XHR2aWV3LnJlcXVlc3RVcGRhdGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBpbGVkO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHQpIHtcblx0XHRpZiAoL150ZXh0XFwvKD86eC18KXBhcGVyc2NyaXB0JC8udGVzdChzY3JpcHQudHlwZSlcblx0XHRcdFx0JiYgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnaWdub3JlJykgIT09ICd0cnVlJykge1xuXHRcdFx0dmFyIGNhbnZhc0lkID0gUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnY2FudmFzJyksXG5cdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKSxcblx0XHRcdFx0c3JjID0gc2NyaXB0LnNyYyB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpLFxuXHRcdFx0XHRhc3luYyA9IFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKHNjcmlwdCwgJ2FzeW5jJyksXG5cdFx0XHRcdHNjb3BlQXR0cmlidXRlID0gJ2RhdGEtcGFwZXItc2NvcGUnO1xuXHRcdFx0aWYgKCFjYW52YXMpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgY2FudmFzIHdpdGggaWQgXCInXG5cdFx0XHRcdFx0XHQrIGNhbnZhc0lkICsgJ1wiJyk7XG5cdFx0XHR2YXIgc2NvcGUgPSBQYXBlclNjb3BlLmdldChjYW52YXMuZ2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlKSlcblx0XHRcdFx0XHRcdHx8IG5ldyBQYXBlclNjb3BlKCkuc2V0dXAoY2FudmFzKTtcblx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUsIHNjb3BlLl9pZCk7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdEh0dHAucmVxdWVzdCh7XG5cdFx0XHRcdFx0dXJsOiBzcmMsXG5cdFx0XHRcdFx0YXN5bmM6IGFzeW5jLFxuXHRcdFx0XHRcdG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG5cdFx0XHRcdFx0b25Mb2FkOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdFx0XHRleGVjdXRlKGNvZGUsIHNjb3BlLCBzcmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleGVjdXRlKHNjcmlwdC5pbm5lckhUTUwsIHNjb3BlLCBzY3JpcHQuYmFzZVVSSSk7XG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWlnbm9yZScsICd0cnVlJyk7XG5cdFx0XHRyZXR1cm4gc2NvcGU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZEFsbCgpIHtcblx0XHRCYXNlLmVhY2goZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLFxuXHRcdFx0XHRsb2FkU2NyaXB0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWQoc2NyaXB0KSB7XG5cdFx0cmV0dXJuIHNjcmlwdCA/IGxvYWRTY3JpcHQoc2NyaXB0KSA6IGxvYWRBbGwoKTtcblx0fVxuXG5cdGlmICh3aW5kb3cpIHtcblx0XHRpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdFx0c2V0VGltZW91dChsb2FkQWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgeyBsb2FkOiBsb2FkQWxsIH0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogY29tcGlsZSxcblx0XHRleGVjdXRlOiBleGVjdXRlLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlXG5cdH07XG5cbn0uY2FsbCh0aGlzKTtcblxucGFwZXIgPSBuZXcgKFBhcGVyU2NvcGUuaW5qZWN0KEJhc2UuZXhwb3J0cywge1xuXHRCYXNlOiBCYXNlLFxuXHROdW1lcmljYWw6IE51bWVyaWNhbCxcblx0S2V5OiBLZXksXG5cdERvbUV2ZW50OiBEb21FdmVudCxcblx0RG9tRWxlbWVudDogRG9tRWxlbWVudCxcblx0ZG9jdW1lbnQ6IGRvY3VtZW50LFxuXHR3aW5kb3c6IHdpbmRvdyxcblx0U3ltYm9sOiBTeW1ib2xEZWZpbml0aW9uLFxuXHRQbGFjZWRTeW1ib2w6IFN5bWJvbEl0ZW1cbn0pKSgpO1xuXG5pZiAocGFwZXIuYWdlbnQubm9kZSkge1xuXHRyZXF1aXJlKCcuL25vZGUvZXh0ZW5kLmpzJykocGFwZXIpO1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdGRlZmluZSgncGFwZXInLCBwYXBlcik7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHBhcGVyO1xufVxuXG5yZXR1cm4gcGFwZXI7XG59LmNhbGwodGhpcywgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnID8gc2VsZiA6IG51bGwpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/paper/dist/paper-full.js\n");

/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\
  !*** ./node_modules/parseqs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Compiles a querystring\r\n * Returns string representation of the object\r\n *\r\n * @param {Object}\r\n * @api private\r\n */\r\n\r\nexports.encode = function (obj) {\r\n  var str = '';\r\n\r\n  for (var i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      if (str.length) str += '&';\r\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n    }\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n/**\r\n * Parses a simple querystring into an object\r\n *\r\n * @param {String} qs\r\n * @api private\r\n */\r\n\r\nexports.decode = function(qs){\r\n  var qry = {};\r\n  var pairs = qs.split('&');\r\n  for (var i = 0, l = pairs.length; i < l; i++) {\r\n    var pair = pairs[i].split('=');\r\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n  }\r\n  return qry;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcz80ZjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3BhcnNlcXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/parseqs/index.js\n");

/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Parses an URI\r\n *\r\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n * @api private\r\n */\r\n\r\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\nvar parts = [\r\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n];\r\n\r\nmodule.exports = function parseuri(str) {\r\n    var src = str,\r\n        b = str.indexOf('['),\r\n        e = str.indexOf(']');\r\n\r\n    if (b != -1 && e != -1) {\r\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n    }\r\n\r\n    var m = re.exec(str || ''),\r\n        uri = {},\r\n        i = 14;\r\n\r\n    while (i--) {\r\n        uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    if (b != -1 && e != -1) {\r\n        uri.source = src;\r\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n        uri.ipv6uri = true;\r\n    }\r\n\r\n    return uri;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanM/NTMxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHLElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSTs7QUFFakk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLGtGQUFrRjtBQUNsRjtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/parseuri/index.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar url = __webpack_require__(/*! ./url */ \"./node_modules/socket.io-client/lib/url.js\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/index.js\");\nvar Manager = __webpack_require__(/*! ./manager */ \"./node_modules/socket.io-client/lib/manager.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n  return io.socket(parsed.path, opts);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = __webpack_require__(/*! ./manager */ \"./node_modules/socket.io-client/lib/manager.js\");\nexports.Socket = __webpack_require__(/*! ./socket */ \"./node_modules/socket.io-client/lib/socket.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanM/ODA1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/socket.io-client/lib/index.js\n");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/manager.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-client/lib/manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar eio = __webpack_require__(/*! engine.io-client */ \"./node_modules/engine.io-client/lib/index.js\");\nvar Socket = __webpack_require__(/*! ./socket */ \"./node_modules/socket.io-client/lib/socket.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/index.js\");\nvar on = __webpack_require__(/*! ./on */ \"./node_modules/socket.io-client/lib/on.js\");\nvar bind = __webpack_require__(/*! component-bind */ \"./node_modules/component-bind/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('socket.io-client:manager');\nvar indexOf = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\nvar Backoff = __webpack_require__(/*! backo2 */ \"./node_modules/backo2/index.js\");\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  var _parser = opts.parser || parser;\n  this.encoder = new _parser.Encoder();\n  this.decoder = new _parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.generateId(nsp);\n    }\n  }\n};\n\n/**\n * generate `socket.id` for the given `nsp`\n *\n * @param {String} nsp\n * @return {String}\n * @api private\n */\n\nManager.prototype.generateId = function (nsp) {\n  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.generateId(nsp);\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting event is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcz83OGViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgX3BhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZW5lcmF0ZSBgc29ja2V0LmlkYCBmb3IgdGhlIGdpdmVuIGBuc3BgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIChuc3ApIHtcbiAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogKG5zcCArICcjJykpICsgdGhpcy5lbmdpbmUuaWQ7XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlKCkgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZyAoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3Vic0xlbmd0aCA9IHRoaXMuc3Vicy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuICAgIHN1Yi5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/socket.io-client/lib/manager.js\n");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/on.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-client/lib/on.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvb24uanM/ZDgzOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24gKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/socket.io-client/lib/on.js\n");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/index.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar toArray = __webpack_require__(/*! to-array */ \"./node_modules/to-array/index.js\");\nvar on = __webpack_require__(/*! ./on */ \"./node_modules/socket.io-client/lib/on.js\");\nvar bind = __webpack_require__(/*! component-bind */ \"./node_modules/component-bind/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('socket.io-client:socket');\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\nvar hasBin = __webpack_require__(/*! has-binary2 */ \"./node_modules/has-binary2/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  this.flags = {};\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var packet = {\n    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,\n    data: args\n  };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  this.flags = {};\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;\n      debug('sending connect packet with query %s', query);\n      this.packet({type: parser.CONNECT, query: query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  if (packet.nsp !== this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    self.packet({\n      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags.compress = compress;\n  return this;\n};\n\n/**\n * Sets the binary flag\n *\n * @param {Boolean} whether the emitted data contains binary\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.binary = function (binary) {\n  this.flags.binary = binary;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzPzI4NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RCxLQUFLO0FBQ0wsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUEsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpbywgbnNwLCBvcHRzKSB7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5mbGFncyA9IHt9O1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogKHRoaXMuZmxhZ3MuYmluYXJ5ICE9PSB1bmRlZmluZWQgPyB0aGlzLmZsYWdzLmJpbmFyeSA6IGhhc0JpbihhcmdzKSkgPyBwYXJzZXIuQklOQVJZX0VWRU5UIDogcGFyc2VyLkVWRU5ULFxuICAgIGRhdGE6IGFyZ3NcbiAgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIHRoaXMuZmxhZ3MgPSB7fTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnkgPSB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG4gICAgICBkZWJ1Zygnc2VuZGluZyBjb25uZWN0IHBhY2tldCB3aXRoIHF1ZXJ5ICVzJywgcXVlcnkpO1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNUfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmIChwYWNrZXQubnNwICE9PSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGJpbmFyeSBmbGFnXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRoZSBlbWl0dGVkIGRhdGEgY29udGFpbnMgYmluYXJ5XG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gIHRoaXMuZmxhZ3MuYmluYXJ5ID0gYmluYXJ5O1xuICByZXR1cm4gdGhpcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/socket.io-client/lib/socket.js\n");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/url.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io-client/lib/url.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module dependencies.\n */\n\nvar parseuri = __webpack_require__(/*! parseuri */ \"./node_modules/parseuri/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzP2NjOWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/socket.io-client/lib/url.js\n");

/***/ }),

/***/ "./node_modules/socket.io-parser/binary.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-parser/binary.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"./node_modules/socket.io-parser/is-buffer.js\");\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanM/NzAzZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0gsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsS0FBSyx5QkFBeUI7QUFDOUIscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsS0FBSyxtREFBbUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgZ2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG5mdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gIGlmIChpc0J1ZihkYXRhKSkge1xuICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/socket.io-parser/binary.js\n");

/***/ }),

/***/ "./node_modules/socket.io-parser/index.js":
/*!************************************************!*\
  !*** ./node_modules/socket.io-parser/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('socket.io-parser');\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar binary = __webpack_require__(/*! ./binary */ \"./node_modules/socket.io-parser/binary.js\");\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"./node_modules/socket.io-parser/is-buffer.js\");\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var buf = '';\n    while (str.charAt(++i) !== '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      p.nsp += c;\n      if (i === str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i === str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcz81NjhkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbnZhciBFUlJPUl9QQUNLRVQgPSBleHBvcnRzLkVSUk9SICsgJ1wiZW5jb2RlIGVycm9yXCInO1xuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHZhciBzdHIgPSAnJyArIG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9PSBvYmoubnNwKSB7XG4gICAgc3RyICs9IG9iai5uc3AgKyAnLCc7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIHZhciBwYXlsb2FkID0gdHJ5U3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgICBpZiAocGF5bG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHN0ciArPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRVJST1JfUEFDS0VUO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBpID0gMDtcbiAgLy8gbG9vayB1cCB0eXBlXG4gIHZhciBwID0ge1xuICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKVxuICB9O1xuXG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkge1xuICAgIHJldHVybiBlcnJvcigndW5rbm93biBwYWNrZXQgdHlwZSAnICsgcC50eXBlKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHZhciBwYXlsb2FkID0gdHJ5UGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgdmFyIGlzUGF5bG9hZFZhbGlkID0gcGF5bG9hZCAhPT0gZmFsc2UgJiYgKHAudHlwZSA9PT0gZXhwb3J0cy5FUlJPUiB8fCBpc0FycmF5KHBheWxvYWQpKTtcbiAgICBpZiAoaXNQYXlsb2FkVmFsaWQpIHtcbiAgICAgIHAuZGF0YSA9IHBheWxvYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlcnJvcignaW52YWxpZCBwYXlsb2FkJyk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdHJ5UGFyc2Uoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3I6ICcgKyBtc2dcbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/socket.io-parser/index.js\n");

/***/ }),

/***/ "./node_modules/socket.io-parser/is-buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-parser/is-buffer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\nmodule.exports = isBuf;\n\nvar withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';\nvar withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';\n\nvar isView = (function () {\n  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {\n    return global.ArrayBuffer.isView;\n  } else {\n    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };\n  }\n})();\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||\n          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanM/ZjkyMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCLGlEQUFpRDtBQUM1RTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxudmFyIHdpdGhOYXRpdmVCdWZmZXIgPSB0eXBlb2YgZ2xvYmFsLkJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbnZhciB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNWaWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQXJyYXlCdWZmZXIuaXNWaWV3O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmouYnVmZmVyIGluc3RhbmNlb2YgZ2xvYmFsLkFycmF5QnVmZmVyOyB9O1xuICB9XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAod2l0aE5hdGl2ZUJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgZ2xvYmFsLkFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/socket.io-parser/is-buffer.js\n");

/***/ }),

/***/ "./node_modules/to-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/to-array/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG8tYXJyYXkvaW5kZXguanM/OTEyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXVxuXG4gICAgaW5kZXggPSBpbmRleCB8fCAwXG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/to-array/index.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWVhc3QvaW5kZXguanM/MDI5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy95ZWFzdC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yeast/index.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const io = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/lib/index.js\")\r\nconst paper = __webpack_require__(/*! paper */ \"./node_modules/paper/dist/paper-full.js\")\r\nconst { redraw } = __webpack_require__(/*! ./rendering/render */ \"./src/rendering/render.js\")\r\nconst createGameController = __webpack_require__(/*! ./state/gameStateController */ \"./src/state/gameStateController.js\")\r\nconst actions = __webpack_require__(/*! ./state/actions */ \"./src/state/actions.js\")\r\n\r\nlet gameController\r\nconst socket = io()\r\nsocket.emit('initialize', { atPlayerTime: Date.now() })\r\nsocket.on('initialize', ({ player, atPlayerTime, atServerTime }) => {\r\n    currentTime = Date.now()\r\n    const serverDelay = (currentTime - atPlayerTime) / 2\r\n    const serverOffset = -(currentTime - serverDelay - atServerTime)\r\n    const startingGameTime = currentTime - serverDelay + serverOffset\r\n    gameController = createGameController(player, socket, serverDelay, serverOffset, startingGameTime)\r\n})\r\n\r\npaper.install(window)\r\n\r\nwindow.onload = function () {\r\n    const canvas = document.getElementById('myCanvas')\r\n    paper.setup(canvas);\r\n    var tool = new paper.Tool()\r\n\r\n    // createShip({ x: 400, y: 400 }, 90)\r\n    let turnDirection\r\n    tool.onKeyDown = function (event) {\r\n        if (gameController) {\r\n            if (event.key === 'up') {\r\n                gameController.initiateAction(actions.startMoving())\r\n            } else if (event.key === 'down') {\r\n\r\n            } else if (event.key === 'left') {\r\n                turnDirection = 'left'\r\n                gameController.initiateAction(actions.startTurning('left'))\r\n            } else if (event.key === 'right') {\r\n                turnDirection = 'right'\r\n                gameController.initiateAction(actions.startTurning('right'))\r\n            }\r\n        }\r\n    }\r\n\r\n    tool.onKeyUp = function (event) {\r\n        if (gameController) {\r\n            if (event.key === 'up') {\r\n                gameController.initiateAction(actions.stopMoving())\r\n            } else if (event.key === 'down') {\r\n\r\n            } else if (event.key === 'left') {\r\n                if (turnDirection === 'left') {\r\n                    turnDirection = undefined\r\n                    gameController.initiateAction(actions.stopTurning())\r\n                }\r\n            } else if (event.key === 'right') {\r\n                if (turnDirection === 'right') {\r\n                    turnDirection = undefined\r\n                    gameController.initiateAction(actions.stopTurning())\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    view.onFrame = function (event) {\r\n        if (gameController) {\r\n            const currentState = gameController.currentState()\r\n            redraw(currentState, project.activeLayer)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction createShip({ x, y }, rotation) {\r\n    var radius = 20;\r\n    var angle = rotation - 30;\r\n\r\n    var circle = new Path.Circle(new Point(x, y), radius);\r\n    var triangle = new Path.RegularPolygon(new Point(x, y), 3, radius);\r\n    var triangle2 = new Path.RegularPolygon(new Point(x, y), 3, radius / 2);\r\n\r\n    triangle.insert(1, new Point(x, y));\r\n    triangle2.insert(1, new Point(x, y));\r\n\r\n    var ship = new CompoundPath({\r\n        children: [\r\n            triangle, triangle2, circle\r\n        ],\r\n        // selected: true\r\n    })\r\n    ship.strokeColor = 'cyan';\r\n    ship.strokeWidth = 2;\r\n    ship.rotate(angle);\r\n    return ship\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsT0FBTyxTQUFTO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50JylcclxuY29uc3QgcGFwZXIgPSByZXF1aXJlKCdwYXBlcicpXHJcbmNvbnN0IHsgcmVkcmF3IH0gPSByZXF1aXJlKCcuL3JlbmRlcmluZy9yZW5kZXInKVxyXG5jb25zdCBjcmVhdGVHYW1lQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vc3RhdGUvZ2FtZVN0YXRlQ29udHJvbGxlcicpXHJcbmNvbnN0IGFjdGlvbnMgPSByZXF1aXJlKCcuL3N0YXRlL2FjdGlvbnMnKVxyXG5cclxubGV0IGdhbWVDb250cm9sbGVyXHJcbmNvbnN0IHNvY2tldCA9IGlvKClcclxuc29ja2V0LmVtaXQoJ2luaXRpYWxpemUnLCB7IGF0UGxheWVyVGltZTogRGF0ZS5ub3coKSB9KVxyXG5zb2NrZXQub24oJ2luaXRpYWxpemUnLCAoeyBwbGF5ZXIsIGF0UGxheWVyVGltZSwgYXRTZXJ2ZXJUaW1lIH0pID0+IHtcclxuICAgIGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxyXG4gICAgY29uc3Qgc2VydmVyRGVsYXkgPSAoY3VycmVudFRpbWUgLSBhdFBsYXllclRpbWUpIC8gMlxyXG4gICAgY29uc3Qgc2VydmVyT2Zmc2V0ID0gLShjdXJyZW50VGltZSAtIHNlcnZlckRlbGF5IC0gYXRTZXJ2ZXJUaW1lKVxyXG4gICAgY29uc3Qgc3RhcnRpbmdHYW1lVGltZSA9IGN1cnJlbnRUaW1lIC0gc2VydmVyRGVsYXkgKyBzZXJ2ZXJPZmZzZXRcclxuICAgIGdhbWVDb250cm9sbGVyID0gY3JlYXRlR2FtZUNvbnRyb2xsZXIocGxheWVyLCBzb2NrZXQsIHNlcnZlckRlbGF5LCBzZXJ2ZXJPZmZzZXQsIHN0YXJ0aW5nR2FtZVRpbWUpXHJcbn0pXHJcblxyXG5wYXBlci5pbnN0YWxsKHdpbmRvdylcclxuXHJcbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlDYW52YXMnKVxyXG4gICAgcGFwZXIuc2V0dXAoY2FudmFzKTtcclxuICAgIHZhciB0b29sID0gbmV3IHBhcGVyLlRvb2woKVxyXG5cclxuICAgIC8vIGNyZWF0ZVNoaXAoeyB4OiA0MDAsIHk6IDQwMCB9LCA5MClcclxuICAgIGxldCB0dXJuRGlyZWN0aW9uXHJcbiAgICB0b29sLm9uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmIChnYW1lQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgICBnYW1lQ29udHJvbGxlci5pbml0aWF0ZUFjdGlvbihhY3Rpb25zLnN0YXJ0TW92aW5nKCkpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnZG93bicpIHtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgIHR1cm5EaXJlY3Rpb24gPSAnbGVmdCdcclxuICAgICAgICAgICAgICAgIGdhbWVDb250cm9sbGVyLmluaXRpYXRlQWN0aW9uKGFjdGlvbnMuc3RhcnRUdXJuaW5nKCdsZWZ0JykpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICB0dXJuRGlyZWN0aW9uID0gJ3JpZ2h0J1xyXG4gICAgICAgICAgICAgICAgZ2FtZUNvbnRyb2xsZXIuaW5pdGlhdGVBY3Rpb24oYWN0aW9ucy5zdGFydFR1cm5pbmcoJ3JpZ2h0JykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9vbC5vbktleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGdhbWVDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICAgIGdhbWVDb250cm9sbGVyLmluaXRpYXRlQWN0aW9uKGFjdGlvbnMuc3RvcE1vdmluZygpKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ2Rvd24nKSB7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHVybkRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHVybkRpcmVjdGlvbiA9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIGdhbWVDb250cm9sbGVyLmluaXRpYXRlQWN0aW9uKGFjdGlvbnMuc3RvcFR1cm5pbmcoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0dXJuRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHVybkRpcmVjdGlvbiA9IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIGdhbWVDb250cm9sbGVyLmluaXRpYXRlQWN0aW9uKGFjdGlvbnMuc3RvcFR1cm5pbmcoKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2aWV3Lm9uRnJhbWUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZ2FtZUNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gZ2FtZUNvbnRyb2xsZXIuY3VycmVudFN0YXRlKClcclxuICAgICAgICAgICAgcmVkcmF3KGN1cnJlbnRTdGF0ZSwgcHJvamVjdC5hY3RpdmVMYXllcilcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU2hpcCh7IHgsIHkgfSwgcm90YXRpb24pIHtcclxuICAgIHZhciByYWRpdXMgPSAyMDtcclxuICAgIHZhciBhbmdsZSA9IHJvdGF0aW9uIC0gMzA7XHJcblxyXG4gICAgdmFyIGNpcmNsZSA9IG5ldyBQYXRoLkNpcmNsZShuZXcgUG9pbnQoeCwgeSksIHJhZGl1cyk7XHJcbiAgICB2YXIgdHJpYW5nbGUgPSBuZXcgUGF0aC5SZWd1bGFyUG9seWdvbihuZXcgUG9pbnQoeCwgeSksIDMsIHJhZGl1cyk7XHJcbiAgICB2YXIgdHJpYW5nbGUyID0gbmV3IFBhdGguUmVndWxhclBvbHlnb24obmV3IFBvaW50KHgsIHkpLCAzLCByYWRpdXMgLyAyKTtcclxuXHJcbiAgICB0cmlhbmdsZS5pbnNlcnQoMSwgbmV3IFBvaW50KHgsIHkpKTtcclxuICAgIHRyaWFuZ2xlMi5pbnNlcnQoMSwgbmV3IFBvaW50KHgsIHkpKTtcclxuXHJcbiAgICB2YXIgc2hpcCA9IG5ldyBDb21wb3VuZFBhdGgoe1xyXG4gICAgICAgIGNoaWxkcmVuOiBbXHJcbiAgICAgICAgICAgIHRyaWFuZ2xlLCB0cmlhbmdsZTIsIGNpcmNsZVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgLy8gc2VsZWN0ZWQ6IHRydWVcclxuICAgIH0pXHJcbiAgICBzaGlwLnN0cm9rZUNvbG9yID0gJ2N5YW4nO1xyXG4gICAgc2hpcC5zdHJva2VXaWR0aCA9IDI7XHJcbiAgICBzaGlwLnJvdGF0ZShhbmdsZSk7XHJcbiAgICByZXR1cm4gc2hpcFxyXG59XHJcblxyXG5cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/rendering/Ship.js":
/*!*******************************!*\
  !*** ./src/rendering/Ship.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function createShip({ x, y }, direction, color) {\r\n    var vector = new Point(direction)\r\n    var radius = 20;\r\n    var angle = vector.angle - 30;\r\n\r\n    var circle = new Path.Circle(new Point(x, y), radius);\r\n    var triangle = new Path.RegularPolygon(new Point(x, y), 3, radius);\r\n    var triangle2 = new Path.RegularPolygon(new Point(x, y), 3, radius / 2);\r\n\r\n    triangle.insert(1, new Point(x, y));\r\n    triangle2.insert(1, new Point(x, y));\r\n\r\n    var ship = new CompoundPath({\r\n        children: [\r\n            triangle, triangle2, circle\r\n        ],\r\n        // selected: true\r\n    })\r\n    ship.strokeColor = color;\r\n    ship.strokeWidth = 2;\r\n    ship.rotate(angle);\r\n    return ship\r\n}\r\n\r\nmodule.exports = createShip\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyaW5nL1NoaXAuanM/MGE0ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vc3JjL3JlbmRlcmluZy9TaGlwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY3JlYXRlU2hpcCh7IHgsIHkgfSwgZGlyZWN0aW9uLCBjb2xvcikge1xyXG4gICAgdmFyIHZlY3RvciA9IG5ldyBQb2ludChkaXJlY3Rpb24pXHJcbiAgICB2YXIgcmFkaXVzID0gMjA7XHJcbiAgICB2YXIgYW5nbGUgPSB2ZWN0b3IuYW5nbGUgLSAzMDtcclxuXHJcbiAgICB2YXIgY2lyY2xlID0gbmV3IFBhdGguQ2lyY2xlKG5ldyBQb2ludCh4LCB5KSwgcmFkaXVzKTtcclxuICAgIHZhciB0cmlhbmdsZSA9IG5ldyBQYXRoLlJlZ3VsYXJQb2x5Z29uKG5ldyBQb2ludCh4LCB5KSwgMywgcmFkaXVzKTtcclxuICAgIHZhciB0cmlhbmdsZTIgPSBuZXcgUGF0aC5SZWd1bGFyUG9seWdvbihuZXcgUG9pbnQoeCwgeSksIDMsIHJhZGl1cyAvIDIpO1xyXG5cclxuICAgIHRyaWFuZ2xlLmluc2VydCgxLCBuZXcgUG9pbnQoeCwgeSkpO1xyXG4gICAgdHJpYW5nbGUyLmluc2VydCgxLCBuZXcgUG9pbnQoeCwgeSkpO1xyXG5cclxuICAgIHZhciBzaGlwID0gbmV3IENvbXBvdW5kUGF0aCh7XHJcbiAgICAgICAgY2hpbGRyZW46IFtcclxuICAgICAgICAgICAgdHJpYW5nbGUsIHRyaWFuZ2xlMiwgY2lyY2xlXHJcbiAgICAgICAgXSxcclxuICAgICAgICAvLyBzZWxlY3RlZDogdHJ1ZVxyXG4gICAgfSlcclxuICAgIHNoaXAuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcclxuICAgIHNoaXAuc3Ryb2tlV2lkdGggPSAyO1xyXG4gICAgc2hpcC5yb3RhdGUoYW5nbGUpO1xyXG4gICAgcmV0dXJuIHNoaXBcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTaGlwXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/rendering/Ship.js\n");

/***/ }),

/***/ "./src/rendering/render.js":
/*!*********************************!*\
  !*** ./src/rendering/render.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const createShip = __webpack_require__(/*! ./Ship */ \"./src/rendering/Ship.js\")\r\n\r\nfunction redraw(state, layer) {\r\n    layer.remove()\r\n    new Layer()\r\n    const player2Ship = createShip(state.player2.position, state.player2.direction, 'red')\r\n    const player1Ship = createShip(state.player1.position, state.player1.direction, 'cyan')\r\n}\r\n\r\nmodule.exports = {\r\n    redraw\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyaW5nL3JlbmRlci5qcz8wYzY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvcmVuZGVyaW5nL3JlbmRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyZWF0ZVNoaXAgPSByZXF1aXJlKCcuL1NoaXAnKVxyXG5cclxuZnVuY3Rpb24gcmVkcmF3KHN0YXRlLCBsYXllcikge1xyXG4gICAgbGF5ZXIucmVtb3ZlKClcclxuICAgIG5ldyBMYXllcigpXHJcbiAgICBjb25zdCBwbGF5ZXIyU2hpcCA9IGNyZWF0ZVNoaXAoc3RhdGUucGxheWVyMi5wb3NpdGlvbiwgc3RhdGUucGxheWVyMi5kaXJlY3Rpb24sICdyZWQnKVxyXG4gICAgY29uc3QgcGxheWVyMVNoaXAgPSBjcmVhdGVTaGlwKHN0YXRlLnBsYXllcjEucG9zaXRpb24sIHN0YXRlLnBsYXllcjEuZGlyZWN0aW9uLCAnY3lhbicpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgcmVkcmF3XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/rendering/render.js\n");

/***/ }),

/***/ "./src/state/actions.js":
/*!******************************!*\
  !*** ./src/state/actions.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function startMoving() {\r\n    return {\r\n        type: \"start moving\",\r\n    }\r\n}\r\n\r\nfunction stopMoving() {\r\n    return {\r\n        type: \"stop moving\",\r\n    }\r\n}\r\n\r\nfunction startTurning(direction) {\r\n    return {\r\n        type: \"start turning\",\r\n        direction, //\"left\" or \"right\"\r\n    }\r\n}\r\n\r\nfunction stopTurning() {\r\n    return {\r\n        type: \"stop turning\",\r\n    }\r\n}\r\n\r\nfunction shoot() {\r\n    return {\r\n        type: \"shoot\",\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    startMoving,\r\n    stopMoving,\r\n    startTurning,\r\n    stopTurning,\r\n    shoot,\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGUvYWN0aW9ucy5qcz9mNzhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL3N0YXRlL2FjdGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzdGFydE1vdmluZygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJzdGFydCBtb3ZpbmdcIixcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcE1vdmluZygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJzdG9wIG1vdmluZ1wiLFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFydFR1cm5pbmcoZGlyZWN0aW9uKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic3RhcnQgdHVybmluZ1wiLFxyXG4gICAgICAgIGRpcmVjdGlvbiwgLy9cImxlZnRcIiBvciBcInJpZ2h0XCJcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcFR1cm5pbmcoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic3RvcCB0dXJuaW5nXCIsXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob290KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInNob290XCIsXHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc3RhcnRNb3ZpbmcsXHJcbiAgICBzdG9wTW92aW5nLFxyXG4gICAgc3RhcnRUdXJuaW5nLFxyXG4gICAgc3RvcFR1cm5pbmcsXHJcbiAgICBzaG9vdCxcclxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/state/actions.js\n");

/***/ }),

/***/ "./src/state/gameStateController.js":
/*!******************************************!*\
  !*** ./src/state/gameStateController.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { reducer } = __webpack_require__(/*! ./reducer */ \"./src/state/reducer.js\")\r\nconst { initialState } = __webpack_require__(/*! ./initialState */ \"./src/state/initialState.js\")\r\nconst actions = __webpack_require__(/*! ./actions */ \"./src/state/actions.js\")\r\nconst tick = __webpack_require__(/*! ./tick */ \"./src/state/tick.js\")\r\n\r\n\r\n\r\nfunction createGameController(player, socket, serverDelay, serverOffset, startingGameTime) {\r\n    console.log('sever delay: ', serverDelay, 'serverOffset: ', serverOffset)\r\n    console.log(`${player} has joined the game`)\r\n    let actionID = 0\r\n    initialState.gameTime = startingGameTime\r\n    console.log('starting state', initialState)\r\n    let history = [initialState]\r\n\r\n    socket.on('action', (action) => {\r\n        const currentTime = Date.now()\r\n        if (action.player === player) {\r\n            serverDelay = (currentTime - action.atPlayerTime) / 2\r\n            history = replaceAction(history, action)\r\n            console.log('replace action ', action, ' in ', history.map(({ action }) => action))\r\n        } else {\r\n            history = insertAction(history, action)\r\n            console.log('inject action ', action, 'into ', history.map(({ action }) => action))\r\n        }\r\n    })\r\n\r\n    function addTimestamp(action, time) {\r\n        return { ...action, atPlayerTime: time, player, id: actionID++ }\r\n    }\r\n\r\n    return {\r\n        initiateAction(action) {\r\n            action.player = player\r\n            let currentTime = Date.now()\r\n            action = addTimestamp(action, currentTime)\r\n            socket.emit('action', action)\r\n            action.atServerTime = currentTime - serverDelay + serverOffset //estimate\r\n            const nextState = reducer(lastState(history), action)\r\n            history.push(nextState)\r\n            console.log('adding estimated action ', action, ' into ', history.map(({ action }) => action))\r\n            // console.log('estimated history: ', history)\r\n        },\r\n\r\n        currentState() {\r\n            let gameTime = Date.now() - serverDelay + serverOffset\r\n            const state = lastState(history)\r\n            // console.log('current time: ', gameTime, 'saved time: ', state.gameTime)\r\n            return tick(state, gameTime)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nfunction lastState(history) {\r\n    return history[history.length - 1]\r\n}\r\n\r\nfunction replaceAction(history, replacementAction) {\r\n    let actionIndex = history.findIndex(({ action }) => isMatchingAction(action))\r\n    const previousHistory = history.slice(0, actionIndex)\r\n    const newHistory = recomputeWithAction(history.slice(actionIndex + 1), replacementAction, lastState(previousHistory))\r\n    return previousHistory.concat(newHistory)\r\n\r\n    function isMatchingAction(action) {\r\n        return action.id === replacementAction.id && action.player === replacementAction.player\r\n    }\r\n}\r\n\r\nfunction insertAction(history, newAction) {\r\n    for (let i = history.length - 1; i >= 0; i--) {\r\n        if (history[i].gameTime < newAction.atServerTime) {\r\n            const previousHistory = history.slice(0, i + 1)\r\n            const newHistory = recomputeWithAction(history.slice(i + 1), newAction, lastState(previousHistory))\r\n            return previousHistory.concat(newHistory)\r\n        }\r\n    }\r\n}\r\n\r\nfunction recomputeWithAction(history, action, startingState) {\r\n    const actionList = history.map(({ action }) => action)\r\n    actionList.unshift(action)\r\n    return actionList.reduce(\r\n        (state, action) => {\r\n            const nextState = reducer(lastState(state), action)\r\n            state.push(nextState)\r\n            return state\r\n        }\r\n        , [startingState]\r\n    ).slice(1)\r\n}\r\n\r\nmodule.exports = createGameController\r\n\r\n// serverDelay = (currentTime - atPlayerTime) / 2\r\n// gameTime = serverDelay + atServerTime //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGUvZ2FtZVN0YXRlQ29udHJvbGxlci5qcz8zM2FjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sVUFBVTtBQUNqQixPQUFPLGVBQWU7QUFDdEI7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEYsU0FBUztBQUNUO0FBQ0EseUVBQXlFLFNBQVM7QUFDbEY7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixTQUFTO0FBQzdGO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiIuL3NyYy9zdGF0ZS9nYW1lU3RhdGVDb250cm9sbGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyByZWR1Y2VyIH0gPSByZXF1aXJlKCcuL3JlZHVjZXInKVxyXG5jb25zdCB7IGluaXRpYWxTdGF0ZSB9ID0gcmVxdWlyZSgnLi9pbml0aWFsU3RhdGUnKVxyXG5jb25zdCBhY3Rpb25zID0gcmVxdWlyZSgnLi9hY3Rpb25zJylcclxuY29uc3QgdGljayA9IHJlcXVpcmUoJy4vdGljaycpXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUdhbWVDb250cm9sbGVyKHBsYXllciwgc29ja2V0LCBzZXJ2ZXJEZWxheSwgc2VydmVyT2Zmc2V0LCBzdGFydGluZ0dhbWVUaW1lKSB7XHJcbiAgICBjb25zb2xlLmxvZygnc2V2ZXIgZGVsYXk6ICcsIHNlcnZlckRlbGF5LCAnc2VydmVyT2Zmc2V0OiAnLCBzZXJ2ZXJPZmZzZXQpXHJcbiAgICBjb25zb2xlLmxvZyhgJHtwbGF5ZXJ9IGhhcyBqb2luZWQgdGhlIGdhbWVgKVxyXG4gICAgbGV0IGFjdGlvbklEID0gMFxyXG4gICAgaW5pdGlhbFN0YXRlLmdhbWVUaW1lID0gc3RhcnRpbmdHYW1lVGltZVxyXG4gICAgY29uc29sZS5sb2coJ3N0YXJ0aW5nIHN0YXRlJywgaW5pdGlhbFN0YXRlKVxyXG4gICAgbGV0IGhpc3RvcnkgPSBbaW5pdGlhbFN0YXRlXVxyXG5cclxuICAgIHNvY2tldC5vbignYWN0aW9uJywgKGFjdGlvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxyXG4gICAgICAgIGlmIChhY3Rpb24ucGxheWVyID09PSBwbGF5ZXIpIHtcclxuICAgICAgICAgICAgc2VydmVyRGVsYXkgPSAoY3VycmVudFRpbWUgLSBhY3Rpb24uYXRQbGF5ZXJUaW1lKSAvIDJcclxuICAgICAgICAgICAgaGlzdG9yeSA9IHJlcGxhY2VBY3Rpb24oaGlzdG9yeSwgYWN0aW9uKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygncmVwbGFjZSBhY3Rpb24gJywgYWN0aW9uLCAnIGluICcsIGhpc3RvcnkubWFwKCh7IGFjdGlvbiB9KSA9PiBhY3Rpb24pKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhpc3RvcnkgPSBpbnNlcnRBY3Rpb24oaGlzdG9yeSwgYWN0aW9uKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW5qZWN0IGFjdGlvbiAnLCBhY3Rpb24sICdpbnRvICcsIGhpc3RvcnkubWFwKCh7IGFjdGlvbiB9KSA9PiBhY3Rpb24pKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgZnVuY3Rpb24gYWRkVGltZXN0YW1wKGFjdGlvbiwgdGltZSkge1xyXG4gICAgICAgIHJldHVybiB7IC4uLmFjdGlvbiwgYXRQbGF5ZXJUaW1lOiB0aW1lLCBwbGF5ZXIsIGlkOiBhY3Rpb25JRCsrIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXRpYXRlQWN0aW9uKGFjdGlvbikge1xyXG4gICAgICAgICAgICBhY3Rpb24ucGxheWVyID0gcGxheWVyXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50VGltZSA9IERhdGUubm93KClcclxuICAgICAgICAgICAgYWN0aW9uID0gYWRkVGltZXN0YW1wKGFjdGlvbiwgY3VycmVudFRpbWUpXHJcbiAgICAgICAgICAgIHNvY2tldC5lbWl0KCdhY3Rpb24nLCBhY3Rpb24pXHJcbiAgICAgICAgICAgIGFjdGlvbi5hdFNlcnZlclRpbWUgPSBjdXJyZW50VGltZSAtIHNlcnZlckRlbGF5ICsgc2VydmVyT2Zmc2V0IC8vZXN0aW1hdGVcclxuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gcmVkdWNlcihsYXN0U3RhdGUoaGlzdG9yeSksIGFjdGlvbilcclxuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKG5leHRTdGF0ZSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FkZGluZyBlc3RpbWF0ZWQgYWN0aW9uICcsIGFjdGlvbiwgJyBpbnRvICcsIGhpc3RvcnkubWFwKCh7IGFjdGlvbiB9KSA9PiBhY3Rpb24pKVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZXN0aW1hdGVkIGhpc3Rvcnk6ICcsIGhpc3RvcnkpXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY3VycmVudFN0YXRlKCkge1xyXG4gICAgICAgICAgICBsZXQgZ2FtZVRpbWUgPSBEYXRlLm5vdygpIC0gc2VydmVyRGVsYXkgKyBzZXJ2ZXJPZmZzZXRcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBsYXN0U3RhdGUoaGlzdG9yeSlcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N1cnJlbnQgdGltZTogJywgZ2FtZVRpbWUsICdzYXZlZCB0aW1lOiAnLCBzdGF0ZS5nYW1lVGltZSlcclxuICAgICAgICAgICAgcmV0dXJuIHRpY2soc3RhdGUsIGdhbWVUaW1lKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gbGFzdFN0YXRlKGhpc3RvcnkpIHtcclxuICAgIHJldHVybiBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUFjdGlvbihoaXN0b3J5LCByZXBsYWNlbWVudEFjdGlvbikge1xyXG4gICAgbGV0IGFjdGlvbkluZGV4ID0gaGlzdG9yeS5maW5kSW5kZXgoKHsgYWN0aW9uIH0pID0+IGlzTWF0Y2hpbmdBY3Rpb24oYWN0aW9uKSlcclxuICAgIGNvbnN0IHByZXZpb3VzSGlzdG9yeSA9IGhpc3Rvcnkuc2xpY2UoMCwgYWN0aW9uSW5kZXgpXHJcbiAgICBjb25zdCBuZXdIaXN0b3J5ID0gcmVjb21wdXRlV2l0aEFjdGlvbihoaXN0b3J5LnNsaWNlKGFjdGlvbkluZGV4ICsgMSksIHJlcGxhY2VtZW50QWN0aW9uLCBsYXN0U3RhdGUocHJldmlvdXNIaXN0b3J5KSlcclxuICAgIHJldHVybiBwcmV2aW91c0hpc3RvcnkuY29uY2F0KG5ld0hpc3RvcnkpXHJcblxyXG4gICAgZnVuY3Rpb24gaXNNYXRjaGluZ0FjdGlvbihhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gYWN0aW9uLmlkID09PSByZXBsYWNlbWVudEFjdGlvbi5pZCAmJiBhY3Rpb24ucGxheWVyID09PSByZXBsYWNlbWVudEFjdGlvbi5wbGF5ZXJcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0QWN0aW9uKGhpc3RvcnksIG5ld0FjdGlvbikge1xyXG4gICAgZm9yIChsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZiAoaGlzdG9yeVtpXS5nYW1lVGltZSA8IG5ld0FjdGlvbi5hdFNlcnZlclRpbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNIaXN0b3J5ID0gaGlzdG9yeS5zbGljZSgwLCBpICsgMSlcclxuICAgICAgICAgICAgY29uc3QgbmV3SGlzdG9yeSA9IHJlY29tcHV0ZVdpdGhBY3Rpb24oaGlzdG9yeS5zbGljZShpICsgMSksIG5ld0FjdGlvbiwgbGFzdFN0YXRlKHByZXZpb3VzSGlzdG9yeSkpXHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c0hpc3RvcnkuY29uY2F0KG5ld0hpc3RvcnkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNvbXB1dGVXaXRoQWN0aW9uKGhpc3RvcnksIGFjdGlvbiwgc3RhcnRpbmdTdGF0ZSkge1xyXG4gICAgY29uc3QgYWN0aW9uTGlzdCA9IGhpc3RvcnkubWFwKCh7IGFjdGlvbiB9KSA9PiBhY3Rpb24pXHJcbiAgICBhY3Rpb25MaXN0LnVuc2hpZnQoYWN0aW9uKVxyXG4gICAgcmV0dXJuIGFjdGlvbkxpc3QucmVkdWNlKFxyXG4gICAgICAgIChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHJlZHVjZXIobGFzdFN0YXRlKHN0YXRlKSwgYWN0aW9uKVxyXG4gICAgICAgICAgICBzdGF0ZS5wdXNoKG5leHRTdGF0ZSlcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgICwgW3N0YXJ0aW5nU3RhdGVdXHJcbiAgICApLnNsaWNlKDEpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlR2FtZUNvbnRyb2xsZXJcclxuXHJcbi8vIHNlcnZlckRlbGF5ID0gKGN1cnJlbnRUaW1lIC0gYXRQbGF5ZXJUaW1lKSAvIDJcclxuLy8gZ2FtZVRpbWUgPSBzZXJ2ZXJEZWxheSArIGF0U2VydmVyVGltZSAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/state/gameStateController.js\n");

/***/ }),

/***/ "./src/state/initialState.js":
/*!***********************************!*\
  !*** ./src/state/initialState.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const player1 = {\r\n    position: { x: 400, y: 400 },\r\n    direction: { x: 0, y: 1 },\r\n    turnDirection: null,\r\n    isMoving: false,\r\n}\r\n\r\nconst player2 = player1\r\n\r\nconst initialState = {\r\n    player1,\r\n    player2,\r\n    bullets: [],\r\n    asteroids: [],\r\n    action: { id: NaN },\r\n    gameTime: 0,\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    initialState\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGUvaW5pdGlhbFN0YXRlLmpzPzg5YTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvc3RhdGUvaW5pdGlhbFN0YXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGxheWVyMSA9IHtcclxuICAgIHBvc2l0aW9uOiB7IHg6IDQwMCwgeTogNDAwIH0sXHJcbiAgICBkaXJlY3Rpb246IHsgeDogMCwgeTogMSB9LFxyXG4gICAgdHVybkRpcmVjdGlvbjogbnVsbCxcclxuICAgIGlzTW92aW5nOiBmYWxzZSxcclxufVxyXG5cclxuY29uc3QgcGxheWVyMiA9IHBsYXllcjFcclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgIHBsYXllcjEsXHJcbiAgICBwbGF5ZXIyLFxyXG4gICAgYnVsbGV0czogW10sXHJcbiAgICBhc3Rlcm9pZHM6IFtdLFxyXG4gICAgYWN0aW9uOiB7IGlkOiBOYU4gfSxcclxuICAgIGdhbWVUaW1lOiAwLFxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBpbml0aWFsU3RhdGVcclxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/state/initialState.js\n");

/***/ }),

/***/ "./src/state/reducer.js":
/*!******************************!*\
  !*** ./src/state/reducer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const tick = __webpack_require__(/*! ./tick */ \"./src/state/tick.js\")\r\n\r\nfunction reducer(state, action) {\r\n    switch (action.type) {\r\n        case 'start moving':\r\n            return updatePlayer(action, 'isMoving', true, state)\r\n\r\n        case 'stop moving':\r\n            return updatePlayer(action, 'isMoving', false, state)\r\n\r\n        case 'start turning':\r\n            return updatePlayer(action, 'turnDirection', action.direction, state)\r\n\r\n        case 'stop turning':\r\n            return updatePlayer(action, 'turnDirection', null, state)\r\n\r\n        case 'shoot':\r\n\r\n\r\n        default: return state\r\n    }\r\n}\r\n\r\n\r\nfunction updatePlayer(action, prop, value, state) {\r\n    // console.log(action.atServerTime, state.gameTime)\r\n    const updatedPositions = tick(state, action.atServerTime)\r\n    const nextPlayer = updateProperty(getPlayer(action.player, updatedPositions), prop, value)\r\n    const updatedPlayer = updateProperty(updatedPositions, action.player, nextPlayer)\r\n    // console.log('old player: ', state.player1, 'new player: ', updatedPlayer.player1)\r\n    return { ...updatedPlayer, action }\r\n}\r\n\r\nfunction getPlayer(player, state) {\r\n    return player === 'player1' ? state.player1 : state.player2\r\n}\r\n\r\nfunction updateProperty(obj, prop, value) {\r\n    return { ...obj, [prop]: value }\r\n}\r\n\r\nmodule.exports = {\r\n    reducer\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGUvcmVkdWNlci5qcz9mMWViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL3N0YXRlL3JlZHVjZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0aWNrID0gcmVxdWlyZSgnLi90aWNrJylcclxuXHJcbmZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0YXJ0IG1vdmluZyc6XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQbGF5ZXIoYWN0aW9uLCAnaXNNb3ZpbmcnLCB0cnVlLCBzdGF0ZSlcclxuXHJcbiAgICAgICAgY2FzZSAnc3RvcCBtb3ZpbmcnOlxyXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUGxheWVyKGFjdGlvbiwgJ2lzTW92aW5nJywgZmFsc2UsIHN0YXRlKVxyXG5cclxuICAgICAgICBjYXNlICdzdGFydCB0dXJuaW5nJzpcclxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBsYXllcihhY3Rpb24sICd0dXJuRGlyZWN0aW9uJywgYWN0aW9uLmRpcmVjdGlvbiwgc3RhdGUpXHJcblxyXG4gICAgICAgIGNhc2UgJ3N0b3AgdHVybmluZyc6XHJcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQbGF5ZXIoYWN0aW9uLCAndHVybkRpcmVjdGlvbicsIG51bGwsIHN0YXRlKVxyXG5cclxuICAgICAgICBjYXNlICdzaG9vdCc6XHJcblxyXG5cclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gc3RhdGVcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVBsYXllcihhY3Rpb24sIHByb3AsIHZhbHVlLCBzdGF0ZSkge1xyXG4gICAgLy8gY29uc29sZS5sb2coYWN0aW9uLmF0U2VydmVyVGltZSwgc3RhdGUuZ2FtZVRpbWUpXHJcbiAgICBjb25zdCB1cGRhdGVkUG9zaXRpb25zID0gdGljayhzdGF0ZSwgYWN0aW9uLmF0U2VydmVyVGltZSlcclxuICAgIGNvbnN0IG5leHRQbGF5ZXIgPSB1cGRhdGVQcm9wZXJ0eShnZXRQbGF5ZXIoYWN0aW9uLnBsYXllciwgdXBkYXRlZFBvc2l0aW9ucyksIHByb3AsIHZhbHVlKVxyXG4gICAgY29uc3QgdXBkYXRlZFBsYXllciA9IHVwZGF0ZVByb3BlcnR5KHVwZGF0ZWRQb3NpdGlvbnMsIGFjdGlvbi5wbGF5ZXIsIG5leHRQbGF5ZXIpXHJcbiAgICAvLyBjb25zb2xlLmxvZygnb2xkIHBsYXllcjogJywgc3RhdGUucGxheWVyMSwgJ25ldyBwbGF5ZXI6ICcsIHVwZGF0ZWRQbGF5ZXIucGxheWVyMSlcclxuICAgIHJldHVybiB7IC4uLnVwZGF0ZWRQbGF5ZXIsIGFjdGlvbiB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBsYXllcihwbGF5ZXIsIHN0YXRlKSB7XHJcbiAgICByZXR1cm4gcGxheWVyID09PSAncGxheWVyMScgPyBzdGF0ZS5wbGF5ZXIxIDogc3RhdGUucGxheWVyMlxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0eShvYmosIHByb3AsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4geyAuLi5vYmosIFtwcm9wXTogdmFsdWUgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIHJlZHVjZXJcclxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/state/reducer.js\n");

/***/ }),

/***/ "./src/state/tick.js":
/*!***************************!*\
  !*** ./src/state/tick.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Point } = __webpack_require__(/*! paper */ \"./node_modules/paper/dist/paper-full.js\")\r\n\r\nconst playerSpeed = 0.15\r\nconst playerRotateSpeed = 0.5\r\n\r\nfunction tick(state, gameTime) {\r\n    // console.log('time delta', gameTime - state.gameTime)\r\n    // console.log('starting player', state.player1)\r\n    const player1 = moveAndRotate(state.player1, state.gameTime, gameTime)\r\n    const player2 = moveAndRotate(state.player2, state.gameTime, gameTime)\r\n    //move bullets\r\n    //move asteroids\r\n    // console.log(player1.position)\r\n    // console.log('ending player', player1)\r\n    return { ...state, gameTime, player1, player2 }\r\n}\r\n\r\nfunction moveAndRotate(obj, oldTime, newTime) {\r\n    const position = !obj.isMoving ?\r\n        obj.position : nextPosition(obj.position, obj.direction, playerSpeed, newTime - oldTime)\r\n    const direction = !obj.turnDirection ?\r\n        obj.direction : nextDirection(obj.direction, obj.turnDirection, playerRotateSpeed, newTime - oldTime)\r\n    return { ...obj, position, direction }\r\n}\r\n\r\nfunction nextPosition(startPosition, direction, speed, timeDelta) {\r\n    startPosition = toPoint(startPosition)\r\n    direction = toPoint(direction)\r\n    const distance = speed * timeDelta\r\n    direction = direction.normalize(distance)\r\n    const newPosition = startPosition.add(direction)\r\n    return fromPoint(newPosition)\r\n}\r\n\r\nfunction nextDirection(startVector, turnDirection, rotateSpeed, timeDelta) {\r\n    console.log('time delta: ', timeDelta)\r\n    const rotation = rotateSpeed * timeDelta\r\n    startVector = toPoint(startVector)\r\n    const nextVector = startVector.rotate(turnDirection === \"right\" ? rotation : -rotation)\r\n    return fromPoint(nextVector)\r\n}\r\n\r\nfunction toPoint({ x, y }) {\r\n    return new Point(x, y)\r\n}\r\n\r\nfunction fromPoint({ x, y }) {\r\n    return { x, y }\r\n}\r\nmodule.exports = tick//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3RhdGUvdGljay5qcz9jMDFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sUUFBUTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQixZQUFZO0FBQ1o7QUFDQSIsImZpbGUiOiIuL3NyYy9zdGF0ZS90aWNrLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBQb2ludCB9ID0gcmVxdWlyZSgncGFwZXInKVxyXG5cclxuY29uc3QgcGxheWVyU3BlZWQgPSAwLjE1XHJcbmNvbnN0IHBsYXllclJvdGF0ZVNwZWVkID0gMC41XHJcblxyXG5mdW5jdGlvbiB0aWNrKHN0YXRlLCBnYW1lVGltZSkge1xyXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgZGVsdGEnLCBnYW1lVGltZSAtIHN0YXRlLmdhbWVUaW1lKVxyXG4gICAgLy8gY29uc29sZS5sb2coJ3N0YXJ0aW5nIHBsYXllcicsIHN0YXRlLnBsYXllcjEpXHJcbiAgICBjb25zdCBwbGF5ZXIxID0gbW92ZUFuZFJvdGF0ZShzdGF0ZS5wbGF5ZXIxLCBzdGF0ZS5nYW1lVGltZSwgZ2FtZVRpbWUpXHJcbiAgICBjb25zdCBwbGF5ZXIyID0gbW92ZUFuZFJvdGF0ZShzdGF0ZS5wbGF5ZXIyLCBzdGF0ZS5nYW1lVGltZSwgZ2FtZVRpbWUpXHJcbiAgICAvL21vdmUgYnVsbGV0c1xyXG4gICAgLy9tb3ZlIGFzdGVyb2lkc1xyXG4gICAgLy8gY29uc29sZS5sb2cocGxheWVyMS5wb3NpdGlvbilcclxuICAgIC8vIGNvbnNvbGUubG9nKCdlbmRpbmcgcGxheWVyJywgcGxheWVyMSlcclxuICAgIHJldHVybiB7IC4uLnN0YXRlLCBnYW1lVGltZSwgcGxheWVyMSwgcGxheWVyMiB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmVBbmRSb3RhdGUob2JqLCBvbGRUaW1lLCBuZXdUaW1lKSB7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9ICFvYmouaXNNb3ZpbmcgP1xyXG4gICAgICAgIG9iai5wb3NpdGlvbiA6IG5leHRQb3NpdGlvbihvYmoucG9zaXRpb24sIG9iai5kaXJlY3Rpb24sIHBsYXllclNwZWVkLCBuZXdUaW1lIC0gb2xkVGltZSlcclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9ICFvYmoudHVybkRpcmVjdGlvbiA/XHJcbiAgICAgICAgb2JqLmRpcmVjdGlvbiA6IG5leHREaXJlY3Rpb24ob2JqLmRpcmVjdGlvbiwgb2JqLnR1cm5EaXJlY3Rpb24sIHBsYXllclJvdGF0ZVNwZWVkLCBuZXdUaW1lIC0gb2xkVGltZSlcclxuICAgIHJldHVybiB7IC4uLm9iaiwgcG9zaXRpb24sIGRpcmVjdGlvbiB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHRQb3NpdGlvbihzdGFydFBvc2l0aW9uLCBkaXJlY3Rpb24sIHNwZWVkLCB0aW1lRGVsdGEpIHtcclxuICAgIHN0YXJ0UG9zaXRpb24gPSB0b1BvaW50KHN0YXJ0UG9zaXRpb24pXHJcbiAgICBkaXJlY3Rpb24gPSB0b1BvaW50KGRpcmVjdGlvbilcclxuICAgIGNvbnN0IGRpc3RhbmNlID0gc3BlZWQgKiB0aW1lRGVsdGFcclxuICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbi5ub3JtYWxpemUoZGlzdGFuY2UpXHJcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24uYWRkKGRpcmVjdGlvbilcclxuICAgIHJldHVybiBmcm9tUG9pbnQobmV3UG9zaXRpb24pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5leHREaXJlY3Rpb24oc3RhcnRWZWN0b3IsIHR1cm5EaXJlY3Rpb24sIHJvdGF0ZVNwZWVkLCB0aW1lRGVsdGEpIHtcclxuICAgIGNvbnNvbGUubG9nKCd0aW1lIGRlbHRhOiAnLCB0aW1lRGVsdGEpXHJcbiAgICBjb25zdCByb3RhdGlvbiA9IHJvdGF0ZVNwZWVkICogdGltZURlbHRhXHJcbiAgICBzdGFydFZlY3RvciA9IHRvUG9pbnQoc3RhcnRWZWN0b3IpXHJcbiAgICBjb25zdCBuZXh0VmVjdG9yID0gc3RhcnRWZWN0b3Iucm90YXRlKHR1cm5EaXJlY3Rpb24gPT09IFwicmlnaHRcIiA/IHJvdGF0aW9uIDogLXJvdGF0aW9uKVxyXG4gICAgcmV0dXJuIGZyb21Qb2ludChuZXh0VmVjdG9yKVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b1BvaW50KHsgeCwgeSB9KSB7XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21Qb2ludCh7IHgsIHkgfSkge1xyXG4gICAgcmV0dXJuIHsgeCwgeSB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSB0aWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/state/tick.js\n");

/***/ }),

/***/ 0:
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd3MgKGlnbm9yZWQpP2RhMjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 1:
/*!********************************!*\
  !*** ./node/self.js (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlL3NlbGYuanMgKGlnbm9yZWQpPzE5MzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),

/***/ 2:
/*!**********************************!*\
  !*** ./node/extend.js (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlL2V4dGVuZC5qcyAoaWdub3JlZCk/MWZhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ })

/******/ });